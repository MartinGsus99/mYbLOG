---
title: 算法合集
date: 2023-07-27 10:00:00
categories:
  - 算法
tags:
  - 算法
  - 笔记
mp3:
cover: img/bg3.jpg
---

# 算法合集

### 969.烧饼排序

给你一个整数数组 `arr` ，请使用 **煎饼翻转** 完成对数组的排序。

一次煎饼翻转的执行过程如下：

- 选择一个整数 `k` ，`1 <= k <= arr.length`
- 反转子数组 `arr[0...k-1]`（**下标从 0 开始**）

例如，`arr = [3,2,1,4]` ，选择 `k = 3` 进行一次煎饼翻转，反转子数组 `[3,2,1]` ，得到 `arr = [**1**,**2**,**3**,4]` 。

以数组形式返回能使 `arr` 有序的煎饼翻转操作所对应的 `k` 值序列。任何将数组排序且翻转次数在 `10 * arr.length` 范围内的有效答案都将被判断为正确。

#### 思路：递归

1. 找到`n`个饼中最大的那个
2. 将其移动到最下面
3. 找出前`n-1`个中最大的，移动到倒数第二个
4. 以此类推

```js
//假设盘子上有n块面积大小不一的烧饼，如何用一把锅铲进行若干次翻转，使得烧饼大小有序
//每次只能翻转最上面的烧饼
//以数组形式返回能使 arr 有序的煎饼翻转操作所对应的 k 值序列。
//任何将数组排序且翻转次数在 10 * arr.length 范围内的有效答案都将被判断为正确。
/**
 * @param {number[]} arr
 * @return {number[]}
 */
//85.45 70.91
var pancakeSort = function (arr) {
  let res = []
  const sort = function (cakes, n) {
    if (n == 1) {
      return
    }

    let maxCake = 0
    let maxCakeIndex = 0
    for (let i = 0; i < n; i++) {
      if (cakes[i] > maxCake) {
        maxCakeIndex = i
        maxCake = cakes[i]
      }
    }
    reverse(cakes, 0, maxCakeIndex)
    res.push(maxCakeIndex + 1)
    reverse(cakes, 0, n - 1)
    res.push(n)
    console.log(cakes)
    sort(cakes, n - 1)
  }

  const reverse = function (arr, i, j) {
    while (i < j) {
      let temp = arr[i]
      arr[i] = arr[j]
      arr[j] = temp
      i++
      j--
    }
  }
  sort(arr, arr.length)
  console.log(cakes)
  return res
}

let cakes = [3, 2, 4, 1]

console.log(pancakeSort(cakes))
```
