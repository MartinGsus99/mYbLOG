{"title":"AES算法","uid":"c7c51dfefdf602928993bfcdc943bd20","slug":"AES","date":"2020-11-04T13:03:45.000Z","updated":"2020-11-04T13:03:20.000Z","comments":true,"path":"api/articles/AES.json","keywords":"Love And Freedom","cover":"img/mimaxue.jpg","content":"<h1 id=\"AES数学基础\"><a href=\"#AES数学基础\" class=\"headerlink\" title=\"AES数学基础\"></a><code>AES数学基础</code></h1><h2 id=\"1-有限域GF-2-8\"><a href=\"#1-有限域GF-2-8\" class=\"headerlink\" title=\"1.有限域GF(2^8)\"></a>1.有限域GF(2^8)</h2><p>AES以字节为单位进行计算，一个字节8bit。</p>\n<p>多项式表示法：01010111———&gt;x^6+x^4+x^2+x^1+x^0</p>\n<h2 id=\"2-算法的基本运算\"><a href=\"#2-算法的基本运算\" class=\"headerlink\" title=\"2.算法的基本运算\"></a>2.算法的基本运算</h2><h3 id=\"（1）加法、减法\"><a href=\"#（1）加法、减法\" class=\"headerlink\" title=\"（1）加法、减法\"></a>（1）加法、减法</h3><p>​    <strong>异或运算：01010111+10000011=11010100</strong></p>\n<h3 id=\"（2）乘法\"><a href=\"#（2）乘法\" class=\"headerlink\" title=\"（2）乘法\"></a>（2）乘法</h3><p>​    要计算有限域GF（2^8）上的乘法，需要确定一个GF(2)上的8次不可约多项式(除了1和自身没有任何其他因子)。</p>\n<p>​    对于AES，这个不可约多项式确定为：m(x)=x^8+x^4+x^3+x^1+x^0 (二进制表示：0000000100011011)</p>\n<p>​    在AES乘法中，需要将两数积mod m(x)。</p>\n<p>​    <strong>例：01010111*10000011=11000001</strong></p>\n<h3 id=\"（3）X乘运算\"><a href=\"#（3）X乘运算\" class=\"headerlink\" title=\"（3）X乘运算\"></a>（3）X乘运算</h3><pre><code> xtime()算法可用于面向字节的乘法运算。\n</code></pre>\n<p>​    根据定义，xtime()运算是最高项指数不大于7的多项式b(x)乘以多项式x的乘法运算</p>\n<p>​    例：b(x)=b7x7+b6x6+b5x5+b4x4+b3x3+b2x2+b1x+b0<br>​    xtime(b(x))=x·b(x)=(b7x8+b6x7+b5x6+b4x5+b3x4+b2x3+b1x2+b0x )mod m(x)<br>​    =(b7x8+b6x7+b5x6+b4x5+b3x4+b2x3+b1x2+b0x )mod (x8+x4+x3+x+1)</p>\n<p>分类讨论：</p>\n<p>（1）当b7=0：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201104210055963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTQ5NDI2,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>（2）当b7=1：<br><img src=\"https://img-blog.csdnimg.cn/20201104210107640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTQ5NDI2,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"AES算法描述\"><a href=\"#AES算法描述\" class=\"headerlink\" title=\"AES算法描述\"></a>AES算法描述</h1><h2 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1.概述\"></a>1.概述</h2><p>​    分组长度：128bit        密钥长度：128bit、192bit、256bit（密钥长度不同，加密轮数不同）</p>\n<p>​    基于Rijndael算法。</p>\n<h2 id=\"2-算法原理\"><a href=\"#2-算法原理\" class=\"headerlink\" title=\"2.算法原理\"></a>2.算法原理</h2><p>​    <strong>例：</strong></p>\n<p>​    已知：一轮输入状态矩阵：</p>\n<p>​    <strong>EA 04 65 85</strong></p>\n<p>​     <strong>83 45 5D 96</strong>  </p>\n<pre><code> **5C 33 98 B0**\n</code></pre>\n<p>​     <strong>F0 2D AD C5</strong></p>\n<h3 id=\"（1）字节代换：关于字节的非线性变换（利用S盒）。\"><a href=\"#（1）字节代换：关于字节的非线性变换（利用S盒）。\" class=\"headerlink\" title=\"（1）字节代换：关于字节的非线性变换（利用S盒）。\"></a>（1）字节代换：关于字节的非线性变换（利用S盒）。</h3><p><img src=\"https://img-blog.csdnimg.cn/20201104210124399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTQ5NDI2,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>代换结果：</p>\n<p><strong>87 F2 4D 97<br>EC 6E 4C 90<br>4A C3  46  E7<br>8C D8 95  A6</strong></p>\n<h3 id=\"（2）行位移：将状态矩阵各行进行循环位移\"><a href=\"#（2）行位移：将状态矩阵各行进行循环位移\" class=\"headerlink\" title=\"（2）行位移：将状态矩阵各行进行循环位移\"></a>（2）行位移：将状态矩阵各行进行循环位移</h3><p>​    第一行保持不变，第二行循环左移8bit，第三行循环左移16bit，第四行循环左移24bit</p>\n<p>位移结果：</p>\n<p><strong>87    f2    4d    97<br>6e    4c    90    ec       （左1）<br>46    e7    4a    c3        （左2）<br>a6    8c    d8    95</strong>        （左3）</p>\n<h3 id=\"（3）列混淆：将状态矩阵右乘列混淆矩阵，这个过程称为列混淆\"><a href=\"#（3）列混淆：将状态矩阵右乘列混淆矩阵，这个过程称为列混淆\" class=\"headerlink\" title=\"（3）列混淆：将状态矩阵右乘列混淆矩阵，这个过程称为列混淆\"></a>（3）列混淆：将状态矩阵<strong>右乘</strong>列混淆矩阵，这个过程称为列混淆</h3><p>混淆矩阵：<br><img src=\"https://img-blog.csdnimg.cn/20201104210138340.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201104210149908.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>混淆结果：</p>\n<p><strong>47    40    a3    4c<br>37    d4    70    9f<br>94    e4    3a    42<br>ed    a5    a6    bc</strong></p>\n<h3 id=\"（4）轮密钥加：用轮密钥矩阵的第-i-列，与上面得到的列混淆矩阵的第-i-列进行异或运算，得到最后的矩阵。\"><a href=\"#（4）轮密钥加：用轮密钥矩阵的第-i-列，与上面得到的列混淆矩阵的第-i-列进行异或运算，得到最后的矩阵。\" class=\"headerlink\" title=\"（4）轮密钥加：用轮密钥矩阵的第 i 列，与上面得到的列混淆矩阵的第 i 列进行异或运算，得到最后的矩阵。\"></a>（4）轮密钥加：用轮密钥矩阵的第 i 列，与上面得到的列混淆矩阵的第 i 列进行异或运算，得到最后的矩阵。</h3><h3 id=\"3-代码实现（C语言）\"><a href=\"#3-代码实现（C语言）\" class=\"headerlink\" title=\"3.代码实现（C语言）\"></a>3.代码实现（C语言）</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;bitset&gt;\nusing namespace std;\n \nint a[4][4] &#x3D; &#123;\n    &#123;0x87, 0xF2, 0x4D, 0x97&#125;,\n    &#123;0xEC, 0x6E, 0x4C, 0x90&#125;,\n    &#123;0x4A, 0xC3, 0x46, 0xE7&#125;,\n    &#123;0x8C, 0xD8, 0x95, 0xA6&#125;\n&#125;;&#x2F;&#x2F;字节代换后的矩阵\nint mixCol[4][4] &#x3D; &#123;\n    &#123;0x02, 0x03, 0x01, 0x01&#125;,\n    &#123;0x01, 0x02, 0x03, 0x01&#125;,\n    &#123;0x01, 0x01, 0x02, 0x03&#125;,\n    &#123;0x03, 0x01, 0x01, 0x02&#125;\n&#125;;&#x2F;&#x2F;列混淆矩阵\nint round_key[4][4] &#x3D; &#123;\n    &#123;0xAC, 0x19, 0x28, 0x57&#125;,\n    &#123;0x77, 0xFA, 0xD1, 0x5C&#125;,\n    &#123;0x66, 0xDC, 0x29, 0x00&#125;,\n    &#123;0xF3, 0x21, 0x41, 0x6A&#125;,\n&#125;;&#x2F;&#x2F;轮密钥矩阵\n \nint b[4][4];&#x2F;&#x2F;行移位后的矩阵\nint resMix[4][4];&#x2F;&#x2F;列混淆后的矩阵\nint res[4][4];&#x2F;&#x2F;轮密钥加后的矩阵\n \nint mul_mat(int x,int y) &#123;\n    if(x &#x3D;&#x3D; 0x01) &#123;\n        return y;\n    &#125;\n    else if(x &#x3D;&#x3D; 0x02) &#123;\n        if((y&amp;128) !&#x3D; 128) &#123; &#x2F;&#x2F;二进制首位为0\n            return y&lt;&lt;1;\n        &#125;\n        else &#123;\n            int temp &#x3D; ((y&lt;&lt;1)&amp;((1&lt;&lt;8)-1)); &#x2F;&#x2F;向左移一位，删掉最高位(保留8位)\n            return temp^(0x1b);\n        &#125;\n    &#125;\n    else if(x &#x3D;&#x3D; 0x03) &#123;\n        return mul_mat(0x02,y)^y;\n    &#125;\n&#125;\n \n \nint main() &#123;\n \n    cout&lt;&lt;&quot;字节代换后的矩阵为：&quot;&lt;&lt;endl;\n    for(int i&#x3D;0;i&lt;&#x3D;3;i++) &#123;\n        for(int j&#x3D;0;j&lt;&#x3D;3;j++) &#123;\n            cout&lt;&lt;hex&lt;&lt;a[i][j]&lt;&lt;&#39;\\t&#39;;\n        &#125;\n        cout&lt;&lt;endl;\n    &#125;\n \n    &#x2F;&#x2F;行移位\n    for(int i&#x3D;0;i&lt;&#x3D;3;i++)\n        for(int j&#x3D;0;j&lt;&#x3D;3;j++)\n            b[i][j] &#x3D; a[i][(i+j)%4];\n \n    cout&lt;&lt;&quot;行移位后的矩阵为：&quot;&lt;&lt;endl;\n    for(int i&#x3D;0;i&lt;&#x3D;3;i++) &#123;\n        for(int j&#x3D;0;j&lt;&#x3D;3;j++) &#123;\n            cout&lt;&lt;hex&lt;&lt;b[i][j]&lt;&lt;&#39;\\t&#39;;\n        &#125;\n        cout&lt;&lt;endl;\n    &#125;\n \n    &#x2F;&#x2F;列混淆\n    for(int i&#x3D;0;i&lt;&#x3D;3;i++) &#123;\n        for(int j&#x3D;0;j&lt;&#x3D;3;j++) &#123;\n            for(int k&#x3D;0;k&lt;&#x3D;3;k++) &#123;\n                resMix[i][j] ^&#x3D; mul_mat(mixCol[i][k],b[k][j]);\n            &#125;\n        &#125;\n    &#125;\n    cout&lt;&lt;&quot;列混淆后的矩阵为：&quot;&lt;&lt;endl;\n    for(int i&#x3D;0;i&lt;&#x3D;3;i++) &#123;\n        for(int j&#x3D;0;j&lt;&#x3D;3;j++) &#123;\n            cout&lt;&lt;hex&lt;&lt;resMix[i][j]&lt;&lt;&#39;\\t&#39;;\n        &#125;\n        cout&lt;&lt;endl;\n    &#125;\n \n    &#x2F;&#x2F;轮密钥加\n    for(int i&#x3D;0;i&lt;&#x3D;3;i++) &#123;\n        for(int j&#x3D;0;j&lt;&#x3D;3;j++) &#123;\n            res[j][i] &#x3D; resMix[j][i] ^ round_key[j][i];\n        &#125;\n    &#125;\n    cout&lt;&lt;&quot;轮密钥加后的矩阵为：&quot;&lt;&lt;endl;\n    for(int i&#x3D;0;i&lt;&#x3D;3;i++) &#123;\n        for(int j&#x3D;0;j&lt;&#x3D;3;j++) &#123;\n            cout&lt;&lt;hex&lt;&lt;res[i][j]&lt;&lt;&#39;\\t&#39;;\n        &#125;\n        cout&lt;&lt;endl;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n","text":"AES数学基础1.有限域GF(2^8)AES以字节为单位进行计算，一个字节8bit。 多项式表示法：01010111———&gt;x^6+x^4+x^2+x^1+x^0 2.算法的基本运算（1）加法、减法​ 异或运算：01010111+10000011=11010100 （2）乘...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[{"name":"密码学","slug":"密码学","count":2,"path":"api/categories/密码学.json"}],"tags":[{"name":"密码学","slug":"密码学","count":2,"path":"api/tags/密码学.json"},{"name":"AES","slug":"AES","count":1,"path":"api/tags/AES.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#AES%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">AES数学基础</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E6%9C%89%E9%99%90%E5%9F%9FGF-2-8\"><span class=\"toc-text\">1.有限域GF(2^8)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97\"><span class=\"toc-text\">2.算法的基本运算</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EF%BC%881%EF%BC%89%E5%8A%A0%E6%B3%95%E3%80%81%E5%87%8F%E6%B3%95\"><span class=\"toc-text\">（1）加法、减法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EF%BC%882%EF%BC%89%E4%B9%98%E6%B3%95\"><span class=\"toc-text\">（2）乘法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EF%BC%883%EF%BC%89X%E4%B9%98%E8%BF%90%E7%AE%97\"><span class=\"toc-text\">（3）X乘运算</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#AES%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\">AES算法描述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1.概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">2.算法原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EF%BC%881%EF%BC%89%E5%AD%97%E8%8A%82%E4%BB%A3%E6%8D%A2%EF%BC%9A%E5%85%B3%E4%BA%8E%E5%AD%97%E8%8A%82%E7%9A%84%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%EF%BC%88%E5%88%A9%E7%94%A8S%E7%9B%92%EF%BC%89%E3%80%82\"><span class=\"toc-text\">（1）字节代换：关于字节的非线性变换（利用S盒）。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EF%BC%882%EF%BC%89%E8%A1%8C%E4%BD%8D%E7%A7%BB%EF%BC%9A%E5%B0%86%E7%8A%B6%E6%80%81%E7%9F%A9%E9%98%B5%E5%90%84%E8%A1%8C%E8%BF%9B%E8%A1%8C%E5%BE%AA%E7%8E%AF%E4%BD%8D%E7%A7%BB\"><span class=\"toc-text\">（2）行位移：将状态矩阵各行进行循环位移</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EF%BC%883%EF%BC%89%E5%88%97%E6%B7%B7%E6%B7%86%EF%BC%9A%E5%B0%86%E7%8A%B6%E6%80%81%E7%9F%A9%E9%98%B5%E5%8F%B3%E4%B9%98%E5%88%97%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5%EF%BC%8C%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%E7%A7%B0%E4%B8%BA%E5%88%97%E6%B7%B7%E6%B7%86\"><span class=\"toc-text\">（3）列混淆：将状态矩阵右乘列混淆矩阵，这个过程称为列混淆</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EF%BC%884%EF%BC%89%E8%BD%AE%E5%AF%86%E9%92%A5%E5%8A%A0%EF%BC%9A%E7%94%A8%E8%BD%AE%E5%AF%86%E9%92%A5%E7%9F%A9%E9%98%B5%E7%9A%84%E7%AC%AC-i-%E5%88%97%EF%BC%8C%E4%B8%8E%E4%B8%8A%E9%9D%A2%E5%BE%97%E5%88%B0%E7%9A%84%E5%88%97%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5%E7%9A%84%E7%AC%AC-i-%E5%88%97%E8%BF%9B%E8%A1%8C%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%EF%BC%8C%E5%BE%97%E5%88%B0%E6%9C%80%E5%90%8E%E7%9A%84%E7%9F%A9%E9%98%B5%E3%80%82\"><span class=\"toc-text\">（4）轮密钥加：用轮密钥矩阵的第 i 列，与上面得到的列混淆矩阵的第 i 列进行异或运算，得到最后的矩阵。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%88C%E8%AF%AD%E8%A8%80%EF%BC%89\"><span class=\"toc-text\">3.代码实现（C语言）</span></a></li></ol></li></ol></li></ol>","author":{"name":"Martin","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Be Myself","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"机器学习-CH1-绪论","uid":"2040db2ad66b910dd82181cc41a30bd3","slug":"机器学习-CH1-绪论","date":"2020-11-05T12:56:45.000Z","updated":"2020-11-05T13:02:56.000Z","comments":true,"path":"api/articles/机器学习-CH1-绪论.json","keywords":"Love And Freedom","cover":"img/machinelearning.jpg","text":"一、引言机器学习致力于研究如何通过计算的手段，利用经验来改善系统性能。 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20201105204318313.png?x-oss-process=image/watermark,type_ZmFuZ3...","link":"","photos":[],"count_time":{"symbolsCount":617,"symbolsTime":"1 mins."},"categories":[{"name":"计算机科学","slug":"计算机科学","count":2,"path":"api/categories/计算机科学.json"}],"tags":[{"name":"机器学习","slug":"机器学习","count":2,"path":"api/tags/机器学习.json"}],"author":{"name":"Martin","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Be Myself","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"密码学","uid":"d4fbd980dccf88ac6beac6e4a1d0235b","slug":"密码学","date":"2020-11-03T13:44:45.000Z","updated":"2020-11-03T13:44:46.000Z","comments":true,"path":"api/articles/密码学.json","keywords":"Love And Freedom","cover":"img/mimaxue.jpg","text":"密码学概念总结 专注于密钥的保护而不是加密算法 1.对称密码 Alice和Bob使用相同的密钥和加密算法. 在A向B发送消息时,需要发送密钥.这会导致中间人C可以获得密钥破解密文. 因此需要好耗费人力和金钱安全传送密钥, 同时,一次会话使用一个密钥,导致密钥的保存冗杂. 2.公钥...","link":"","photos":[],"count_time":{"symbolsCount":398,"symbolsTime":"1 mins."},"categories":[{"name":"密码学","slug":"密码学","count":2,"path":"api/categories/密码学.json"}],"tags":[{"name":"密码学","slug":"密码学","count":2,"path":"api/tags/密码学.json"},{"name":"概论","slug":"概论","count":1,"path":"api/tags/概论.json"}],"author":{"name":"Martin","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Be Myself","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}