{"title":"React","uid":"d9e53d39e48f5c5aa42bf2e7c031bcd1","slug":"React","date":"2023-03-27T10:51:45.000Z","updated":"2023-03-27T11:03:25.639Z","comments":true,"path":"api/articles/React.json","keywords":"Love And Freedom","cover":"img/bg4.jpeg","content":"<h1 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h1><h2 id=\"一、应用\"><a href=\"#一、应用\" class=\"headerlink\" title=\"一、应用\"></a>一、应用</h2><ul>\n<li>前端应用</li>\n<li>移动原生</li>\n<li>桌面应用Electron  React 3D</li>\n</ul>\n<h2 id=\"二、原型\"><a href=\"#二、原型\" class=\"headerlink\" title=\"二、原型\"></a>二、原型</h2><ol>\n<li>Facebook在其php生态中引入了组合式组件的思想，启发了后来的react设计</li>\n<li>J.W创建了FaxJS,也就是React的原型；</li>\n<li>Facebook收购ins后，该项目在内使用，基于FaxJS创建了React；</li>\n</ol>\n<h2 id=\"三、React设计思路\"><a href=\"#三、React设计思路\" class=\"headerlink\" title=\"三、React设计思路\"></a>三、React设计思路</h2><h3 id=\"1-UI编程痛点\"><a href=\"#1-UI编程痛点\" class=\"headerlink\" title=\"1.UI编程痛点\"></a>1.UI编程痛点</h3><ul>\n<li>状态更新，UI不会自动更新，需要手动调用DOM</li>\n<li>欠缺基本的代码层面的封装和隔离，代码层面没有组件化</li>\n<li>UI之间的数据依赖关系需要手动维护，如果 依赖链条过长，会遇到“Callbace Hell”</li>\n</ul>\n<h3 id=\"2-响应式与转换式\"><a href=\"#2-响应式与转换式\" class=\"headerlink\" title=\"2.响应式与转换式\"></a>2.响应式与转换式</h3><ul>\n<li>转换式：给定输入求解输出；  （编译器、数值计算）</li>\n<li>响应式：监听事件没消息驱动； （监控系统、UI界面）</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">事件-&gt;执行既定的回调-&gt;状态更新-&gt;UI更新<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"3-响应式编程\"><a href=\"#3-响应式编程\" class=\"headerlink\" title=\"3.响应式编程\"></a>3.响应式编程</h3><ul>\n<li>状态更新，UI自动更新</li>\n<li>前端代码组件化、可复用、可封装</li>\n<li>状态之间的互相依赖关系、只需要声明计科</li>\n</ul>\n<h3 id=\"4-组件化\"><a href=\"#4-组件化\" class=\"headerlink\" title=\"4.组件化\"></a>4.组件化</h3><ul>\n<li>组件是组件的组合/原子组件</li>\n<li>组件内部拥有状态，外部不可见</li>\n<li>父组件可将状态传入组件内部</li>\n</ul>\n<h3 id=\"5-状态归属问题\"><a href=\"#5-状态归属问题\" class=\"headerlink\" title=\"5.状态归属问题\"></a>5.状态归属问题</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">Note：共享变量需要提升到最近的祖先组件、可以用状态管理解决；\nE.g:如果状态归属于两个节点，就向上寻找到最近的祖宗节点；<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><img src=\"https://s3.bmp.ovh/imgs/2023/01/30/edd9edf1a3d14f27.jpg\"></p>\n<blockquote>\n<p>Javascript中、函数是【一等公民】</p>\n<p>**通过向子组件传递function来改变根组件的变量（形成双向数据流）</p>\n</blockquote>\n<h3 id=\"6-思考\"><a href=\"#6-思考\" class=\"headerlink\" title=\"6.思考\"></a>6.思考</h3><ul>\n<li>React是单向数据流、还是双向数据流？</li>\n</ul>\n<blockquote>\n<p>其实是单向数据流，永远是父组件给子组件传递，并不代表子组件不能改变父组件数据；</p>\n</blockquote>\n<ul>\n<li>如何解决状态不合理上升的问题？（第五节解决）</li>\n</ul>\n<blockquote>\n<p>状态管理库</p>\n</blockquote>\n<ul>\n<li>组件的状态改变之后，如何更新DOM？（第四节解决）</li>\n</ul>\n<blockquote>\n<p>1</p>\n</blockquote>\n<h3 id=\"7-组件设计\"><a href=\"#7-组件设计\" class=\"headerlink\" title=\"7.组件设计\"></a>7.组件设计</h3><ul>\n<li>组件声明了状态和UI的映射；</li>\n<li>组件拥有Props/State两种状态；</li>\n<li>组件可由其他组件拼装而成；</li>\n</ul>\n<p>解法：</p>\n<ul>\n<li>组件内部拥有私有状态State</li>\n<li>组件接受外部的Props状态提供复用性</li>\n<li>根据当前的state/props返回一个UI</li>\n</ul>\n<pre class=\"line-numbers language-react\" data-language=\"react\"><code class=\"language-react\">function Component(props)&#123;\n    const &#123;url&#125;&#x3D;props;\n    this.text&#x3D;&#39;click me&#39;;\n    \n    return(\n    \t&lt;div&gt;\n        \t&lt;SubComponent props&#x3D;&#123;&#123;color:&#39;red&#39;&#125;&#125;&gt;&lt;&#x2F;SubComponent&gt;\n            &lt;img src&#x3D;&#123;url&#125;&gt;&lt;&#x2F;img&gt;\n            &lt;button&gt;clike me&lt;&#x2F;button&gt;\n        &lt;&#x2F;div&gt;\n    )\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"8-生命周期\"><a href=\"#8-生命周期\" class=\"headerlink\" title=\"8.生命周期\"></a>8.生命周期</h3><p><img src=\"https://s3.bmp.ovh/imgs/2023/01/30/4fc6e86cf176a88b.jpg\"></p>\n<h3 id=\"9-React-Hooks\"><a href=\"#9-React-Hooks\" class=\"headerlink\" title=\"9.React Hooks\"></a>9.React Hooks</h3><pre class=\"line-numbers language-react\" data-language=\"react\"><code class=\"language-react\">import React,&#123;useState&#125; from &#39;react&#39;;\n\nfunction Example()&#123;\n    &#x2F;&#x2F;声明一个新状态需要手动调用useState，返回一个状态和set该状态的函数；\n    const [count,setState]&#x3D;useState(0);\n    \n    &#x2F;&#x2F;传入一个函数和一个数组秘书组是状态的数组，称作依赖项，该函数在mount时执行\n    &#x2F;&#x2F;有“副作用”的函数，要传入useEffect来执行。副作用代表出来单纯的计算之外还要做其他事情。比如网络请求，更新DOM，localStorage存储数据等；\n    useEffect(()&#x3D;&gt;&#123;\n        document.title&#x3D;&#96;You clicked $&#123;count&#125; times&#96;;\n    &#125;)\n    \n    return(\n    \t&lt;div&gt;\n        \t&lt;p&gt;Clicked &#123; count &#125; times&lt;&#x2F;p&gt;\n            &lt;button onClick&#x3D;&#123;()&#x3D;&gt;setCount(count+1)&#125;&gt;Click +1&lt;&#x2F;button&gt;\n        &lt;&#x2F;div&gt;\n    )\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"Hook使用法则\"><a href=\"#Hook使用法则\" class=\"headerlink\" title=\"Hook使用法则\"></a>Hook使用法则</h3><ul>\n<li>不要在循环、条件或嵌套中调用hook</li>\n</ul>\n<h2 id=\"四、React实现\"><a href=\"#四、React实现\" class=\"headerlink\" title=\"四、React实现\"></a>四、React实现</h2><h3 id=\"1-Problems\"><a href=\"#1-Problems\" class=\"headerlink\" title=\"1.Problems\"></a>1.Problems</h3><ul>\n<li>JSX不符合JS语法标准；</li>\n</ul>\n<p><img src=\"https://s3.bmp.ovh/imgs/2023/01/30/1fc630e94d6d6c60.jpg\"></p>\n<ul>\n<li>返回的JSX发生改变时，如何更新DOM；</li>\n</ul>\n<blockquote>\n<p>计算新旧JSX的Difference</p>\n</blockquote>\n<ul>\n<li>指令式：说一步做一步</li>\n<li>声明式</li>\n<li>响应式</li>\n</ul>\n<p><img src=\"https://s3.bmp.ovh/imgs/2023/01/30/9ff90ed31b0de3e3.jpg\"></p>\n<p><img src=\"https://s3.bmp.ovh/imgs/2023/01/30/cf361645d5820a2d.jpg\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">state改变-&gt;计算diff-&gt;更新dom\n\nHow to diff?\n\n更新次数少&lt;----tradeoff----&gt;计算速度快\n完美的最小Diff算法，需要O(n^3)\n换取时间，需要O（n）<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<table>\n<thead>\n<tr>\n<th align=\"center\">元素</th>\n<th align=\"center\">更新方法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">不同类型元素</td>\n<td align=\"center\">替换</td>\n</tr>\n<tr>\n<td align=\"center\">同类型的DOM元素</td>\n<td align=\"center\">更新</td>\n</tr>\n<tr>\n<td align=\"center\">同类型的组件元素</td>\n<td align=\"center\">递归</td>\n</tr>\n</tbody></table>\n<p>弊病：最顶层的父组件状态发生改变，子组件全部更新</p>\n<ul>\n<li>state/props改变时，如何重新触发render函数；</li>\n</ul>\n<h2 id=\"五、React状态管理库\"><a href=\"#五、React状态管理库\" class=\"headerlink\" title=\"五、React状态管理库\"></a>五、React状态管理库</h2><h3 id=\"1-核心思想\"><a href=\"#1-核心思想\" class=\"headerlink\" title=\"1.核心思想\"></a>1.核心思想</h3><blockquote>\n<p>***将状态抽离到UI外部进行统一管理</p>\n<p>只存放需要共享的、距离较远的</p>\n</blockquote>\n<h3 id=\"2-常用管理库推荐\"><a href=\"#2-常用管理库推荐\" class=\"headerlink\" title=\"2.常用管理库推荐\"></a>2.常用管理库推荐</h3><ul>\n<li>redux</li>\n<li>xstate</li>\n<li>mobx</li>\n<li>recoil</li>\n</ul>\n<h3 id=\"3-状态机\"><a href=\"#3-状态机\" class=\"headerlink\" title=\"3.状态机\"></a>3.状态机</h3><blockquote>\n<p>当前状态，收到外部事件，迁移到下一个状态</p>\n</blockquote>\n<h3 id=\"4-ModernJS-Reduck\"><a href=\"#4-ModernJS-Reduck\" class=\"headerlink\" title=\"4.ModernJS/Reduck\"></a>4.ModernJS/Reduck</h3><h2 id=\"六、应用级框架科普\"><a href=\"#六、应用级框架科普\" class=\"headerlink\" title=\"六、应用级框架科普\"></a>六、应用级框架科普</h2><ul>\n<li>NextJS  (研究一下Vercel)</li>\n<li>ModernJS (Web Infra)全栈开发框架</li>\n<li>Blitz 无API思想的全栈开发框架，开发过程无需写API调用与CRUD逻辑 </li>\n</ul>\n","text":"React一、应用 前端应用 移动原生 桌面应用Electron React 3D 二、原型 Facebook在其php生态中引入了组合式组件的思想，启发了后来的react设计 J.W创建了FaxJS,也就是React的原型； Facebook收购ins后，该项目在内使用，基于F...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"前端","slug":"前端","count":37,"path":"api/categories/前端.json"}],"tags":[{"name":"笔记","slug":"笔记","count":41,"path":"api/tags/笔记.json"},{"name":"React","slug":"React","count":1,"path":"api/tags/React.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#React\"><span class=\"toc-text\">React</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">一、应用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E5%8E%9F%E5%9E%8B\"><span class=\"toc-text\">二、原型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81React%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">三、React设计思路</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-UI%E7%BC%96%E7%A8%8B%E7%97%9B%E7%82%B9\"><span class=\"toc-text\">1.UI编程痛点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%93%8D%E5%BA%94%E5%BC%8F%E4%B8%8E%E8%BD%AC%E6%8D%A2%E5%BC%8F\"><span class=\"toc-text\">2.响应式与转换式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">3.响应式编程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E7%BB%84%E4%BB%B6%E5%8C%96\"><span class=\"toc-text\">4.组件化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E7%8A%B6%E6%80%81%E5%BD%92%E5%B1%9E%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">5.状态归属问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E6%80%9D%E8%80%83\"><span class=\"toc-text\">6.思考</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">7.组件设计</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">8.生命周期</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-React-Hooks\"><span class=\"toc-text\">9.React Hooks</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Hook%E4%BD%BF%E7%94%A8%E6%B3%95%E5%88%99\"><span class=\"toc-text\">Hook使用法则</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81React%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">四、React实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-Problems\"><span class=\"toc-text\">1.Problems</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81React%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%BA%93\"><span class=\"toc-text\">五、React状态管理库</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3\"><span class=\"toc-text\">1.核心思想</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%B8%B8%E7%94%A8%E7%AE%A1%E7%90%86%E5%BA%93%E6%8E%A8%E8%8D%90\"><span class=\"toc-text\">2.常用管理库推荐</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E7%8A%B6%E6%80%81%E6%9C%BA\"><span class=\"toc-text\">3.状态机</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-ModernJS-Reduck\"><span class=\"toc-text\">4.ModernJS&#x2F;Reduck</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%AD%E3%80%81%E5%BA%94%E7%94%A8%E7%BA%A7%E6%A1%86%E6%9E%B6%E7%A7%91%E6%99%AE\"><span class=\"toc-text\">六、应用级框架科普</span></a></li></ol></li></ol>","author":{"name":"Martin","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Be Myself","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"NoDe JS 实战","uid":"e87d219c8babe95023e8a1174854d4ca","slug":"NodeJS实战读书笔记","date":"2023-03-27T10:51:45.000Z","updated":"2023-03-27T11:04:23.400Z","comments":true,"path":"api/articles/NodeJS实战读书笔记.json","keywords":"Love And Freedom","cover":"img/bg25.jpg","text":"NoDe JS 实战一、Welcome to node1.NodeJS基础 显著特征：异步、事件驱动机制 Node和JS的优势之一是单线程编程。为了实现同步，引入事件机制，点击按钮，触发事件，规避资源死锁和竞态条件 非阻塞I/O 程序可以在做其他事情的时候发起一个请求来获取网络资...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"前端","slug":"前端","count":37,"path":"api/categories/前端.json"}],"tags":[{"name":"笔记","slug":"笔记","count":41,"path":"api/tags/笔记.json"},{"name":"Node","slug":"Node","count":1,"path":"api/tags/Node.json"}],"author":{"name":"Martin","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Be Myself","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Vite知识体系","uid":"95a504c95e3e0ccf4ebea428f814913b","slug":"Vite知识体系","date":"2023-03-27T10:51:45.000Z","updated":"2023-03-27T11:02:58.494Z","comments":true,"path":"api/articles/Vite知识体系.json","keywords":"Love And Freedom","cover":"img/bg3.jpg","text":"Vite知识体系一、浅谈构建工具1. Why we need build tools? 模块化（ESM、CommonJS、UMD） 资源编译（高级语法的编译） 产物质量（代码提及、代码性能） 开发效率（热更新） 2.构建工具的意义 提供模块加载方案、兼容不同的模块规范； 高级语法...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"前端","slug":"前端","count":37,"path":"api/categories/前端.json"}],"tags":[{"name":"笔记","slug":"笔记","count":41,"path":"api/tags/笔记.json"},{"name":"项目构建","slug":"项目构建","count":1,"path":"api/tags/项目构建.json"}],"author":{"name":"Martin","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Be Myself","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}